<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>BlankSpace</title>
  <style>
    /* v4.8 — Fixed textbox loading + EXIF + metadata toggle + YouTube import + save/load + Google Maps + Apple-style background */
    :root{
      --bg:#0f1220; --panel:#161a2b; --text:#e8ecff; --muted:#aab2d5;
      --chip:rgba(255,255,255,.06); --radius:18px; --shadow:0 10px 30px rgba(0,0,0,.45);
      --accent:#8b5cf6; --danger:#ef4444; --group:#3b82f6;
      --handle-bg: rgba(255,255,255,.12); --handle-border: rgba(255,255,255,.55);
      --handle-bg-strong: rgba(255,255,255,.2);
      --node-border: rgba(255,255,255,.18);
      
      /* Apple-style background variables */
      --bg-hue: 220;          /* 200–260 = blue/purple Apple vibe */
      --bg-sat: 28%;          /* overall saturation */
      --bg-light: 12%;        /* base lightness (darker for dark theme) */
      --tile: 4098px;          /* 256/512/1024 */
      --grid-gap: 24px;       /* spacing of the micro dot grid */
      --grain-strength: 0.15; /* 0–0.15 suggested */
      --glow-opacity: 0.55;   /* intensity of aurora layer */
    }
    
    /* === Theme variables for wires & handles === */
    /* Default (dark theme) */
    :root {
      --wire-stroke: rgba(255,255,255,.95);
      --wire-shadow: rgba(0,0,0,.6);
      --handle-bg: rgba(255,255,255,.15);
      --handle-border: rgba(255,255,255,.8);
      --handle-icon: rgba(255,255,255,.95);
      --connect-hover-outline: #60a5fa;
    }
    /* Light theme overrides */
    :root.light, [data-theme="light"], .theme-light, body.light {
      --wire-stroke: rgba(17,17,17,.9) !important;
      --wire-shadow: rgba(0,0,0,.18) !important;
      --handle-bg: #fff !important;
      --handle-border: var(--accent) !important;
      --handle-icon: rgba(0,0,0,.9) !important;
      --connect-hover-outline: #3b82f6 !important;
    }
  
    /* === Wires layer sits BELOW nodes === */
    #wires {
      position:absolute; left:0; top:0;
      width:50000px; height:50000px;
      pointer-events:none;     /* wires never block */
      z-index:500;               /* behind nodes (which are z-index:auto/1+) */
      filter: drop-shadow(0 0 1px var(--wire-shadow));
    }
    .wire-path {
      fill:none;
      stroke: var(--wire-stroke);
      stroke-width: 3;
      stroke-linecap: round;
      stroke-linejoin: round;
      pointer-events: stroke;
    }
    /* Invisible larger hit area for wire paths */
    .wire-hit-area {
      fill: none;
      stroke: transparent;
      stroke-width: 12;
      stroke-linecap: round;
      stroke-linejoin: round;
      pointer-events: stroke;
      cursor: pointer;
    }
    /* "On-wire" handle groups (drag these) */
    .wire-handle {
      pointer-events:all;
      cursor:grab;
    }
    .wire-handle.dragging { cursor:grabbing; }
    .wire-handle .hit { fill: transparent; r: 18; } /* generous hit area */
    .wire-handle .dot { fill: var(--handle-bg); stroke: var(--handle-border); r: 8; stroke-width: 2; }
    .wire-handle .icon {
      fill: none; stroke: var(--handle-icon); stroke-width: 1.5;
    }
    /* Hover cue for connectable targets */
    .node.connect-hover, .textbox.connect-hover, .checknode.connect-hover {
      outline: 2px solid var(--connect-hover-outline);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--connect-hover-outline) 35%, transparent);
    }
    :root.light{
      --bg:#f7f8fc; --panel:#ffffff; --text:#0e132f; --muted:#5b627e;
      --chip:rgba(0,0,0,.06); --shadow:0 10px 25px rgba(0,0,0,.12);
      --handle-bg: rgba(0,0,0,.12); --handle-border: rgba(0,0,0,.55);
      --handle-bg-strong: rgba(0,0,0,.2);
      --node-border: rgba(0,0,0,.15);
      
      /* Light theme background adjustments */
      --bg-light: 98%;        /* lighter for light theme */
    }
    *{box-sizing:border-box}
    html,body,#root{height:100%}
    body{
      margin:0;color:var(--text);font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;overflow:hidden;
      
      /* Apple-style seamless background */
      background-image:
        /* 1) Micro dot grid (ultra‑subtle) */
        radial-gradient(rgba(255,255,255,.03) 1px, transparent 1.5px),
        /* 2) Fine diagonal fiber */
        repeating-linear-gradient(135deg, rgba(255,255,255,.02) 0 2px, transparent 2px 4px),
        /* 3) Aurora / glow tile (SVG with seamless turbulence) - dark theme */
        url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='1024'%3E%3Cdefs%3E%3ClinearGradient id='wash' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='hsl(220, 30%25, 15%25)'/%3E%3Cstop offset='100%25' stop-color='hsl(220, 30%25, 8%25)'/%3E%3C/linearGradient%3E%3Cfilter id='aurora' x='-20%25' y='-20%25' width='140%25' height='140%25'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.006' numOctaves='2' seed='8' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0.8 0 0.2 0 0  0 0.8 0.2 0 0  0.2 0 1.2 0 0  0 0 0 .3 0'/%3E%3CfeComponentTransfer%3E%3CfeFuncR type='gamma' amplitude='1.15' exponent='1.2'/%3E%3CfeFuncG type='gamma' amplitude='1.10' exponent='1.1'/%3E%3CfeFuncB type='gamma' amplitude='1.25' exponent='1.3'/%3E%3C/feComponentTransfer%3E%3CfeGaussianBlur stdDeviation='22'/%3E%3C/filter%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23wash)'/%3E%3Crect width='100%25' height='100%25' filter='url(%23aurora)' opacity='0.4'/%3E%3C/svg%3E"),
        /* 4) Soft base wash (CSS gradient) */
        linear-gradient(
          180deg,
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) + 2%)),
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) - 4%))
        );

      background-size:
        var(--grid-gap) var(--grid-gap),            /* dot grid size */
        var(--tile) var(--tile),                    /* diagonal fiber repeats on tile */
        var(--tile) var(--tile),                    /* aurora SVG tile */
        cover;                                      /* base wash fills */

      background-position: 0 0, 0 0, 0 0, 0 0;
      background-repeat: repeat, repeat, repeat, no-repeat;
      background-attachment: fixed;
      
      /* Extra polish for Apple‑ish depth */
      -webkit-font-smoothing: antialiased;
      backface-visibility: hidden;
    }
    
</style>

<style id="retro-theme-css">
/* === Retro Theme (warm paper + pastel accents) === */
:root.retro, [data-theme="retro"], .theme-retro, body.retro{
  --bg:#FFF7F0;
  --panel:#FFFFFF;
  --text:#1B1B1B;
  --muted:#727272;
  --chip:rgba(0,0,0,.06);
  --radius:18px;
  --shadow:0 10px 25px rgba(0,0,0,.12);
  --accent:#61C0BF;          /* Teal */
  --accent-2:#E0C3F6;        /* Lavender */
  --accent-3:#FCC5B3;        /* Peach */
  --node-border: rgba(0,0,0,.15);
  --handle-bg: rgba(0,0,0,.08);
  --handle-border: #61C0BF;
  --handle-bg-strong: rgba(0,0,0,.16);
  --handle-icon: #1B1B1B;
  --wire-stroke: rgba(17,17,17,.9);
  --wire-shadow: rgba(0,0,0,.15);
  --connect-hover-outline: #61C0BF;

  --bg-hue: 24;
  --bg-sat: 40%;
  --bg-light: 96%;
  --tile: 2048px;
  --grid-gap: 22px;
}

:root.retro body{
  background-image:
    radial-gradient(rgba(0,0,0,.06) 1px, transparent 1.6px),
    repeating-linear-gradient(135deg, rgba(0,0,0,.02) 0 2px, transparent 2px 4px),
    url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='1024'%3E%3Cdefs%3E%3Cfilter id='gn'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='1' stitchTiles='stitch'/%3E%3C/feTurbulence%3E%3C/filter%3E%3C/defs%3E%3Crect width='100%25' height='100%25' filter='url(%23gn)' opacity='.035'/%3E%3C/svg%3E"),
    linear-gradient(180deg, #FFF9F3, #FFEFE3);
  background-size:
    var(--grid-gap) var(--grid-gap),
    var(--tile) var(--tile),
    var(--tile) var(--tile),
    cover;
  background-position: 0 0, 0 0, 0 0, 0 0;
  background-repeat: repeat, repeat, repeat, no-repeat;
  background-attachment: fixed;
}

:root.retro button:hover,
:root.retro .panel-toggle:hover{ border-color: rgba(97,192,191,.6); }

:root.retro .checknode input[type="checkbox"]{ accent-color: var(--accent); }
</style>

<style>
   /* Light theme background override */
    :root.light body{
      background-image:
        /* 1) Micro dot grid (ultra‑subtle) */
        radial-gradient(rgba(0,0,0,.04) 1px, transparent 1.5px),
        /* 2) Fine diagonal fiber */
        repeating-linear-gradient(135deg, rgba(0,0,0,.03) 0 2px, transparent 2px 4px),
        /* 3) Aurora / glow tile (SVG with seamless turbulence) - light theme */
        url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1024' height='1024'%3E%3Cdefs%3E%3ClinearGradient id='wash' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='hsl(220, 30%25, 99%25)'/%3E%3Cstop offset='100%25' stop-color='hsl(220, 30%25, 95%25)'/%3E%3C/linearGradient%3E%3Cfilter id='aurora' x='-20%25' y='-20%25' width='140%25' height='140%25'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.006' numOctaves='2' seed='8' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 .75 0'/%3E%3CfeComponentTransfer%3E%3CfeFuncR type='gamma' amplitude='1.15' exponent='1.2'/%3E%3CfeFuncG type='gamma' amplitude='1.10' exponent='1.1'/%3E%3CfeFuncB type='gamma' amplitude='1.25' exponent='1.3'/%3E%3C/feComponentTransfer%3E%3CfeGaussianBlur stdDeviation='22'/%3E%3C/filter%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23wash)'/%3E%3Crect width='100%25' height='100%25' filter='url(%23aurora)' opacity='0.66'/%3E%3C/svg%3E"),
        /* 4) Soft base wash (CSS gradient) */
        linear-gradient(
          180deg,
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) + 0%)),
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) - 3%))
        );
    }
    .topbar{
      position:fixed; inset:0 0 auto 0; height:64px; display:flex; align-items:center; justify-content:space-between;
      padding:0 16px; background:linear-gradient(180deg, rgba(0,0,0,.3), rgba(0,0,0,0)); z-index:1000; pointer-events:none;
    }
    .topbar .actions button, .topbar select{pointer-events:auto}
    .brand{display:flex; gap:12px; align-items:center}
    .logo{width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg,#74ebd5,#ACB6E5)}
    .title{font-weight:700}
    .subtitle{font-size:12px; color:var(--muted)}
    .actions{display:flex; gap:8px}
    button{
      background:var(--panel); color:var(--text); border:1px solid rgba(255,255,255,.08); border-color: var(--accent);
      border-radius:10px; padding:8px 12px; box-shadow:var(--shadow); cursor:pointer;
    }
    button:hover{filter:brightness(1.1)}
    button:active{transform:translateY(1px)}
    button.danger{background:rgba(239,68,68,.15); border-color:rgba(239,68,68,.35)}

/* Unique capsule select for the Theme control */
#theme {
  /* reset */
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  outline: none;

  /* layout */
  display: inline-block;
  padding: 10px 44px 10px 44px;   /* room for color dots on the left */
  background-color: var(--panel);
  border-radius: 999px;
  font-weight: 700;
  line-height: 1;

  /* palette (inherits from your vars) */
  --ts-bg:    var(--panel, #fff);
  --ts-ink:   var(--text, #1B1B1B);
  --ts-ring:  var(--accent, #61C0BF);
  --ts-shadow: var(--shadow, 0 10px 25px rgba(0,0,0,.12));

  color: var(--ts-ink);
  border: 1.5px solid var(--ts-ring);
  box-shadow: var(--ts-shadow);
  cursor: pointer;
}
#theme:hover { filter: brightness(1.02); }
#theme:focus-visible { box-shadow: 0 0 0 3px color-mix(in oklab, var(--ts-ring), transparent 75%); }
#theme::-ms-expand { display: none; }  /* hide IE arrow */
#theme option { background: var(--ts-bg); color: var(--ts-ink); }

/* ===== Retro mode: stronger outline + offset pastel drop-shadows ===== */
html.retro #theme {
  border-color: #1B1B1B;
  box-shadow:
    0 0 0 1.5px #1B1B1B,          /* crisp ink outline */
    8px 10px 0 #FCC5B3,           /* peach offset */
    -2px -2px 0 #61C0BF;          /* teal offset */
}

    /* URL Import Panel */
    .url-panel{
      position:fixed; top:80px; left:16px; width:320px; background:var(--panel); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:16px; box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    .url-panel h3{margin:0 0 12px; font-size:14px; font-weight:600}
    .url-panel input{
      width:100%; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      border-radius:8px; padding:8px 12px; color:var(--text); font-size:14px; margin-bottom:8px;
    }
    .url-panel input:focus{outline:none; border-color:var(--accent)}
    .url-panel .url-buttons{display:flex; gap:8px}
    .url-panel button{padding:6px 12px; font-size:12px}
    .url-panel .url-types{
      font-size:11px; color:var(--muted); margin-bottom:8px; line-height:1.4;
    }

    /* Save/Load Panel */
    .save-panel{
      position:fixed; top:80px; right:16px; width:320px; background:var(--panel); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:16px; box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    .save-panel h3{margin:0 0 12px; font-size:14px; font-weight:600}
    .save-panel .save-buttons{display:flex; gap:8px; margin-bottom:12px}
    .save-panel .save-list{max-height:150px; overflow-y:auto}
    .save-item{
      display:flex; justify-content:space-between; align-items:center; padding:8px;
      background:rgba(255,255,255,.04); border-radius:6px; margin-bottom:6px; font-size:12px;
    }
    .save-item button{padding:4px 8px; font-size:11px}

    /* Google Maps Modal */
    .map-modal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 400px; background: var(--panel); border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px; padding: 24px; box-shadow: var(--shadow); z-index: 2000;
      backdrop-filter: blur(20px);
    }
    .map-modal h3 {
      margin: 0 0 16px; font-size: 18px; font-weight: 600; text-align: center;
    }
    .map-modal .input-group {
      margin-bottom: 16px;
    }
    .map-modal label {
      display: block; margin-bottom: 6px; font-size: 14px; font-weight: 500;
    }
    .map-modal input {
      width: 100%; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px; padding: 10px 12px; color: var(--text); font-size: 14px;
    }
    .map-modal input:focus {
      outline: none; border-color: var(--accent);
    }
    .map-modal .modal-buttons {
      display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;
    }
    .map-modal button {
      padding: 8px 16px; font-size: 14px;
    }
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 1999;
      backdrop-filter: blur(4px);
    }

    #viewport{position:absolute; inset:0; overflow:hidden; cursor:grab}
    #viewport.dragging{cursor:grabbing}
    #board{position:absolute; inset:auto; transform-origin:0 0; outline:none}

    .node{
      position:absolute; border-radius:20px; background:var(--panel); box-shadow:var(--shadow);
      border:1px solid var(--node-border); 
      scrollbar-width: thin;
      user-select:none; cursor:grab; 
      scrollbar-color: var(--accent) var(--handle-bg);
      scrollbar-width: thin; z-index: 1000;
    }
    .node:active{cursor:grabbing}
    .node.selected{outline:2px solid var(--accent)}
    .node .content{width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,.02)}
    .node .toolbar{position:absolute; top:6px; right:6px; display:flex; gap:6px; z-index:1000}
    .node .toolbar button{padding:4px 8px; font-size:12px}

    /* Node title styling - minimal like groups */
    .node .title{
      position:absolute; z-index: 1100; top:-14px; left:16px; padding:2px 8px; background:var(--panel); 
      border-radius:999px; border:1px solid rgba(255,255,255,.08); font-size:12px;
      max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      cursor:pointer; transition:all 0.2s ease;
    }
    .node .title:hover{
      background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.15);
    }
    .node .title.editing{
      background:rgba(255,255,255,.1); border-color:var(--accent); outline:1px solid var(--accent);
      cursor:text;
    }

    .node.image img{width:100%; height:100%; object-fit:contain; background: var(--bg);
    position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
    }
    .node.video video{width:100%; height:100%; background: var(--bg);
    position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
    }
    .node.pdf iframe, .node.pdf embed{width:100%; height:100%; background: var(--bg); 
    position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
    }
    .node.youtube iframe{width:100%; height:100%; border:none; border-radius:16px;
    position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
    }
    .node.map iframe{width:100%; height:100%; border:none; border-radius:16px;
    position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
    }
    .node.website iframe{width:100%; height:100%; border:none; border-radius:16px;
    position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
    overflow: auto;
    scrollbar-color: var(--accent) var(--handle-bg);
    scrollbar-width: thin;
    }

    /* Glassmorphism textbox styling - adapted from glassmorphism file */
    .textbox {
      position: absolute;
      min-width: 120px;
      min-height: 70px;
      cursor: grab;
      z-index: 1600;
      white-space: pre-wrap;
      word-break: break-word;
      text-align: left;
      font-size: 18px;
      line-height: 1.5;
      resize: both;
      overflow: auto;
      scrollbar-color: var(--accent) var(--handle-bg);
      scrollbar-width: thin;
      
      /* Glassmorphism styling */
      padding: 14px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.35);
      outline: none;
      
      /* Glass base */
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(14px) saturate(160%);
      -webkit-backdrop-filter: blur(14px) saturate(160%);
      
      /* Subtle white-only gradient for depth on the border */
      background-image:
        linear-gradient(rgba(255,255,255,0.10), rgba(255,255,255,0.10)),
        linear-gradient(135deg, rgba(255,255,255,0.85), rgba(255,255,255,0.45));
      background-origin: border-box;
      background-clip: padding-box, border-box;
      
      /* Gentle inner/outer glow to lift from bg */
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.35), /* top bevel */
        inset 0 -1px 0 rgba(255,255,255,0.12), /* bottom shade */
        0 8px 30px rgba(0,0,0,0.35),
        0 0 24px rgba(255,255,255,0.04);
      
      color: var(--text);
      transition: box-shadow .35s ease, transform .35s ease, border-color .35s ease;
    }
    
    /* Animated sheen for texture */
    .textbox::before {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 13px;
      pointer-events: none;
      background:
        radial-gradient(120% 60% at 20% 10%, rgba(255,255,255,0.22), rgba(255,255,255,0) 60%),
        radial-gradient(140% 80% at 80% 120%, rgba(255,255,255,0.10), rgba(255,255,255,0) 60%),
        linear-gradient(115deg, rgba(255,255,255,0.00) 35%, rgba(255,255,255,0.22) 50%, rgba(255,255,255,0.00) 65%);
      background-size: auto, auto, 300% 100%;
      background-position: center center, center center, -150% 0;
      background-repeat: no-repeat;
      mix-blend-mode: screen;
      will-change: background-position;
      animation: textbox-sheen 5.5s ease-in-out infinite;
    }
    
    /* Subtle animated micro-texture */
    .textbox::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 13px;
      pointer-events: none;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0 1px, rgba(255,255,255,0.00) 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0 2px, rgba(255,255,255,0.00) 2px 5px);
      opacity: .7;
      filter: contrast(110%) saturate(120%);
      background-size: 100% 300%, 300% 100%;
      will-change: background-position;
      animation: textbox-micro 14s linear infinite;
    }
    
    @keyframes textbox-sheen {
      0%   { background-position: center center, center center, -150% 0; }
      50%  { background-position: center center, center center, 150% 0; }
      100% { background-position: center center, center center, 150% 0; }
    }
    
    @keyframes textbox-micro {
      0%   { background-position: 0 0, 0 0; }
      100% { background-position: 0 100%, 100% 0; }
    }
    
    .textbox:hover {
      border-color: rgba(255,255,255,.45);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.45),
        inset 0 -1px 0 rgba(255,255,255,0.18),
        0 10px 40px rgba(0,0,0,0.45),
        0 0 36px rgba(255,255,255,0.08);
    }
    
    .textbox:focus {
      outline: none;
      cursor: text !important;
      border-color: rgba(255,255,255,0.6);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.45),
        inset 0 -1px 0 rgba(255,255,255,0.18),
        0 10px 40px rgba(0,0,0,0.45),
        0 0 36px rgba(255,255,255,0.08);
      transform: translateY(-1px);
    }
    
    .textbox.selected {
      border-color: var(--accent);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.45),
        inset 0 -1px 0 rgba(255,255,255,0.18),
        0 8px 24px rgba(0,0,0,.45), 
        0 0 0 2px var(--accent);
    }
    
    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .textbox::before,
      .textbox::after { 
        animation: none; 
      }
    }
    
    /* Make it obvious links are clickable in the textbox */
    .textbox a { 
      text-decoration: underline; 
      cursor: pointer; 
    }
    /* Ensure links are not accidentally "blocked" by overlays */
    .textbox a { 
      pointer-events: auto; 
    }
    
    .textbox .tb-resizer{
      position:absolute; width:12px; height:12px; right:-6px; bottom:-6px; 
      background:var(--handle-bg); border:2px solid var(--handle-border); 
      border-radius:50%; cursor:nwse-resize; z-index: 1650;
      transition: all 0.2s ease;
      opacity: 0.6;
    }
    .textbox:hover .tb-resizer, .textbox.selected .tb-resizer{
      opacity: 1;
      background:var(--handle-bg-strong);
    }
    .textbox .tb-resizer:hover{
      transform: scale(1.2);
    }

    /* Metadata textbox: vertical orientation (narrow column) */
    .textbox.metadata{
      width:280px;
    }
    .textbox .section-title{
      font-weight:700; font-size:18px; opacity:.9; margin:6px 0 4px;
    }
    .textbox .kv{display:grid; grid-template-columns:92px 1fr; gap:4px 8px; font-size:12px; color:var(--muted)}
    .textbox .kv div:nth-child(odd){opacity:.9}
    .textbox .kv div:nth-child(even){color:var(--text)}

    .group{
      position:absolute; z-index: 0; border:2px dashed var(--group); border-radius:24px; background:rgba(59,130,246,.06);
    }
    .group .title{
      position:absolute; top:-14px; left:16px; padding:2px 8px; background:var(--panel); border-radius:999px; border:1px solid rgba(255,255,255,.08); font-size:12px;
      cursor:pointer; transition:all 0.2s ease;
    }
    .group .title:hover{
      background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.15);
    }
    .group .title.editing{
      background:rgba(255,255,255,.1); border-color:var(--accent); outline:1px solid var(--accent);
      cursor:text;
    }
    .group.selected{outline:2px solid var(--accent)}
    .group .resizer{position:absolute; width:12px; height:12px; right:-6px; bottom:-6px; background:var(--handle-bg); border:2px solid var(--handle-border); border-radius:50%; cursor:nwse-resize}


    
    .marquee{position:absolute; border:5px dashed var(--accent); background:rgba(255,255,255,.1); pointer-events:none; z-index:2000}

    .menu{position:absolute; display:none; flex-direction:column; background:var(--panel); border:1px var(--panel-border); border-radius:10px; padding:6px; z-index:2000; }
    .menu.open{display:flex}
    .menu button{background:transparent; border:none; text-align:left; padding:8px 12px; border-radius:8px}
    .menu button:hover{background:rgba(255,255,255,.06)}
    .menu hr{border:none; border-top:1px solid rgba(255,255,255,.08); margin:6px 0}

    .scale-bar{
      position:fixed; left:12px; bottom:12px; display:flex; align-items:center; gap:10px; z-index:1500;
      background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.1); padding:6px 10px; border-radius:999px; backdrop-filter: blur(6px);
    }

    /* Drag and drop overlay */
    .drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(139, 92, 246, 0.1);
      border: 3px dashed var(--accent);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
    .drop-overlay.active {
      display: flex;
    }
    .drop-message {
      background: var(--panel);
      padding: 24px 32px;
      border-radius: 16px;
      border: 1px solid var(--accent);
      box-shadow: var(--shadow);
      text-align: center;
      pointer-events: none;
    }
    .drop-message h3 {
      margin: 0 0 8px;
      color: var(--accent);
      font-size: 18px;
      font-weight: 600;
    }
    .drop-message p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
    
    /* ===== Standalone Checklist Node ===== */
    .checknode{
      position:absolute;
      left:200px; top:200px;
      display:flex; align-items:center; gap:.5rem;
      padding:.5rem .75rem;
      border:1px solid var(--node-border);
      background:var(--panel);
      border-radius:.5rem;
      box-shadow:var(--shadow);
      user-select:(none);
      color:var(--text);
      cursor:default;
      transition:box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .checknode:hover{
      border-color:rgba(255,255,255,.25);
      box-shadow:0 6px 20px rgba(0,0,0,.3);
    }
    :root.light .checknode:hover{
      border-color:rgba(0,0,0,.2);
      box-shadow:0 6px 20px rgba(0,0,0,.15);
    }
    /* Drag handle (visual grip) */
    .checknode .drag-handle{
      width:10px; height:20px; flex:0 0 10px;
      display:inline-block;
      border-radius:3px;
      background-image:
        radial-gradient(currentColor 1px, transparent 1px),
        radial-gradient(currentColor 1px, transparent 1px);
      background-position: 0 0, 5px 10px;
      background-size: 5px 10px;
      opacity:.65;
      cursor:grab;
      color:var(--muted);
    }
    .checknode .drag-handle:active { cursor:grabbing; }
    .checknode .drag-handle:hover { opacity:.9; }

    .checknode input[type="checkbox"]{
      width:1rem; height:1rem; margin:0; flex:0 0 auto; pointer-events:auto;
      accent-color:var(--accent); background-color: var(--bg);
    }

    .checknode .checktext{
      outline:none; min-width:2ch; max-width:36ch;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      user-select:text; cursor:text;
      color:var(--text);
    }
    .checknode .checktext:focus{
      outline:2px solid var(--accent);
      outline-offset:2px;
      border-radius:4px;
    }
  </style>

<style>
/* X (Twitter) node visual parity */
.node.twitter {
  position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
}
.node.twitter .tweet-host{
  border-radius:16px; 
  overflow:hidden;
  background: var(--bg);
}
</style>
<style>
/* Video node parity */
.node.video {
  position:absolute; border-radius: 16px; padding: 8px; box-shadow: var(--shadow); z-index: 1000;
}
.node.video .video-host{ border-radius:16px; overflow:hidden; background: var(--bg);}
</style>
<style>

  /* === Floating Text Toolbar (injected) === */
  #textToolbar.ftb { position: fixed; left: -9999px; top: -9999px; z-index: 9999; opacity: 0; pointer-events: none; transition: opacity .18s ease, transform .18s ease; transform: translateY(4px); }
  #textToolbar.ftb.is-visible { opacity: 1; pointer-events: auto; transform: translateY(0); }
  .ftb-row { display:flex; align-items:center; gap:6px; padding:10px; border-radius:22px; background: rgba(30,35,42,.55); backdrop-filter: blur(14px) saturate(160%); -webkit-backdrop-filter: blur(14px) saturate(160%); border:1px solid rgba(255,255,255,.20); box-shadow:0 12px 30px rgba(0,0,0,.45); }
  .ftb-sep { width:1px; height:26px; background:rgba(255,255,255,.18); margin:0 4px; }
  .ftb-btn { min-width:34px; height:34px; padding:0 10px; border:0; border-radius:12px; cursor:pointer; background: rgba(255,255,255,.08); color:#e9eef5; font:600 13px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; display:grid; place-items:center; user-select:none; }
  .ftb-btn:hover { filter: brightness(1.1); }
  .ftb-btn:active { transform: translateY(0.5px); }
  .ftb-btn[disabled]{ opacity:.45; cursor:not-allowed; }
  .ftb-btn.is-active{ outline: 2px solid rgba(255,255,255,.25); }
  .ftb-swatch { width:34px; height:34px; display:grid; place-items:center; border-radius:12px; background:rgba(255,255,255,.08); cursor:pointer; overflow:hidden; }
  .ftb-swatch input[type="color"]{ width:34px; height:34px; border:0; padding:0; background:transparent; appearance:none; }
  .ftb-link, .ftb-select, .ftb-number { height:34px; border-radius:12px; border:1px solid rgba(255,255,255,.20); background: rgba(255,255,255,.06); color:#e9eef5; padding:0 10px; }
  .ftb-link{ width:208px; } .ftb-select{ min-width:150px; } .ftb-number{ width:74px; }
  .ftb-unit{ opacity:.7; font-size:12px; margin-left:-6px; margin-right:4px; }
  #tbFont{ background:#fff; color:#111827; border-color:#fff; font-weight:600; }
  #tbFont:focus{ outline:2px solid #fff; }
  /* === End Floating Text Toolbar === */

</style>
<style>

  /* === Floating Spotlight Search (injected) === */
  #spotlightOverlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,.45);
    backdrop-filter: blur(10px) saturate(140%);
    -webkit-backdrop-filter: blur(10px) saturate(140%);
    display: none;
    align-items: center; justify-content: center;
    z-index: 10000;
  }
  #spotlightOverlay.is-open { display: flex; }
  .spotlight-card {
    width: min(720px, 92vw);
    border-radius: 18px;
    background: rgba(30,35,42,.92);
    border: 1px solid rgba(255,255,255,.18);
    box-shadow: 0 24px 70px rgba(0,0,0,.6);
    padding: 16px;
  }
  .spotlight-row {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
    align-items: center;
  }
  .spotlight-input {
    height: 44px;
    border: 1px solid rgba(255,255,255,.25);
    background: rgba(255,255,255,.06);
    color: #e9eef5;
    border-radius: 12px;
    padding: 0 14px;
    font: 600 15px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    outline: none;
  }
  .spotlight-input::placeholder { color: #b3c0cf; }
  .spotlight-btn {
    height: 44px; padding: 0 14px;
    border: 0; border-radius: 12px;
    background: white; color: #111827;
    font: 700 14px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    cursor: pointer;
  }
  .spotlight-hint {
    margin-top: 10px; font-size: 12px; color: var(--accent);
    display: flex; justify-content: space-between;
  }
  .kbd { 
    display:inline-grid; place-items:center; 
    min-width: 22px; height: 22px; padding: 0 6px;
    background: rgba(255,255,255,.14); color: var(--text); 
    border-radius: 6px; font-weight: 700; 
    border: 1px solid rgba(255,255,255,.22);
  }
  /* === End Spotlight Search === */

</style>
<style>

  /* === Canvas Bottom-Center Description (injected) === */
  /* Fallback when appended to 
<body>
  <button id="shareButton" style="position: fixed; top: 10px; right: 10px; padding: 10px; background-color: #4CAF50; color: white; border: none; border-radius: 5px;">Share Mood Board</button>

  <!-- Modal for Share Link -->
  <div class="modal-overlay" id="modalOverlay" style="display: none;"></div>
  <div id="shareModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 600px; background: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 8px; z-index: 1000;">
    <h2>Share Your Mood Board</h2>
    <input type="text" id="shareLink" readonly placeholder="Generated link will appear here..." style="width: 100%; padding: 10px; background-color: #333; color: white; border: none; border-radius: 5px; text-align: center;">
    <button id="copyLinkButton" style="padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">Copy Link</button>
  </div>

  <script>
    // Example of mood board state (this would be dynamically captured)
    const boardState = {
      nodes: [{ id: 1, x: 100, y: 100, width: 200, height: 200, content: 'Node 1' }],
      zoom: 1.0,
      pan: { x: 0, y: 0 }
    };

    // Function to serialize the state and generate the URL
    function serializeState(state) {
      return btoa(JSON.stringify(state)); // Base64 encode the serialized state
    }

    // Function to show the share modal
    function showShareModal() {
      const serializedState = serializeState(boardState);
      const link = window.location.href.split('?')[0] + '?state=' + serializedState;
      document.getElementById('shareLink').value = link;
      document.getElementById('modalOverlay').style.display = 'block';
      document.getElementById('shareModal').style.display = 'block';
    }

    // Function to copy the link to the clipboard
    function copyLink() {
      const shareLink = document.getElementById('shareLink');
      shareLink.select();
      document.execCommand('copy');
      alert('Link copied to clipboard!');
    }

    // Event listener for the share button
    document.getElementById('shareButton').addEventListener('click', showShareModal);

    // Event listener for the copy link button
    document.getElementById('copyLinkButton').addEventListener('click', copyLink);

    // Close modal when overlay is clicked
    document.getElementById('modalOverlay').addEventListener('click', () => {
      document.getElementById('modalOverlay').style.display = 'none';
      document.getElementById('shareModal').style.display = 'none';
    });
  </script>
 */
  #canvasDescription {
    position: fixed;
    left: 50%;
    bottom: 12px;
    transform: translateX(-50%);
    z-index: 9000;
    color: #b3c0cf;
    font: 700 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    letter-spacing: .02em;
    opacity: .85;
    text-shadow: 0 1px 1px rgba(0,0,0,.35);
    pointer-events: none; /* never blocks canvas interactions */
    user-select: none;
    background: transparent;
    border: 0;
    padding: 0;
  }
  /* Preferred when inside #viewport (canvas) */
  #viewport #canvasDescription {
    position: absolute;
    left: 50%;
    bottom: 12px;
    transform: translateX(-50%);
  }
  /* === End Description === */

</style>


<style id="oscar-black-gold-rim">
/* ======================================================================
   OSCAR → "Nebula Slate" Dark Neumorphic Theme
   A full revamp to match the reference dashboard: soft surfaces, depth,
   subtle texture, teal/blue accents, and crisp typography.
   ====================================================================== */
:root{ color-scheme: dark; }

/* ---------- Core palette & tokens ---------- */
html:not(.light):not(.retro){
  --bg:#0e141c;             /* page background (very deep slate) */
  --bg-2:#111a24;           /* slightly lighter layer */
  --panel:#1a2330;          /* main card surface */
  --panel-2:#18202b;        /* deeper surface for contrast */
  --panel-3:#141b25;        /* darkest inset surface */
  --text:#e8edf7;           /* primary text */
  --text-dim:#a6b2c7;       /* secondary text */
  --text-faint:#7d8ba3;     /* tertiary */
  --hairline:rgba(255,255,255,.06);
  --hairline-strong:rgba(255,255,255,.12);
  --rim-dark:rgba(0,0,0,.45);

  /* Accent system (derived from reference) */
  --cyan:#22d3ee;
  --blue:#60a5fa;
  --purple:#a78bfa;
  --yellow:#f59e0b;
  --green:#22c55e;
  --danger:#ef4444;

  /* Depth & glow */
  --sh-1:0 1px 2px rgba(0,0,0,.35);
  --sh-2:0 8px 22px rgba(0,0,0,.55);
  --sh-3:0 24px 64px rgba(0,0,0,.6);
  --inset-1:inset 0 1px 0 rgba(255,255,255,.05);
  --inset-2:inset 0 -1px 0 rgba(0,0,0,.45);

  /* Controls */
  --input-bg:rgba(255,255,255,.06);
  --input-bd:rgba(255,255,255,.12);
  --input-hover:rgba(255,255,255,.08);
  --focus: color-mix(in srgb, var(--cyan) 60%, transparent);
}

/* ---------- Page background with vignette + micro texture ---------- */
html:not(.light):not(.retro) body{
  margin:0;
  color:var(--text);
  background:
    radial-gradient(1200px 700px at 25% -10%, rgba(255,255,255,.05), transparent 60%),
    radial-gradient(1600px 900px at 90% -20%, rgba(255,255,255,.04), transparent 65%),
    linear-gradient(180deg, #0f1720 0%, #0e141c 60%, #0d131b 100%);
  position:relative;
  overflow-x:hidden;
}

/* Subtle grain using CSS-only noise dither (no external assets) */
html:not(.light):not(.retro) body::before{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  opacity:.18;
  background-image:
    repeating-conic-gradient(from 0deg, rgba(255,255,255,.012) 0% 0.25%, transparent 0.25% 0.5%);
  mix-blend-mode:soft-light;
  filter:contrast(120%) brightness(105%);
  z-index:0;
}

/* ---------- Universal panels / containers ---------- */
html:not(.light):not(.retro) .panel,
html:not(.light):not(.retro) .sidebar,
html:not(.light):not(.retro) .dock,
html:not(.light):not(.retro) .inspector{
  background:
    radial-gradient(120% 140% at 70% 0%, rgba(255,255,255,.06), rgba(255,255,255,0) 60%),
    var(--panel);
  border:1px solid var(--hairline);
  border-radius:20px;
  box-shadow: var(--inset-1), var(--sh-1), var(--sh-2);
  color:var(--text);
  position:relative;
  z-index:1;
}

/* Title bars, headers, and search strip */
html:not(.light):not(.retro) .topbar,
html:not(.light):not(.retro) .header{
  background:linear-gradient(180deg, rgba(9,13,19,.7), rgba(9,13,19,.35));
  backdrop-filter: blur(8px);
  border-bottom:1px solid var(--hairline);
  box-shadow: var(--sh-1);
}

/* ---------- Node & card system ---------- */
html:not(.light):not(.retro) .node,
html:not(.light):not(.retro) .textbox,
html:not(.light):not(.retro) .group{
  background:
    radial-gradient(120% 160% at 85% -10%, rgba(255,255,255,.07), rgba(255,255,255,0) 55%),
    var(--panel-2);
  border:1px solid var(--hairline);
  border-radius:18px;
  box-shadow: var(--inset-1), var(--inset-2), var(--sh-1), var(--sh-2);
  transition: transform .2s ease, box-shadow .2s ease, border-color .2s ease;
}
html:not(.light):not(.retro) .node:hover,
html:not(.light):not(.retro) .textbox:hover,
html:not(.light):not(.retro) .group:hover{
  transform: translateY(-1px);
  border-color: var(--hairline-strong);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.07),
    0 2px 0 rgba(0,0,0,.35),
    0 10px 26px rgba(0,0,0,.5),
    0 26px 70px rgba(0,0,0,.55);
}
html:not(.light):not(.retro) .node.selected,
html:not(.light):not(.retro) .textbox.selected,
html:not(.light):not(.retro) .group.selected{
  outline:2px solid var(--focus);
  box-shadow:
    0 0 0 2px color-mix(in srgb, var(--cyan) 45%, transparent),
    0 24px 64px rgba(0,0,0,.6);
}

/* Node titles as frosted pills */
html:not(.light):not(.retro) .node .title{
  background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
  border:1px solid var(--hairline-strong);
  color:var(--text);
  border-radius:12px;
  padding:4px 10px;
}

/* ---------- Inputs & buttons ---------- */
html:not(.light):not(.retro) button,
html:not(.light):not(.retro) .btn,
html:not(.light):not(.retro) select,
html:not(.light):not(.retro) input[type="text"],
html:not(.light):not(.retro) input[type="search"],
html:not(.light):not(.retro) textarea{
  background:var(--input-bg);
  border:1px solid var(--input-bd);
  color:var(--text);
  border-radius:12px;
  box-shadow: var(--inset-1), var(--sh-1);
  transition: background .15s ease,border-color .15s ease, box-shadow .15s ease;
}
html:not(.light):not(.retro) button:hover,
html:not(.light):not(.retro) .btn:hover{ background:var(--input-hover); }
html:not(.light):not(.retro) input[type="text"]:focus,
html:not(.light):not(.retro) input[type="search"]:focus,
html:not(.light):not(.retro) textarea:focus,
html:not(.light):not(.retro) select:focus{
  outline:2px solid var(--focus);
  border-color: color-mix(in srgb, var(--cyan) 35%, var(--input-bd));
  box-shadow: 0 0 0 2px color-mix(in srgb, var(--cyan) 25%, transparent);
}

/* Primary CTA button */
html:not(.light):not(.retro) .btn.primary,
html:not(.light):not(.retro) button.primary{
  background:linear-gradient(180deg, color-mix(in srgb, var(--cyan) 35%, #0b1924), #0b1e27);
  border-color: color-mix(in srgb, var(--cyan) 45%, #0a1a22);
  box-shadow: 0 8px 18px rgba(34,211,238,.25), var(--sh-1);
}
html:not(.light):not(.retro) .btn.primary:hover{ filter:brightness(1.05); }

/* Toggle / switch */
html:not(.light):not(.retro) .switch{ background:var(--panel-3); border:1px solid var(--hairline); }
html:not(.light):not(.retro) .switch .thumb{ background:var(--text); box-shadow: var(--sh-1); }
html:not(.light):not(.retro) .switch.on{ border-color: color-mix(in srgb, var(--cyan) 45%, var(--hairline)); }
html:not(.light):not(.retro) .switch.on .thumb{ background:var(--cyan); }

/* ---------- Menus, popovers, tooltips ---------- */
html:not(.light):not(.retro) .menu,
html:not(.light):not(.retro) .context,
html:not(.light):not(.retro) .popover{
  background:var(--panel-2);
  border:1px solid var(--hairline);
  border-radius:14px;
  box-shadow: var(--sh-1), var(--sh-2);
}
html:not(.light):not(.retro) .menu button:hover{ background:rgba(255,255,255,.06); }
html:not(.light):not(.retro) .tooltip{
  background:#0c1219;
  color:var(--text);
  border:1px solid var(--hairline);
  box-shadow: var(--sh-1);
  border-radius:8px;
}

/* ---------- Drag & Drop states ---------- */
html:not(.light):not(.retro) .drop-overlay{
  background: rgba(34,211,238,.10);
  border:3px dashed color-mix(in srgb, var(--cyan) 70%, transparent);
  border-radius:16px;
}
html:not(.light):not(.retro) .drop-message{
  border-color: color-mix(in srgb, var(--cyan) 45%, rgba(255,255,255,.12));
  color:var(--text-dim);
}

/* ---------- Connectors & handles ---------- */
html:not(.light):not(.retro) .wire{ stroke: rgba(255,255,255,.9); filter: drop-shadow(0 2px 2px rgba(0,0,0,.65)); }
html:not(.light):not(.retro) .handle{
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.28);
  box-shadow: var(--sh-1);
}

/* ---------- Zoom pill ---------- */
html:not(.light):not(.retro) .scale-bar{
  background:rgba(255,255,255,.06) !important;
  border:1px solid rgba(255,255,255,.12) !important;
  border-radius:12px !important;
  box-shadow: var(--sh-1);
}
html:not(.light):not(.retro) #zoomMinus,
html:not(.light):not(.retro) #zoomPlus{
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.14);
  color:#e7ecf6;
  border-radius:10px;
}

/* ---------- Scrollbars (slim, modern) ---------- */
html:not(.light):not(.retro) *::-webkit-scrollbar{ height:10px; width:10px; }
html:not(.light):not(.retro) *::-webkit-scrollbar-track{ background:transparent; }
html:not(.light):not(.retro) *::-webkit-scrollbar-thumb{
  background:linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.10));
  border:2px solid transparent;
  background-clip:padding-box;
  border-radius:999px;
}
html:not(.light):not(.retro) *::-webkit-scrollbar-thumb:hover{
  background:linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,.14));
}

/* ---------- Mini chart & progress styles (for cards) ---------- */
html:not(.light):not(.retro) .stat-bar .bar,
html:not(.light):not(.retro) .chart .bar{
  background: linear-gradient(180deg, var(--cyan), var(--blue));
  border-radius:6px 6px 0 0;
  box-shadow: 0 8px 18px rgba(96,165,250,.25);
}
html:not(.light):not(.retro) .progress.cyan{ background:linear-gradient(180deg, var(--cyan), var(--blue)); }
html:not(.light):not(.retro) .progress.purple{ background:linear-gradient(180deg, var(--purple), #6d28d9); }
html:not(.light):not(.retro) .progress.yellow{ background:linear-gradient(180deg, var(--yellow), #c2410c); }

/* ---------- Badges, pills ---------- */
html:not(.light):not(.retro) .badge{
  background:rgba(255,255,255,.06);
  border:1px solid var(--hairline);
  color:var(--text-dim);
  border-radius:999px;
  padding:4px 10px;
}
html:not(.light):not(.retro) .badge.accent{ color:#001217; background:var(--cyan); border-color:transparent; }

/* ---------- Tables ---------- */
html:not(.light):not(.retro) table{
  background:var(--panel);
  color:var(--text);
  border-collapse:separate;
  border-spacing:0;
  border:1px solid var(--hairline);
  border-radius:14px;
  overflow:hidden;
  box-shadow: var(--sh-1);
}
html:not(.light):not(.retro) th, 
html:not(.light):not(.retro) td{ border-bottom:1px solid rgba(255,255,255,.06); }
html:not(.light):not(.retro) tr:hover td{ background:rgba(255,255,255,.04); }

/* ---------- Code, selection ---------- */
html:not(.light):not(.retro) ::selection{
  background:color-mix(in srgb, var(--cyan) 35%, #0b121a);
  color:var(--text);
}

/* ---------- Utility accent rings (like sample cards) ---------- */
.ring-purple{ color:var(--purple); }
.ring-yellow{ color:var(--yellow); }
.ring-blue{ color:var(--blue); }
</style>


<style id="checklist-select-fix">


  /* Make checklist selection visible in both themes */
  .checknode.selected{
    outline: 2px solid var(--accent);
    outline-offset: 2px;
    border-color: var(--node-border);
  }

/* Saved boards — thumbnail cards (PNG preview + actions) */
#saveList{ display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:10px; }
.save-card{
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.08);
  border-radius:12px; padding:10px; display:grid; gap:8px;
}
.save-card img{ width:100%; height:96px; object-fit:cover; border-radius:8px; background:#000; }
.save-card .meta{ font-size:12px; opacity:.9; line-height:1.2; display:grid; gap:2px; }
.save-card .row{ display:flex; gap:6px; }
.save-card button{ flex:1; padding:6px 8px; font-size:12px; border-radius:8px; cursor:pointer; }
</style>
<style id="no-sheen-patch">
/* Disable sheen & micro shimmer on textboxes to prevent stutter */
.textbox::before,
.textbox::after{
  background: none !important;
  animation: none !important;
  mix-blend-mode: normal !important;
  filter: none !important;
  will-change: auto !important;
  opacity: 1 !important;
}
</style>

<style id="tb-ctx-css">
/* Textbox color context menu */
#tbCtxMenu{
  position: fixed; z-index: 99999; width: 220px;
  background: rgba(22,26,43,.98);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 12px; padding: 10px;
  box-shadow: 0 12px 32px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06);
  display: none;
  backdrop-filter: blur(8px);
}
#tbCtxMenu .title{ font-size:12px; color:#cfd7ff; opacity:.9; margin-bottom:8px; }
#tbCtxMenu .row{ display:flex; gap:8px; align-items:center; margin:6px 0; }
#tbCtxMenu input[type="color"]{ width: 100%; height: 36px; padding:0; border:0; background:transparent; cursor:pointer; }
#tbCtxMenu .seg{
  display:grid; grid-auto-flow:column; gap:6px;
}
#tbCtxMenu .seg button{
  flex:1; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06); color:#e8ecff; cursor:pointer; font-size:12px;
}
#tbCtxMenu .seg button.active{ outline:2px solid rgba(139,92,246,.65); }
#tbCtxMenu .swatch{
  display:grid; grid-template-columns: repeat(6, 1fr); gap:6px;
}
#tbCtxMenu .swatch button{
  width: 24px; height: 24px; border-radius:6px; border:1px solid rgba(255,255,255,.18); cursor:pointer;
}

/* === Retro-only fixes for tbCtxMenu overflow/seams === */
.retro #tbCtxMenu,
[data-theme="retro"] #tbCtxMenu,
body.retro #tbCtxMenu{
  box-sizing: border-box;
  width: 220px;
  max-width: 220px;
  overflow: hidden;
}

.retro #tbCtxMenu .row,
.retro #tbCtxMenu .seg,
.retro #tbCtxMenu .swatch { min-width: 0; }

.retro #tbCtxMenu .seg{
  grid-auto-flow: column;
  grid-auto-columns: 1fr;
}

.retro #tbCtxMenu .swatch{
  grid-template-columns: repeat(6, minmax(0, 1fr));
}

.retro #tbCtxMenu input[type="color"]{
  display: block;
  width: 100%;
  box-sizing: border-box;
}

/* Optional: hide any remaining subpixel seam cleanly */
.retro #tbCtxMenu{
  outline: 1px solid rgba(0,0,0,.12);
  outline-offset: -1px;
}

/* Retro-only: force swatches to be perfect squares */
.retro #tbCtxMenu .swatch{ grid-template-columns: repeat(6, minmax(0, 1fr)); }
.retro #tbCtxMenu .swatch button{
  width: 100%;
  height: auto;            /* let aspect-ratio control height */
  aspect-ratio: 1 / 1;     /* perfect square */
  box-sizing: border-box;  /* include border in box, avoids 1px distortion */
}
</style>

<style id="mobile-enhance-css">
/* Mobile-friendly panels */
@media (max-width: 900px){
  .url-panel, .save-panel{
    width: min(88vw, 520px) !important;
    max-height: calc(100vh - 140px) !important;
    font-size: 14px;
  }
  .save-panel h3, .url-panel h3{ font-size: 16px; }
  .save-panel button, .url-panel button{ font-size: 13px; }
}
@media (max-width: 600px){
  .url-panel, .save-panel{
    width: min(94vw, 460px) !important;
    max-height: calc(100vh - 120px) !important;
    font-size: 13px;
  }
  .save-panel h3, .url-panel h3{ font-size: 15px; }
  .save-panel button, .url-panel button{ font-size: 12px; padding: 8px 10px; }
}
/* Ensure the board captures touch gestures for dragging without scroll jitter */
#viewport{
  touch-action: none;
}
</style>

<style id="zoom-btn-css">
#zoomControls{
  display:flex; align-items:center; gap:8px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  padding:6px 10px; border-radius:12px;
  position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
  z-index:2000;
}
.zoom-btn{
  width:32px; height:32px; font-size:18px; font-weight:bold;
  border-radius:8px; border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.08);
  color:#e8ecff; cursor:pointer;
}
.zoom-btn:hover{ background: rgba(255,255,255,.15); }
#zoomPct{ min-width:50px; text-align:center; font-weight:600; color:#fff; }
</style>

<style id="zoom-steps-css">
/* Zoom controls replacing the old % panel */
.scale-bar{ gap:10px; }
#zoomControls{
  display:flex; align-items:center; gap:8px;
  background: rgba(0,0,0,.25);
  border:1px solid rgba(255,255,255,.1);
  padding:4px 6px; border-radius:10px;
  backdrop-filter: blur(6px);
}
#zoomMinus, #zoomPlus{
  width:32px; height:32px; border-radius:8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  font-size:18px; color:#e8ecff; cursor:pointer;
  display:grid; place-items:center;
}
#zoomMinus:active, #zoomPlus:active{ transform: translateY(1px); }
#zoomLabel{ min-width:60px; text-align:center; font-variant-numeric: tabular-nums; }
</style>
<style id="zoom-bottom-left-css">
/* Ensure zoom controls stay bottom-left on all viewports */
.scale-bar{
  position: fixed !important;
  left: 12px !important;
  bottom: 12px !important;
  z-index: 1500 !important;
}
</style>
<style id="zoom-safearea-css">
/* Keep zoom controls within visible window & safe areas */
:root{
  /* fallback values if env() not supported */
  --safe-left: env(safe-area-inset-left, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
}
.scale-bar{
  position: fixed !important;
  left: calc(var(--safe-left) + 12px) !important;
  bottom: calc(var(--safe-bottom) + 12px) !important;
  max-width: calc(100vw - 24px) !important;
  z-index: 2000 !important;
}
</style>
<style id="center-zoom-and-panel-toggle-css">
/* Bottom-center zoom controls, respecting safe areas */
:root{
  --safe-left: env(safe-area-inset-left, 0px);
  --safe-right: env(safe-area-inset-right, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --zoom-bottom-offset: 20px; /* Will be adjusted by JS */
}
.scale-bar{
  position: fixed !important;
  left: 50% !important;
  transform: translateX(-50%);
  bottom: var(--zoom-bottom-offset) !important;
  z-index: 2000 !important;
  max-width: calc(100vw - (var(--safe-left) + var(--safe-right)) - 24px);
}

/* Minimalistic panel toggles */
.url-panel, .save-panel{
  position: relative;
}
.panel-toggle{
  position: absolute;
  top: 8px; right: 8px;
  width: 28px; height: 28px;
  border-radius: 8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  color: #e8ecff; cursor: pointer;
  display: grid; place-items: center;
  font-size: 16px; line-height: 1;
}
.panel-toggle:active{ transform: translateY(1px); }

/* When collapsed: hide inner content except the header */
.panel-collapsible .panel-body{ display: block; }
.panel-collapsible.collapsed .panel-body{ display: none; }

/* Make headers clickable targets too (optional) */
.panel-collapsible > h3{
  padding-right: 40px;  /* leave space for toggle button */
  position: relative;
}
</style>

<style id="alignment-and-zoom-pin-css">
/* Pin zoom to bottom-center, safe-area aware (static offset), override any previous rules */
.scale-bar{
  position: fixed !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  bottom: calc(env(safe-area-inset-bottom, 0px) + 36px) !important;
  z-index: 2200 !important;
}

/* Panel alignment + clamping */
.url-panel, .save-panel{
  position: fixed;  /* make positions deterministic */
  left: 12px;
}
.url-panel{ top: 72px; }           /* header height buffer */
.save-panel{ top: auto; }          /* JS will place it under URL panel */
@media (max-width: 900px){
  .url-panel, .save-panel{ left: 12px; right: auto; }
}
</style>


<style id="save-panel-responsive-css">
/* Make Save & Load internals adapt to panel width */
.save-panel .save-buttons{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.save-panel .save-buttons button{
  flex: 1 1 auto;
  min-width: 120px;
}

/* Responsive list: single column on narrow panels, multi when wider */
.save-panel #saveList{
  display: grid;
  grid-template-columns: 1fr;
  gap: 10px;
  overflow-x: hidden;
}
@media (min-width: 720px){
  .save-panel #saveList{
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  }
}

/* Cards fill width and wrap neatly */
.save-panel .save-card{
  width: 100%;
  box-sizing: border-box;
}
.save-panel .save-card .meta{
  word-break: break-word;
  overflow-wrap: anywhere;
}

/* Thumbnails scale with width, maintain aspect ratio */
.save-panel .save-card img{
  display: block;
  width: 100%;
  height: auto !important;
  aspect-ratio: 16 / 9;
  object-fit: cover;
  border-radius: 8px;
  background: #000;
}

/* Action row wraps when tight */
.save-panel .save-card .row{
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.save-panel .save-card .row button{
  flex: 1 1 90px;
  min-width: 86px;
}
</style>

<style id="pointer-gestures-css">
#viewport, #board { touch-action: none; }
</style>
<style id="panel-collapse-to-button-css">
/* Collapse panels to small floating buttons */
.url-panel, .save-panel{ position: fixed; }
.url-panel.panel-collapsed, .save-panel.panel-collapsed{
  width: 44px !important;
  height: 44px !important;
  padding: 0 !important;
  overflow: hidden !important;
  display: grid !important;
  place-items: center !important;
  border-radius: 12px !important;
}
/* Hide body and header when collapsed */
.url-panel.panel-collapsed .panel-body,
.save-panel.panel-collapsed .panel-body,
.url-panel.panel-collapsed h3,
.save-panel.panel-collapsed h3{ display: none !important; }

/* Toggle button */
.panel-toggle{
  position: absolute; top: 8px; right: 8px;
  width: 28px; height: 28px; border-radius: 8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  color: #e8ecff; cursor: pointer; display: grid; place-items: center;
  font-size: 16px; line-height: 1;
}
.panel-toggle:active{ transform: translateY(1px); }

/* When collapsed, the toggle becomes the button face */
.url-panel.panel-collapsed .panel-toggle,
.save-panel.panel-collapsed .panel-toggle{
  position: static; width: 36px; height: 36px; margin: 0;
}

/* Positions (left for URL, right for Save) */
.url-panel{ top: 80px; left: 16px; }
.save-panel{ top: 80px; right: 16px; }
</style>

<style id="node-title-hit-css">
/* Larger, easier-to-tap node title */
.node .title{
  z-index: 1100;
  padding: 6px 10px !important;
  font-size: 14px !important;
  min-height: 28px;
  line-height: 1.2;
  touch-action: manipulation !important;   /* allow taps to trigger focus */
  -webkit-user-select: text !important;
  user-select: text !important;
}
/* Extra hit-slap area (invisible) for small titles */
.node .title::after{
  content:"";
  position:absolute;
  left:-6px; right:-6px; top:-6px; bottom:-6px;
  border-radius: 14px;
  pointer-events: none; /* purely enlarges the easy tap visual area; not blocking */
}
/* When editing, ensure text cursor and visual affordance */
.node .title.editing{
  cursor: text !important;
}
</style>


<style id="collapsed-panels-css">
/* Collapsed look: keep existing colors/background/borders from panel, just compress */
.url-panel.panel-collapsed,
.save-panel.panel-collapsed{
  width: 56px !important;
  height: 56px !important;
  min-width: 56px !important;
  min-height: 56px !important;
  padding: 0 !important;
  display: grid !important;
  place-items: center !important;
  border-radius: 12px;
  overflow: hidden !important;
}
/* Hide content except the toggle button (used as the face) */
.url-panel.panel-collapsed .panel-body,
.url-panel.panel-collapsed h3,
.save-panel.panel-collapsed .panel-body,
.save-panel.panel-collapsed h3{
  display: none !important;
}

/* The toggle becomes the face with centered label text */
.panel-toggle{
  position: absolute;
  top: 8px; right: 8px;
  width: 28px; height: 28px;
  border-radius: 8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  color: inherit;
  cursor: pointer;
  display: grid;
  place-items: center;
  font-weight: 600;
}
/* In collapsed mode, the button fills and shows the label ("URL"/"Save") */
.url-panel.panel-collapsed .panel-toggle,
.save-panel.panel-collapsed .panel-toggle{
  position: static;
  width: 100%; height: 100%;
  margin: 0;
  background: transparent;
  border: none;
  color: inherit;
  font-size: 14px;
  letter-spacing: .2px;
}
</style>


<style id="node-lock-css">
.node.locked{ cursor: default !important; outline: 1px dashed var(--accent, #6ea8fe); outline-offset: 2px; }
</style>

<style id="tbcl-lock-css">
.textbox.locked, .checklist.locked{ cursor: default !important; outline: 1px dashed var(--accent, #6ea8fe); outline-offset: 2px; }
</style>

<style id="group-lock-css">
.group.locked{ cursor: default !important; outline: 1px dashed var(--accent, #6ea8fe); outline-offset: 2px; }
</style>


<style id="retro-theme-complete">
/* ===================== RETRO THEME — Full Overhaul ===================== */
/* Activate with: <html class="retro"> via the theme selector */
:root.retro {
  --retro-bg: #FFF7F0;
  --retro-paper: #FFFFFF;
  --retro-ink: #1B1B1B;
  --retro-muted: #727272;
  --retro-teal: #61C0BF;
  --retro-lilac: #E0C3F6;
  --retro-peach: #FCC5B3;
  --retro-outline: #1B1B1B;
  --retro-outline-weak: rgba(0,0,0,.15);
  --retro-radius-xl: 24px;
  --retro-radius-lg: 18px;
  --retro-radius-md: 14px;
  --retro-pill: 999px;
  --retro-shadow-card: 0 0 0 1.5px var(--retro-outline);
  --retro-offset-peach: 8px 10px 0 var(--retro-peach);
  --retro-offset-teal: -2px -2px 0 var(--retro-teal);
  --retro-wire: rgba(20,20,20,.9);
}

:root.retro body {
  color: var(--retro-ink);
  background: var(--retro-bg);
  background-image:
    radial-gradient(rgba(0,0,0,.06) 1px, transparent 1.6px),
    repeating-linear-gradient(135deg, rgba(0,0,0,.02) 0 2px, transparent 2px 4px),
    linear-gradient(180deg, #FFF9F3, #FFEFE3);
  background-size:
    22px 22px,
    2048px 2048px,
    cover;
  background-attachment: fixed;
}
/* kill any dark canvas backgrounds */
:root.retro body { background-blend-mode: normal; }
:root.retro body, :root.retro body * { text-shadow: none; }

/* --------- Generic Controls --------- */
:root.retro button, 
:root.retro .btn, 
:root.retro .zoom-btn, 
:root.retro .seg button {
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-pill);
  background: var(--retro-paper);
  color: var(--retro-ink);
  box-shadow: var(--retro-shadow-card);
  padding: .65rem 1rem;
  font-weight: 700;
}
:root.retro .btn.is-teal { background: var(--retro-teal); }
:root.retro .btn.is-lilac{ background: var(--retro-lilac); }
:root.retro .btn.is-peach{ background: var(--retro-peach); }

/* --------- Panels / Topbar / Dock --------- */
:root.retro .panel,
:root.retro #sidePanel,
:root.retro .topbar,
:root.retro #dock,
:root.retro .url-panel {
  background: var(--retro-paper);
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-xl);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(var(--retro-offset-peach)) drop-shadow(var(--retro-offset-teal));
}
:root.retro .section-title,
:root.retro .title { font-weight: 800; color: var(--retro-ink); }
:root.retro .subtitle, :root.retro .muted { color: var(--retro-muted); }

/* --------- Floating Toolbar --------- */
:root.retro .ftb {
  background: var(--retro-teal);
  border: 1.5px solid var(--retro-outline);
  border-radius: 32px;
  padding: 8px;
  box-shadow: var(--retro-shadow-card);
}
:root.retro .ftb-row { gap: 8px; }
:root.retro .ftb-btn {
  background:#fff;
  border: 1.5px solid var(--retro-outline);
  border-radius: 14px;
  box-shadow: var(--retro-shadow-card);
  width: 40px; height: 40px;
}
:root.retro .ftb-btn.active { outline: 2px solid var(--retro-lilac); }

/* --------- Spotlight (search) --------- */
:root.retro .spotlight-card {
  background: var(--retro-paper);
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-xl);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(6px 8px 0 var(--retro-teal));
}
:root.retro .spotlight-input {
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-pill);
  padding: .85rem 1.1rem;
  background: #fff; color: #111827;
}
:root.retro .spotlight-btn {
  border:1.5px solid var(--retro-outline);
  border-radius: 14px;
  background:#fff;
}

/* --------- Nodes / Groups / Textboxes --------- */
:root.retro .node{
  background: var(--retro-paper);
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-xl);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(var(--retro-offset-teal));
}
:root.retro .textbox {
  background: var(--retro-paper);
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-xl);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(var(--retro-offset-peach)); 
}

:root.retro .group {
  background: var(--retro-teal);
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-xl);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(var(--retro-offset-peach)) drop-shadow(var(--retro-offset-teal));
}
:root.retro .node.image img,
:root.retro .node.video video,
:root.retro .node.website iframe { border-radius: calc(var(--retro-radius-xl) - 6px); }

:root.retro .node .title,
:root.retro .textbox .title,
:root.retro .group .title { font-weight: 800; color: var(--retro-ink); }

/* Textbox content look */
:root.retro .textbox {
  padding: .8rem 1rem;
  font-size: 15px;
  line-height: 1.45;
}

/* Group header accent underline */
:root.retro .group .title 
:root.retro .node .title,
:root.retro .textbox .title
{ border-bottom: 2px solid var(--retro-teal); padding-bottom:.25rem; }

/* --------- Checklist --------- */
:root.retro .checknode,
:root.retro .checklist {
  background: #fff;
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-lg);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(4px 5px 0 var(--retro-lilac));
  padding: 10px 12px;
}
:root.retro .checknode input[type="checkbox"]{
  width:18px;height:18px;border:1.5px solid var(--retro-outline);
  border-radius:4px; appearance:none; background:#fff; vertical-align:middle;
}
:root.retro .checknode input[type="checkbox"]:checked{
  background: var(--retro-teal);
}

/* --------- URL panel buttons / chips --------- */
:root.retro .url-buttons button,
:root.retro .url-types .btn,
:root.retro .chip {
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-pill);
  background: #fff;
  box-shadow: var(--retro-shadow-card);
  padding: .5rem .9rem;
  font-weight: 700;
}
:root.retro .url-types .btn.active { background: var(--retro-lilac); }

/* --------- Wires --------- */
:root.retro #wires .wire-path { stroke: var(--retro-wire) !important; }
:root.retro #wires .wire-hit-area { stroke: transparent; }

/* --------- Resizers / Handles --------- */
:root.retro .resize-handle,
:root.retro .node .handle,
:root.retro .textbox .handle {
  background: rgba(0,0,0,.06);
  border: 1.5px solid var(--retro-outline);
  border-radius: 6px;
}

/* --------- Scrollbars (optional) --------- */
:root.retro ::-webkit-scrollbar       { height: 10px; width: 10px; }
:root.retro ::-webkit-scrollbar-track { background: #fff; border-radius: 10px; }
:root.retro ::-webkit-scrollbar-thumb { background: #e4e4e4; border:1px solid var(--retro-outline-weak); border-radius: 10px; }
</style>


<style id="retro-save-panel-patch">
/* === Retro theme patch: Save/Load panel & saved boards === */
:root.retro #savePanel,
:root.retro .save-panel{
  background: var(--retro-paper);
  color: var(--retro-ink);
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-xl);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(var(--retro-offset-peach)) drop-shadow(var(--retro-offset-teal));
}
:root.retro #savePanel h3,
:root.retro .save-panel h3{
  margin: 0 0 12px;
  font-weight: 800;
  letter-spacing: .2px;
  color: var(--retro-ink);
}
:root.retro #savePanel .save-buttons button,
:root.retro .save-panel .save-buttons button{
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-pill);
  background: #fff;
  color: var(--retro-ink);
  box-shadow: var(--retro-shadow-card);
  font-weight: 700;
  padding: .55rem .9rem;
}
:root.retro #savePanel .save-list,
:root.retro .save-panel .save-list{
  background: transparent;
  border-radius: var(--retro-radius-lg);
  padding-right: 2px;
}
:root.retro #saveList .save-card,
:root.retro .save-panel .save-card{
  background: #fff;
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-radius-lg);
  box-shadow: var(--retro-shadow-card);
  filter: drop-shadow(4px 5px 0 var(--retro-lilac));
  padding: 12px;
}
:root.retro #saveList .save-card img,
:root.retro .save-panel .save-card img{
  border: 1.5px solid var(--retro-outline);
  border-radius: 10px;
  background: #fff;
}
:root.retro #saveList .save-card .meta,
:root.retro .save-panel .save-card .meta{ color: var(--retro-ink); }
:root.retro #saveList .save-card .row button,
:root.retro .save-panel .save-card .row button{
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-pill);
  background: #fff;
  color: var(--retro-ink);
  font-weight: 700;
  padding: .45rem .7rem;
}
:root.retro #savePanel.panel-collapsed,
:root.retro .save-panel.panel-collapsed{
  border: 1.5px solid var(--retro-outline) !important;
  filter: drop-shadow(4px 5px 0 var(--retro-teal));
}
:root.retro #savePanel.panel-collapsed .panel-toggle,
:root.retro .save-panel.panel-collapsed .panel-toggle{
  border: 1.5px solid var(--retro-outline);
  border-radius: var(--retro-pill);
  background: #fff;
  color: var(--retro-ink);
  font-weight: 800;
}
:root.retro #savePanel ::-webkit-scrollbar,
:root.retro .save-panel ::-webkit-scrollbar       { height: 10px; width: 10px; }
:root.retro #savePanel ::-webkit-scrollbar-track,
:root.retro .save-panel ::-webkit-scrollbar-track { background: #fff; border-radius: 10px; }
:root.retro #savePanel ::-webkit-scrollbar-thumb,
:root.retro .save-panel ::-webkit-scrollbar-thumb { background: #e4e4e4; border:1px solid var(--retro-outline-weak); border-radius: 10px; }

/* --- Timeline node styles --- */
.timeline { position:absolute; user-select:none; }
.timeline.selected { outline: 2px solid var(--accent,#3b82f6); outline-offset: 2px; }
.timeline .timeline-line { position:absolute; left:0; top:0; right:0; bottom:0; background: currentColor; }
.timeline.horizontal { height: 6px; }
.timeline.vertical   { width: 6px; }
.timeline .tl-handle {
  position:absolute; width:12px; height:12px; border-radius:6px;
  background: var(--handle-bg, #fff); border:1px solid var(--handle-border, rgba(0,0,0,.25));
  box-shadow: 0 1px 2px rgba(0,0,0,.15);
  cursor: ew-resize;
}
.timeline.vertical .tl-handle { cursor: ns-resize; }
.timeline .tl-handle.left  { left:-6px; top:50%; transform: translate(-50%,-50%); }
.timeline .tl-handle.right { right:-6px; top:50%; transform: translate(50%,-50%); }
.timeline.vertical .tl-handle.top    { top:-6px; left:50%; transform: translate(-50%,-50%); }
.timeline.vertical .tl-handle.bottom { bottom:-6px; left:50%; transform: translate(-50%,50%); }
.timeline .tl-mark {
  position:absolute; width:24px; height:24px; border-radius:50%;
  background: var(--tl-mark-fill, #fff); border:2px solid var(--tl-mark-stroke, currentColor);
  box-shadow: 0 1px 2px rgba(0,0,0,.2);
  cursor: grab;
}
.timeline .tl-mark .resizer { display:none;
  position:absolute; width:10px; height:10px; right:-5px; bottom:-5px;
  border-radius:50%; background:#fff; border:1px solid rgba(0,0,0,.3); cursor: nwse-resize;
}

/* Timeline menu tabbed panel - robust visibility */
#timelineMenu { min-width: 280px; }
#timelineMenu .panel { display: none !important; padding: 8px 10px; gap: 8px; }
#timelineMenu .panel.active { display: flex !important; flex-direction: column; }
#timelineMenu .tabs { display:flex; gap:6px; padding:6px; background:var(--panel); border-bottom:1px solid var(--accent); }
#timelineMenu .tabs .tab { padding:6px 10px; border-radius:6px; background:var(--panel); border:1px solid var(--panel-border); cursor:pointer; user-select:none; }
#timelineMenu .tabs .tab.active { background:var(--panel); border:2px solid var(--accent); }
#timelineMenu .row { display:flex; align-items:center; gap:8px;}
#timelineMenu .row label { min-width:110px; font-size:12px; color:var(--text); }
#timelineMenu input[type="color"], #timelineMenu input[type="number"], #timelineMenu select { padding:2px 4px; background: var(--accent); border:1px solid var(--panel-border);}


/* Timeline mark SVG shape helper */
.timeline .tl-mark svg.shape { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }



.timeline .tl-mark { position:absolute; }
.timeline .tl-mark .resizer { display:none; position:absolute; z-index:2; }
.timeline .tl-mark svg.shape { z-index:1; }



/* --- Enlarged hit areas for timeline & timestamps --- */
.timeline .tl-mark .resizer-hit { position:absolute; left:-10px; right:-10px; top:-10px; bottom:-10px; pointer-events:auto; background:transparent; }
.timeline .tl-mark { position:absolute; }
.timeline .tl-mark .hit { position:absolute; left:-8px; right:-8px; top:-8px; bottom:-8px; pointer-events:auto; background:transparent; }



/* Priority stacking for hit targets */
.timeline .tl-hit { z-index: 1; }
.timeline .tl-mark { z-index: 3; }
.timeline .tl-mark .hit { z-index: 4; }



/* Priority stacking and hit behavior */
.timeline { position:absolute; }
.timeline .tl-hit { z-index: 1; pointer-events: auto; }
.timeline .tl-mark { z-index: 3; position:absolute; }
.timeline .tl-mark .hit { z-index: 4; pointer-events: auto; }

</style>

</head>

<body>
  <button id="shareButton" style="position: fixed; top: 10px; right: 10px; padding: 10px; background-color: #4CAF50; color: white; border: none; border-radius: 5px;">Share Mood Board</button>

  <!-- Modal for Share Link -->
  <div class="modal-overlay" id="modalOverlay" style="display: none;"></div>
  <div id="shareModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 600px; background: rgba(0, 0, 0, 0.8); color: white; padding: 20px; border-radius: 8px; z-index: 1000;">
    <h2>Share Your Mood Board</h2>
    <input type="text" id="shareLink" readonly placeholder="Generated link will appear here..." style="width: 100%; padding: 10px; background-color: #333; color: white; border: none; border-radius: 5px; text-align: center;">
    <button id="copyLinkButton" style="padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px;">Copy Link</button>
  </div>

  <script>
    // Example of mood board state (this would be dynamically captured)
    const boardState = {
      nodes: [{ id: 1, x: 100, y: 100, width: 200, height: 200, content: 'Node 1' }],
      zoom: 1.0,
      pan: { x: 0, y: 0 }
    };

    // Function to serialize the state and generate the URL
    function serializeState(state) {
      return btoa(JSON.stringify(state)); // Base64 encode the serialized state
    }

    // Function to show the share modal
    function showShareModal() {
      const serializedState = serializeState(boardState);
      const link = window.location.href.split('?')[0] + '?state=' + serializedState;
      document.getElementById('shareLink').value = link;
      document.getElementById('modalOverlay').style.display = 'block';
      document.getElementById('shareModal').style.display = 'block';
    }

    // Function to copy the link to the clipboard
    function copyLink() {
      const shareLink = document.getElementById('shareLink');
      shareLink.select();
      document.execCommand('copy');
      alert('Link copied to clipboard!');
    }

    // Event listener for the share button
    document.getElementById('shareButton').addEventListener('click', showShareModal);

    // Event listener for the copy link button
    document.getElementById('copyLinkButton').addEventListener('click', copyLink);

    // Close modal when overlay is clicked
    document.getElementById('modalOverlay').addEventListener('click', () => {
      document.getElementById('modalOverlay').style.display = 'none';
      document.getElementById('shareModal').style.display = 'none';
    });
  </script>

  <header class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <div class="title">Blank Space</div>
        <div class="subtitle">Infinite node-based workflow board powered by GPT5</div>
      </div>
    </div>
    <div class="actions">
      <button id="btnUploadImage">Upload Image</button>
      <button id="btnUploadVideo">Upload Video</button>
      <button id="btnUploadPDF">Upload Document</button>
      <select id="theme">
        <option value="dark" selected>Dark</option>
        <option value="light">Light</option>
        <option value="retro">Retro</option>
</select>
    </div>
  </header>

  <!-- URL Import Panel -->
  <div class="url-panel">
    <h3>Import from URL</h3>
    <div class="url-types">
      Supports: YouTube (videos & Shorts), Instagram (posts & Reels), X/Twitter (posts), images (JPG, PNG, GIF, WEBP), video files (MP4, WEBM, OGG, HLS), and websites
    </div>
    <input type="text" id="urlInput" placeholder="Paste URL here..." />
    <div class="url-buttons">
      <button id="btnImportUrl">Import</button>
      <button id="btnClearUrl">Clear</button>
    </div>
  </div>

  <!-- Save/Load Panel -->
  <div class="save-panel">
    <h3>Save & Load</h3>
    <div class="save-buttons">
      <button id="btnSave">Save Board</button>
      <button id="btnExport">Export JSON</button>
      <button id="btnImport">Import JSON</button>
    </div>
    <div class="save-list" id="saveList"></div>
  </div>

  <div id="root">
    <div id="viewport">
      <div id="board" class="board grid" tabindex="0"></div>
    </div>
    <div class="scale-bar" id="zoomControls">
  <button type="button" class="zoom-btn" data-zoom-dir="-">−</button>
  <span id="zoomPct">100%</span>
  <button type="button" class="zoom-btn" data-zoom-dir="+">+</button>
</div></div>
    </div>
  </div>

  <!-- Hidden inputs for uploads -->
  <input id="fileImage" type="file" accept="image/*" multiple style="display:none"/>
  <input id="fileVideo" type="file" accept="video/*" multiple style="display:none"/>
  <input id="filePDF" type="file" accept="application/pdf" multiple style="display:none"/>
  <input id="fileImport" type="file" accept=".json" style="display:none"/>

  <!-- Google Maps Modal -->
  <div id="mapModal" class="modal-overlay" style="display:none;">
    <div class="map-modal">
      <h3>Add Google Map Route</h3>
      <div class="input-group">
        <label for="mapStart">Start Point:</label>
        <input type="text" id="mapStart" placeholder="Enter starting location..." />
      </div>
      <div class="input-group">
        <label for="mapDestination">Destination:</label>
        <input type="text" id="mapDestination" placeholder="Enter destination..." />
      </div>
      <div class="modal-buttons">
        <button id="mapCancel">Cancel</button>
        <button id="mapCreate" style="background: var(--accent);">Create Map</button>
      </div>
    </div>
  </div>

  <!-- Drop overlay for drag and drop -->
  <div id="dropOverlay" class="drop-overlay">
    <div class="drop-message">
      <h3>Drop files or URLs to add to board</h3>
      <p>Images, videos, and PDFs supported</p>
    </div>
  </div>

  <!-- Context menus -->
  <menu id="canvasMenu" class="menu">
    <button data-action="upload-image">Upload Image…</button>
    <button data-action="upload-video">Upload Video…</button>
    <button data-action="upload-pdf">Upload Document…</button>
    <hr/>
    <button data-action="add-google-map">Add Google Map</button>
    <button data-action="add-whiteboard">Add White Board</button>
    <button data-action="add-Vegas-Charts">Add Vegas Charts</button>
    <button data-action="add-calendar">Add Calendar</button>
    <button data-action="add-lightbox">Add Lightbox</button>
    <button data-action="add-shotlist-builder">Add Shotlist Builder</button>
    <hr/>
    <button data-action="create-group">Create Group</button>
    <button data-action="create-textbox">Create Text Box</button>
    <button data-action="add-checknode">Create Checklist</button>
    <hr/>
    <button data-action="create-timeline-h">Create Timeline — Horizontal</button>
    <button data-action="create-timeline-v">Create Timeline — Vertical</button>
  </menu>

  <menu id="nodeMenu" class="menu">
    <button data-action="open">Open / Play</button>
    <hr/>

    <button data-action="toggle-metadata">Show metadata</button>
    <!-- INSERT THESE TWO LINES -->
    <button data-action="connect">Connect</button>
    <hr/>
    <!-- /INSERT -->
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="toggle-lock">Lock</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>

  
  <menu id="groupMenu" class="menu">
    <button data-action="rename">Rename…</button>
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="toggle-lock">Lock</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>
  <menu id="timelineMenu" class="menu">
    <div class="tabs">
      <div class="tab active" data-tab="actions">Actions</div>
      <div class="tab" data-tab="style">Timeline Style</div>
    </div>

    <div class="panel active" data-panel="actions">
      <button data-action="add-timestamp">Add Timestamp</button>
      <hr/>
      <button data-action="duplicate">Duplicate</button>
      <button data-action="delete" class="danger">Delete</button>
    </div>

    <div class="panel" data-panel="style">
      <div class="row">
        <label>Stroke Color</label>
        <input id="tl-stroke-color" type="color" value="#111111">
      </div>
      <div class="row">
        <label>Stroke Width (px)</label>
        <input id="tl-stroke-width" type="number" min="1" max="64" step="1" value="6">
      </div>
      <div class="row">
        <label>Stroke Pattern</label>
        <select id="tl-stroke-pattern">
          <option value="solid">Solid</option>
          <option value="dashed">Dashed</option>
        </select>
      </div>
      <div class="row">
        <label>Fill Color</label>
        <input id="tl-fill-color" type="color" value="#ffffff">
      </div>
      <div class="row">
        <label>Timestamp Color</label>
        <input id="tl-mark-fill-color" type="color" value="#ffffff">
      </div>
      <div class="row"><label>Transparency Level</label><input id="tl-fill-alpha" type="range" min="0" max="100" step="1" value="100"><span id="tl-fill-alpha-val" style="min-width:40px;text-align:right;">100%</span></div>
      <div class="row">
        <label>Timestamp Shape</label>
        <select id="tl-mark-shape">
          <option value="circle">Circle</option>
          <option value="square">Square</option><option value="bar">Bar</option>
        </select>
      </div>

      <div class="row">
        <label>Timestamp Radius (px)</label>
        <input id="tl-mark-radius" type="number" min="6" max="120" step="1" value="12">
      </div>

    </div>
  </menu>
  <menu id="timestampMenu" class="menu">
    <button data-action="create-timezone">Time Zone</button>
  
  <hr/>
  <button data-action="delete" class="danger">Delete Timestamp</button>
</menu>


<menu id="textboxMenu" class="menu">
    <button data-action="connect">Connect</button>
    <hr/>
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="color">Textbox color…</button>
    <hr/>
    <button data-action="toggle-lock">Lock</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>

  <menu id="wireMenu" class="menu">
    <button data-action="disconnect" class="danger">Disconnect</button>
  </menu>

  <script>
    console.log('Script starting...');
    
    // v4.8 — Fixed textbox loading with proper state management
    const state = { wires: [], 
      zoom: 1,
      origin: {x: 0, y: 0},
      nodes: [],
      groups: [],
      textboxes: [],
      selection: new Set(),
      nextId: 1,
      isPanning: false,
      panStart: {x:0,y:0},
      originStart: {x:0,y:0}
    };

    board.addEventListener('click', (e)=>{ if(e.button===0 && typeof closeMenus==='function') closeMenus(); });
    const viewport = document.getElementById('viewport');
    const canvasMenu = document.getElementById('canvasMenu');
    const nodeMenu = document.getElementById('nodeMenu');
    const textboxMenu = document.getElementById('textboxMenu');
    const wireMenu = document.getElementById('wireMenu');

    console.log('Elements found:', {board, viewport, canvasMenu, nodeMenu, textboxMenu, wireMenu});

    function init(){
      console.log('Initializing...');
      resizeBoard();
      bindGlobal();
      bindUrlPanel();
      bindSavePanel();
      bindMapModal();
      setupDragAndDrop();
      createGroup({x:200, y:200});
      applyTransform();
      loadSavedBoards();
      console.log('Initialization complete');
    }

    function resizeBoard(){
      board.style.width = `50000px`;
      board.style.height = `50000px`;
    }

    function applyTransform(){
      board.style.transform = `translate(${state.origin.x}px, ${state.origin.y}px) scale(${state.zoom})`;
      document.getElementById('zoomPct').textContent = `${Math.round(state.zoom*100)}%`;
    }

    function bindGlobal(){
      console.log('Binding global events...');
      
      const themeSel = document.getElementById('theme');
      themeSel.addEventListener('change', ()=> {
        const htmlEl = document.documentElement;
        htmlEl.classList.remove('light','retro');
        if (themeSel.value==='light') htmlEl.classList.add('light');
        else if (themeSel.value==='retro') htmlEl.classList.add('retro');
      });

      // Upload triggers
      document.getElementById('btnUploadImage').addEventListener('click', ()=> {
        console.log('Upload image clicked');
        document.getElementById('fileImage').click();
      });
      document.getElementById('btnUploadVideo').addEventListener('click', ()=> {
        console.log('Upload video clicked');
        document.getElementById('fileVideo').click();
      });
      document.getElementById('btnUploadPDF').addEventListener('click', ()=> {
        console.log('Upload PDF clicked');
        document.getElementById('filePDF').click();
      });
      
      document.getElementById('fileImage').addEventListener('change', (e)=> handleFiles(e.target.files));
      document.getElementById('fileVideo').addEventListener('change', (e)=> handleFiles(e.target.files));
      document.getElementById('filePDF').addEventListener('change',  (e)=> handleFiles(e.target.files));

      // Wheel zoom
      viewport.addEventListener('wheel', (e)=>{
        // Prevent board zoom when scrolling inside text inputs/boxes
        const inTextbox = e.target.closest('.textbox');
        const isEditable = e.target.closest('[contenteditable="true"]');
        const isFormInput = e.target.closest('input, textarea');
        if (inTextbox || isEditable || isFormInput) {
          return; // let the element handle its own scrolling
        }
        e.preventDefault();

        const delta = -e.deltaY;
        const zoomFactor = Math.exp(delta*0.001);
        const prev = state.zoom;
        const next = Math.min(4, Math.max(0.2, prev*zoomFactor));
        if(next===prev) return;
        const rect = viewport.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const ox = (cx - state.origin.x) / prev;
        const oy = (cy - state.origin.y) / prev;
        state.origin.x = cx - ox*next;
        state.origin.y = cy - oy*next;
        state.zoom = next;
        applyTransform();
      }, {passive:false});

      // Left-drag on empty canvas pans OR deselects
      viewport.addEventListener('mousedown', (e)=>{
        if(e.button===0 && typeof closeMenus==='function') closeMenus();
        if(e.button === 1) { // Middle mouse button - pan only
          e.preventDefault();
          startPanning(e);
          return;
        }
        
        if(e.button!==0) return; // Only handle left mouse button for selection/pan
        if (e.target.closest('.textbox')) return;
        // Check if clicking on empty space (not on any node, group, or textbox)
        const clickedOnContent = e.target.closest('.node, .group, .textbox');
        
        if(!clickedOnContent) {
          // Clicking on empty space
          if(e.shiftKey) { 
            beginMarquee(e); 
            return; 
          }
          
          // Clear selection on empty space click
          clearSelection();
          
          // Only start panning if we're not just deselecting
          startPanning(e);
        }
    });
      
      // Handle middle mouse button wheel clicks for panning
      viewport.addEventListener('auxclick', (e) => {
        if(e.button === 1) { // Middle mouse button
          e.preventDefault();
          startPanning(e);
        }
      });

      // Context menus
      viewport.addEventListener('contextmenu', (e)=>{
        console.log('Context menu triggered');
        e.preventDefault();
        
        // Check for wire handle first (highest priority)
        const wireHandle = e.target.closest('.wire-handle');
        if(wireHandle) {
          console.log('Opening wire handle context menu');
          openWireMenu(e.clientX, e.clientY, wireHandle);
          return;
        }
        
        // Check for wire path or hit area
        const wirePath = e.target.closest('.wire-path, .wire-hit-area');
        if(wirePath) {
          console.log('Opening wire path context menu');
          openWireMenu(e.clientX, e.clientY, wirePath);
          return;
        }
        
        // Check for checklist node
        const checklistNode = e.target.closest('.checknode');
        if(checklistNode) {
          console.log('Opening checklist context menu');
          openChecklistMenu(e.clientX, e.clientY, checklistNode);
          return;
        }
        
        const textbox = e.target.closest('.textbox');
        if(textbox && !textbox.classList.contains('metadata')){
          console.log('Opening textbox menu');
          const textboxObj = getTextboxByElement(textbox);
          if(textboxObj) {
            openTextboxMenu(e.clientX, e.clientY, textboxObj);
            return;
          }
        }
        
        const targetNode = e.target.closest('.node');
        if(targetNode){
          console.log('Opening node menu');
          const id = targetNode.dataset.id;
          openNodeMenu(e.clientX, e.clientY, getNodeById(id));
        }else{
          console.log('Opening canvas menu');
          // Group menu when right-clicking empty group area
          const groupEl = e.target.closest('.group');
          if(groupEl && !e.target.closest('.node')){
            console.log('Opening group menu');
            const gid = groupEl.dataset.id; const g = (typeof getGroupById==='function') ? getGroupById(gid) : groupEl;
            openGroupMenu(e.clientX, e.clientY, g);
            return;
          }

          openCanvasMenu(e.clientX, e.clientY);
        }
      });

      
// Close menus (including timeline) when clicking anywhere that's not a menu
document.addEventListener('mousedown', (e)=>{
  const m = e.target.closest && e.target.closest('.menu');
  if (!m && typeof closeMenus==='function') closeMenus();
}, true);
// Delete key
      window.addEventListener('keydown', (e)=>{
        const active = document.activeElement;
        if(active && active.classList && active.classList.contains('textbox')) return;
        if(active && active.tagName === 'INPUT') return;
        if(e.key==='Delete' || e.key==='Backspace'){
          const ids = Array.from(state.selection);
          ids.forEach(id=>{
            const n = getNodeById(id); if(n) { n.el.remove(); state.nodes = state.nodes.filter(x=>x!==n); }
            const g = getGroupById(id); if(g) { g.el.remove(); state.groups = state.groups.filter(x=>x!==g); }
            const t = getTextboxById(id); if(t) { t.element.remove(); state.textboxes = state.textboxes.filter(x=>x!==t); }
            const el = getElement(id); if(el && el.classList && el.classList.contains('checknode')){ if(typeof deleteChecklistNode==='function') deleteChecklistNode(el);}
          });
          clearSelection();
        }
      });

      window.addEventListener('resize', applyTransform);
    }

    function startPanning(e) {
      state.isPanning = true;
      state.panStart = {x:e.clientX, y:e.clientY};
      state.originStart = {...state.origin};
      viewport.classList.add('dragging');
      
      function move(ev){
        if(!state.isPanning) return;
        state.origin.x = state.originStart.x + (ev.clientX - state.panStart.x);
        state.origin.y = state.originStart.y + (ev.clientY - state.panStart.y);
        applyTransform();
      }
      function up(){
        state.isPanning=false;
        viewport.classList.remove('dragging');
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', up);
      }
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', up);
    }

    function bindUrlPanel(){
      console.log('Binding URL panel...');
      const urlInput = document.getElementById('urlInput');
      const btnImport = document.getElementById('btnImportUrl');
      const btnClear = document.getElementById('btnClearUrl');

      btnImport.addEventListener('click', ()=>{
        console.log('Import button clicked');
        const url = urlInput.value.trim();
        if(url){
          importFromUrl(url);
          urlInput.value = '';
        } else {
          alert('Please enter a URL');
        }
      });

      btnClear.addEventListener('click', ()=>{
        console.log('Clear button clicked');
        urlInput.value = '';
      });
    }

    function bindSavePanel(){
      console.log('Binding save panel...');
      document.getElementById('btnSave').addEventListener('click', saveBoard);
      document.getElementById('btnExport').addEventListener('click', exportBoard);
      document.getElementById('btnImport').addEventListener('click', ()=> document.getElementById('fileImport').click());
      document.getElementById('fileImport').addEventListener('change', importBoard);
    }

    function bindMapModal(){
      console.log('Binding map modal...');
      const modal = document.getElementById('mapModal');
      const startInput = document.getElementById('mapStart');
      const destInput = document.getElementById('mapDestination');
      const cancelBtn = document.getElementById('mapCancel');
      const createBtn = document.getElementById('mapCreate');

      cancelBtn.addEventListener('click', closeMapModal);
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeMapModal();
      });

      createBtn.addEventListener('click', () => {
        const start = startInput.value.trim();
        const destination = destInput.value.trim();
        
        if (!start || !destination) {
          alert('Please enter both start point and destination');
          return;
        }
        
        createGoogleMapNode(start, destination);
        closeMapModal();
      });

      // Handle Enter key
      [startInput, destInput].forEach(input => {
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            if (input === startInput && !destInput.value.trim()) {
              destInput.focus();
            } else {
              createBtn.click();
            }
          }
          if (e.key === 'Escape') {
            closeMapModal();
          }
        });
      });
    }

    function setupDragAndDrop() {
      const dropOverlay = document.getElementById('dropOverlay');
      
      // Prevent default drag behaviors
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.addEventListener(eventName, preventDefaults, false);
      

  try {
    const overlay = document.getElementById('dropOverlay') || document.body;
    const root = document.documentElement;
    const onDragEnter = (e)=>{ e.preventDefault(); e.stopPropagation(); overlay.classList && overlay.classList.add('show'); };
    const onDragOver  = (e)=>{ e.preventDefault(); e.stopPropagation(); };
    const onDragLeave = (e)=>{ e.preventDefault(); e.stopPropagation(); overlay.classList && overlay.classList.remove('show'); };
    const onDrop = (e)=>{
    e.preventDefault();
    // prevent other 'drop' listeners on the same target from firing
    if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    e.stopPropagation();
    overlay.classList && overlay.classList.remove('show');
    handleDrop(e);
  };
    if (!window.__DnD_WIRED__) {
    window.__DnD_WIRED__ = true;
    (root || document).addEventListener('dragenter', onDragEnter);
    (root || document).addEventListener('dragover',  onDragOver);
    (root || document).addEventListener('dragleave', onDragLeave);
    (root || document).addEventListener('drop',      onDrop);
  }} catch(_){}

});
      
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Highlight drop area
      
      // Robust anti-flicker DnD overlay logic
      let __dragCounter = 0;
      function __showOverlay(){ dropOverlay.classList.add('active'); }
      function __hideOverlay(){ dropOverlay.classList.remove('active'); __dragCounter = 0; }

      // Use capture phase to catch events consistently
      document.addEventListener('dragenter', function(e){
        // Only consider real drags (files or URLs/text)
        const types = (e.dataTransfer && e.dataTransfer.types) || [];
        if (types.length === 0) return;
        __dragCounter++;
        __showOverlay();
      }, true);

      document.addEventListener('dragover', function(e){
        // Required to allow drop
        e.preventDefault();
        if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
      }, true);

      document.addEventListener('dragleave', function(e){
        // Some browsers fire many dragleave events as you cross children.
        // Only hide when counter returns to zero.
        __dragCounter = Math.max(0, __dragCounter - 1);
        if (__dragCounter === 0) __hideOverlay();
      }, true);

      document.addEventListener('drop', function(e){
        __hideOverlay();
      }, true);

      // Safety: reset overlay if page visibility changes mid-drag
      document.addEventListener('visibilitychange', function(){
        if (document.hidden) __hideOverlay();
      });

      // Handle dropped files
      /* disabled duplicate: document.addEventListener('drop', handleDrop, false); */
      
      function handleDrop(e) {

  if (e && e.__handledDnD) { return; } e.__handledDnD = true;
const dt = e.dataTransfer;
  const dropPos = (typeof screenToWorld === 'function')
    ? screenToWorld(e.clientX, e.clientY)
    : {x: e.clientX, y: e.clientY};

  // 1) Files work as before
  const files = dt && dt.files;
  if (files && files.length){
    if (typeof handleFiles === 'function') {
      handleFiles(files, dropPos);
    }
    return;
  }

  // 2) Try to extract a URL from the drag payload
  const tryExtractUrl = (dt) => {
    try {
      // Prefer text/uri-list, then text/plain
      let t = (dt.getData && (dt.getData('text/uri-list') || dt.getData('text/plain'))) || '';
      if (!t) {
        // Some sources give only HTML with an <a href="...">
        const html = dt.getData && dt.getData('text/html');
        const m = html && html.match(/href="([^"]+)"/i);
        if (m) t = m[1];
      }
      const first = (t.split('\n').find(Boolean) || '').trim();
      if (/^(https?:\/\/|data:image\/)/i.test(first)) return first;
    } catch(_){}
    return null;
  };

  // Synchronous attempt
  let url = tryExtractUrl(dt);
  if (url){
    if (typeof importFromUrl === 'function') {
      // Safe to pass an extra argument (drop position) even if importFromUrl only expects 1
      importFromUrl(url, dropPos);
    }
    return;
  }

  // Fallback: some browsers expose strings via items.getAsString (async)
  if (dt && dt.items && dt.items.length){
    for (const item of dt.items){
      if (item.kind === 'string' && (item.type === 'text/uri-list' || item.type === 'text/plain')){
        item.getAsString(str=>{
          const u = (str||'').trim().split('\n').find(Boolean) || '';
          if (/^(https?:\/\/|data:image\/)/i.test(u)){
            if (typeof importFromUrl === 'function') {
              importFromUrl(u, dropPos);
            }
          }
        });
        break;
      }
    }
  }

}}

    function openMapModal() {
      console.log('Opening map modal...');
      const modal = document.getElementById('mapModal');
      const startInput = document.getElementById('mapStart');
      const destInput = document.getElementById('mapDestination');
      
      // Clear previous values
      startInput.value = '';
      destInput.value = '';
      
      modal.style.display = 'block';
      setTimeout(() => startInput.focus(), 100);
    }

    function closeMapModal() {
      console.log('Closing map modal...');
      document.getElementById('mapModal').style.display = 'none';
    }

    function createGoogleMapNode(start, destination) {
      console.log('Creating Google Map node:', { start, destination });
      
      const encodedStart = encodeURIComponent(start);
      const encodedDest = encodeURIComponent(destination);
      
      const workingMapUrl = `https://maps.google.com/maps?q=${encodedStart}+to+${encodedDest}&output=embed`;
      
      const rect = viewport.getBoundingClientRect();
      const pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      
      const size = { w: 560, h: 400 };
      const meta = {
        start: start,
        destination: destination,
        mapType: 'directions',
        embedUrl: workingMapUrl,
        fullUrl: `https://www.google.com/maps/dir/${encodedStart}/${encodedDest}`
      };
      
      return createNode('map', workingMapUrl, size, pos, meta);
    }

    function importFromUrl(url){
      console.log('Importing from URL:', url);
      
      const rect = viewport.getBoundingClientRect();
      const pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      
      // Detect URL type and handle accordingly
      const urlType = detectUrlType(url);
      
      switch(urlType) {
        case 'video-file':
          createVideoNode(url, pos, {kind:'file'});
          break;
        case 'video-hls':
          createVideoNode(url, pos, {kind:'hls'});
          break;
    
        case 'twitter':
          createTwitterNode(url, pos);
          break;

        case 'instagram':
          createInstagramNode(url, pos);
          break;

        case 'youtube':
        case 'youtube-shorts':
          const videoId = extractYouTubeId(url);
          if(videoId) {
            createYouTubeNode(videoId, pos, urlType === 'youtube-shorts');
          } else {
            alert('Invalid YouTube URL');
          }
          break;
          
        case 'image':
          createImageFromUrl(url, pos);
          break;
          
        case 'website':
          createWebsiteNode(url, pos);
          break;
          
        default:
          alert('Unsupported URL type. Please use YouTube, image URLs (JPG, PNG, GIF), or website URLs.');
      }
    }

    function detectUrlType(url) {
      
      // Direct video files
      if (/(?:\.mp4|\.webm|\.ogv|\.ogg|\.mov|\.m4v)(?:\?|#|$)/i.test(url)) return 'video-file';
      // HLS playlists
      if (/\.m3u8(?:\?|#|$)/i.test(url)) return 'video-hls';
      // Short NYT links -> website (likely not embeddable; we show a link card overlay)
      try{ const u=new URL(url); if(/(^|\.)nyti\.ms$/i.test(u.hostname)) return 'website'; }catch(_e){}
    // Data URLs for images (supports webp/jpg/png/gif/svg/bmp)
      if (/^data:image\/(?:png|jpe?g|gif|webp|svg\+xml|bmp)/i.test(url)) {
        return 'image';
      }

      
      
      // X (Twitter) posts
      if (/(?:^https?:\/\/)?(?:(?:www\.)?(?:x|twitter)\.com|mobile\.twitter\.com)\/[^\/]+\/status\/(\d+)/i.test(url)) {
        return 'twitter';
      }
    // Instagram posts & Reels (also supports windows.instagram.com)
      if (/(?:^https?:\/\/)?(?:www\.|m\.|windows\.)?instagram\.com\/(?:reel|reels|p|tv)\//i.test(url)) {
        return 'instagram';
      }
    // YouTube regular videos
      if(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)/i.test(url)) {
        return 'youtube';
      }
      
      // YouTube Shorts
      if(/youtube\.com\/shorts\//i.test(url)) {
        return 'youtube-shorts';
      }
      
      // Image URLs
      if(/\.(jpg|jpeg|png|gif|webp|svg|bmp)(\?.*)?$/i.test(url)) {
        return 'image';
      }
      
      // Website URLs (anything with http/https that's not above)
      if(/^https?:\/\//i.test(url)) {
        return 'website';
      }
      
      return 'unknown';
    }

    function extractYouTubeId(url){
      const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/v\/([^&\n?#]+)/,
        /youtube\.com\/shorts\/([^&\n?#]+)/
      ];
      for(const pattern of patterns){
        const match = url.match(pattern);
        if(match) return match[1];
      }
      return null;
    }

    function createYouTubeNode(videoId, at, isShorts = false){
      const embedUrl = `https://www.youtube.com/embed/${videoId}`;
      const size = isShorts ? {w: 315, h: 560} : {w: 560, h: 315};
      const meta = {
        videoId: videoId,
        platform: 'youtube',
        embedUrl: embedUrl,
        isShorts: isShorts
      };
      return createNode('youtube', embedUrl, size, at, meta);
    }

    function createImageFromUrl(url, at) {
      console.log('Creating image from URL:', url);
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      
      img.onload = function() {
        const naturalW = img.naturalWidth;
        const naturalH = img.naturalHeight;
        const size = calculateOptimalImageSize(naturalW, naturalH);
        
        const meta = {
          originalUrl: url,
          dimensions: {w: naturalW, h: naturalH},
          source: 'url'
        };
        
        createNode('image', url, size, at, meta);
      };
      
      img.onerror = function() {
        alert('Failed to load image from URL. The image may not be accessible or may have CORS restrictions.');
      };
      
      img.src = url;
    }

    function createWebsiteNode(url, at) {
      console.log('Creating website node:', url);
      
      if (!url.match(/^https?:\/\//i)) {
        url = 'https://' + url;
      }
      
      const size = { w: 800, h: 600 };
      const meta = {
        originalUrl: url,
        website: true,
        domain: extractDomain(url)
      };
      
      return createNode('website', url, size, at, meta);
    }

    function extractDomain(url) {
      try {
        return new URL(url).hostname;
      } catch (e) {
        return 'Unknown';
      }
    }

    // Fixed textbox creation with proper state management
    function createFloatingTextbox(at){
      console.log('Creating textbox at:', at);
      const id = 't'+(state.nextId++);
      const el = document.createElement('div');
      el.className = 'textbox';
      el.contentEditable = 'true';
      el.spellcheck = false;
      el.dataset.id = id;
      el.style.left = at.x + 'px';
      el.style.top = at.y + 'px';
      el.style.width = '280px';
      el.style.height = '160px';
      
      const textboxObj = {
        id: id,
        element: el,
        hasPlaceholder: true,
        isEditing: false
      };
      
      state.textboxes.push(textboxObj);
      
      // Set initial placeholder
      setPlaceholderText(textboxObj);
      setupTextboxEvents(textboxObj);

      board.appendChild(el);
      return textboxObj;
    }

    function setPlaceholderText(textboxObj) {
      const el = textboxObj.element;
      el.innerHTML = '<span style="color: var(--muted); opacity: 0.7;">Click to start typing...</span>';
      textboxObj.hasPlaceholder = true;
      textboxObj.isEditing = false;
    }

    function clearPlaceholderText(textboxObj) {
      if (textboxObj.hasPlaceholder) {
        textboxObj.element.innerHTML = '';
        textboxObj.hasPlaceholder = false;
      }
    }

    function setupTextboxEvents(textboxObj) {
      const el = textboxObj.element;
      
      el.addEventListener('focus', ()=>{
        clearPlaceholderText(textboxObj);
        textboxObj.isEditing = true;
        el.style.cursor = 'text';
      });
      
      el.addEventListener('blur', ()=>{
        const textContent = el.textContent || '';
        const htmlContent = el.innerHTML || '';
        
        if(textContent.trim() === '' || htmlContent.trim() === '') {
          setPlaceholderText(textboxObj);
        }
        textboxObj.isEditing = false;
        el.style.cursor = 'grab';
      });

      // Selection and dragging
      el.addEventListener('mousedown', (e)=>{
        // Let real links win first
        const link = e.target.closest('a[href]');
        if (link) {
          // Do NOT select or start drag; let the upcoming click handler decide.
          return; 
        }
        if(e.target.classList.contains('tb-resizer')) return;
        
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) {
          toggleSelect(textboxObj.id);
        } else {
          selectId(textboxObj.id);
        }
        
        const isClickToEdit = !textboxObj.isEditing && (textboxObj.hasPlaceholder || !el.contains(document.activeElement));
        
        if(isClickToEdit){
          setTimeout(() => {
            el.focus();
            clearPlaceholderText(textboxObj);
            textboxObj.isEditing = true;
          }, 10);
          return;
        }
        
        if(!textboxObj.isEditing) {
          startTextboxDrag(e, textboxObj);
        }
        
        e.stopPropagation();
      });

      // Add a dedicated click handler for links:
      el.addEventListener('click', (e)=>{
        const link = e.target.closest('a[href]');
        if (!link) return;
        // If editing, only open on Cmd/Ctrl-click (keeps normal clicks for caret placement)
        if (textboxObj.isEditing && !(e.metaKey || e.ctrlKey)) {
          return; // let the caret move
        }
        e.preventDefault(); // prevent contenteditable caret quirks
        const href = link.getAttribute('href');
        if (href) window.open(href, '_blank', 'noopener');
      });

      // Add resizer
      const rh = document.createElement('div'); 
      rh.className = 'tb-resizer'; 
      rh.title = 'Drag to resize';
      el.appendChild(rh);
      
      rh.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        
        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = el.offsetWidth;
        const startHeight = el.offsetHeight;
        
        function mousemove(ev){
          const dx = (ev.clientX - startX) / state.zoom;
          const dy = (ev.clientY - startY) / state.zoom;
          const newWidth = Math.max(200, startWidth + dx);
          const newHeight = Math.max(120, startHeight + dy);
          
          el.style.width = newWidth + 'px';
          el.style.height = newHeight + 'px';
        }
        
        function mouseup(){
          window.removeEventListener('mousemove', mousemove);
          window.removeEventListener('mouseup', mouseup);
        }
        
        window.addEventListener('mousemove', mousemove);
        window.addEventListener('mouseup', mouseup);
      });
    }

    function startTextboxDrag(e, textboxObj) {
      const el = textboxObj.element;
      const selectedTextboxes = Array.from(state.selection)
        .map(id => getTextboxById(id))
        .filter(t => t && t !== null);
      
      if(selectedTextboxes.length === 0) {
        selectedTextboxes.push(textboxObj);
      }
      
      const startX = e.clientX;
      const startY = e.clientY;
      const startPositions = {};
      
      selectedTextboxes.forEach(t => {
        startPositions[t.id] = {
          x: parseFloat(t.element.style.left),
          y: parseFloat(t.element.style.top)
        };
      });
      
      el.style.cursor = 'grabbing';
      
      function mousemove(ev){
        const dx = (ev.clientX - startX) / state.zoom;
        const dy = (ev.clientY - startY) / state.zoom;
        
        selectedTextboxes.forEach(t => {
          const start = startPositions[t.id];
          t.element.style.left = (start.x + dx) + 'px';
          t.element.style.top = (start.y + dy) + 'px';
        });
        // <— add this
        try { if (window.updateAllWires) updateAllWires(); } catch(_){ }
      }
      
      function mouseup(){
        el.style.cursor = 'grab';
        window.removeEventListener('mousemove', mousemove);
        window.removeEventListener('mouseup', mouseup);
      }
      
      window.addEventListener('mousemove', mousemove);
      window.addEventListener('mouseup', mouseup);
    }

    // Menu functions


function openGroupMenu(x, y, group){
  const menu = document.getElementById('groupMenu');
  if(!menu || !group) return;
  if (typeof closeMenus==='function') closeMenus();
  menu.style.left = x+'px';
  menu.style.top  = y+'px';
  menu.classList.add('open');

  const isLocked = !!(group.locked || (group.el && (group.el.dataset.locked==='1' || group.el.classList.contains('locked'))));
  const lockBtn = menu.querySelector('button[data-action="toggle-lock"]');
  if (lockBtn) lockBtn.textContent = isLocked ? 'Unlock' : 'Lock';

  menu.onmousedown = (e)=> e.stopPropagation();
  menu.onclick = (e)=>{
    const act = e.target && e.target.getAttribute('data-action');
    if(!act) return;
    if (typeof closeMenus==='function') closeMenus();

    if (act==='toggle-lock'){
      const next = !(
        group.locked || (group.el && (group.el.dataset.locked==='1' || group.el.classList.contains('locked')))
      );
      group.locked = next;
      if (group.el){
        group.el.classList.toggle('locked', next);
        group.el.dataset.locked = next ? '1' : '0';
        group.el.style.cursor = next ? 'default' : 'grab';
      }
      return;
    }
    if (act==='rename'){
      try {
        const title = group.el && group.el.querySelector('.title');
        if (title){ title.click(); }
      } catch(_){}
      return;
    }
    if (act==='duplicate'){ duplicateSelection(group.id); return; }
    if (act==='delete'){ deleteSelection(group.id); return; }
      if (state && state.selection) state.selection.delete(group.id);
      return;
    }
  };

    let canvasContextPoint = {x:0,y:0};
    
    function openCanvasMenu(x,y){
      console.log('Opening canvas menu at', x, y);
      closeMenus();
      canvasMenu.style.left = x+'px'; 
      canvasMenu.style.top = y+'px';
      canvasMenu.classList.add('open');
      canvasContextPoint = screenToWorld(x,y);
      
      canvasMenu.onmousedown = (e)=>e.stopPropagation();
      canvasMenu.onclick = (e)=>{
        const act = e.target.dataset.action; 
        if(!act) return;
        console.log('Canvas menu action:', act);
        closeMenus();
        if(act==='upload-image') document.getElementById('fileImage').click();
        if(act==='upload-video') document.getElementById('fileVideo').click();
        if(act==='upload-pdf') document.getElementById('filePDF').click();
        if(act==='add-google-map') openMapModal();
        if (act==='add-whiteboard') {
        const n = createWebsiteNode('https://drawnix.com/', canvasContextPoint);
        // Optional friendly title:
        if (n && n.el) { n.title = 'White Board'; n.el.querySelector('.title').textContent = n.title; }
}
        if (act==='add-Vegas-Charts') {
        const n = createWebsiteNode('https://vega.github.io/editor/', canvasContextPoint);
        if (n && n.el) { n.title = 'Vegas Charts'; n.el.querySelector('.title').textContent = n.title; }
}
        if (act==='add-calendar') {
        const n = createWebsiteNode('https://xsleuthx.github.io/Colorful-Calendar/', canvasContextPoint);
        if (n && n.el) { n.title = 'Calendar'; n.el.querySelector('.title').textContent = n.title; }
}
        if (act==='add-lightbox') {
        const n = createWebsiteNode('https://xsleuthx.github.io/Lightbox/', canvasContextPoint);
        if (n && n.el) { n.title = 'Lightbox'; n.el.querySelector('.title').textContent = n.title; }
}
        if (act==='add-shotlist-builder') {
        const n = createWebsiteNode('https://xsleuthx.github.io/Shotlist-Builder/', canvasContextPoint);
        if (n && n.el) { n.title = 'Shotlist Builder'; n.el.querySelector('.title').textContent = n.title; }
}
        if(act==='create-group') createGroup(canvasContextPoint);
        if(act==='create-textbox') createFloatingTextbox(canvasContextPoint);
        if(act==='create-timeline-h'){ window.createTimeline({direction:'h', at: canvasContextPoint}); }
        if(act==='create-timeline-v'){ window.createTimeline({direction:'v', at: canvasContextPoint}); }
        if(act==='add-checknode') {
          // Create checklist node at context point
          if(typeof window.addChecklistNodeAt === 'function') {
            window.addChecklistNodeAt(canvasContextPoint.x, canvasContextPoint.y, 'New item', false);
          }
        }
      };
    }
    
    function openNodeMenu(x,y,node){
      console.log('Opening node menu at', x, y);
      closeMenus();
      nodeMenu.style.left = x+'px'; 
      nodeMenu.style.top = y+'px';
      nodeMenu.classList.add('open');
      const lockBtn = nodeMenu.querySelector('button[data-action="toggle-lock"]');
      if (lockBtn){ lockBtn.textContent = (node.locked ? 'Unlock' : 'Lock'); }
      
      const toggleBtn = nodeMenu.querySelector('button[data-action="toggle-metadata"]');
      if(node.kind==='image'){
        toggleBtn.style.display='block';
        toggleBtn.textContent = node.metaShown ? 'Close metadata' : 'Show metadata';
      }else{
        toggleBtn.style.display='none';
      }
      
      nodeMenu.onmousedown = (e)=>e.stopPropagation();
      nodeMenu.onclick = (e) => {

        const act = e.target.dataset.action; 
        if(!act) return;
        console.log('Node menu action:', act);
        closeMenus();
        if(act==='toggle-lock'){
          node.locked = !node.locked;
          if (node.el){
            node.el.classList.toggle('locked', node.locked);
            node.el.dataset.locked = node.locked ? '1' : '0';
            node.el.style.cursor = node.locked ? 'default' : 'grab';
          }
          const lockBtn2 = nodeMenu.querySelector('button[data-action="toggle-lock"]');
          if (lockBtn2){ lockBtn2.textContent = node.locked ? 'Unlock' : 'Lock'; }
          return;
        }

        if (act==='connect'){
          // Begin connection mode from this node's element
          if (typeof window.__startConnectFrom === 'function') {
            window.__startConnectFrom(node.el);
          }
          return;
        }
        if(act==='delete'){ deleteSelection(node.id); }
        if(act==='duplicate'){ duplicateSelection(node.id); }
        if(act==='toggle-metadata'){
          if(node.metaShown){
            if(node.metaTextbox){ node.metaTextbox.remove(); node.metaTextbox = null; }
            node.metaShown=false;
          }else{
            node.metaTextbox = createMetadataTextbox(node);
            node.metaShown=true;
          }
        }
        if(act==='open'){
          if(node.kind==='image') window.open(node.assetUrl, '_blank');
          else if(node.kind==='video'){ const v = node.el.querySelector('video'); v && v.play(); }
          else if(node.kind==='pdf') window.open(node.assetUrl, '_blank');
          else if(node.kind==='youtube') window.open(`https://www.youtube.com/watch?v=${node.meta.videoId}`, '_blank');
          else if(node.kind==='map') {
            const fullUrl = node.meta.fullUrl || `https://www.google.com/maps/dir/${encodeURIComponent(node.meta.start || '')}/${encodeURIComponent(node.meta.destination || '')}`;
            window.open(fullUrl, '_blank');
          }
          else if(node.kind==='website') {
            const originalUrl = node.meta.originalUrl || node.assetUrl;
            window.open(originalUrl, '_blank');
          }
        }

};
    }

    
function openTextboxMenu(x, y, textboxObj){
  console.log('Opening textbox menu at', x, y);
  closeMenus();
  const textboxMenu = document.getElementById('textboxMenu');
  textboxMenu.style.left = x + 'px';
  textboxMenu.style.top  = y + 'px';
  textboxMenu.classList.add('open');

  // Normalize to an element (support passing either object or element)
  const el = textboxObj && (textboxObj.element || textboxObj);
  if (!el) return;

  const isLocked = (typeof textboxObj?.locked === 'boolean')
    ? textboxObj.locked
    : (el.dataset.locked === '1' || el.classList.contains('locked'));

  const lockBtn = textboxMenu.querySelector('button[data-action="toggle-lock"]');
  if (lockBtn) lockBtn.textContent = (isLocked ? 'Unlock' : 'Lock');

  textboxMenu.onmousedown = (e)=> e.stopPropagation();
  textboxMenu.onclick = (e)=>{
    const act = e.target && e.target.getAttribute('data-action');
    if(!act) return;
    if (typeof closeMenus==='function') closeMenus();

    if (act==='toggle-lock'){
      const next = !( (typeof textboxObj?.locked === 'boolean')
        ? textboxObj.locked
        : (el.dataset.locked === '1' || el.classList.contains('locked')) );
      if (textboxObj) textboxObj.locked = next;
      el.classList.toggle('locked', next);
      el.dataset.locked = next ? '1' : '0';
      el.style.cursor = next ? 'default' : 'grab';
      const lockBtn2 = textboxMenu.querySelector('button[data-action="toggle-lock"]');
      if (lockBtn2) lockBtn2.textContent = next ? 'Unlock' : 'Lock';
      return;
    }

    if (act === 'color'){
      e.stopPropagation();
      window.__openingTextboxColor = true;
      setTimeout(()=>{
        if (typeof window.openTextboxColorAt === 'function') {
          window.openTextboxColorAt(x + 12, y + 8, el);
        }
        window.__openingTextboxColor = false;
      }, 0);
      return;
    }

    if (act==='connect'){
      if (typeof window.__startConnectFrom === 'function') {
        window.__startConnectFrom(el);
      }
      return;
    }

    if(act==='delete'){ const __el = (textboxObj && (textboxObj.element||textboxObj)); const __id = (textboxObj && textboxObj.id) || (__el && __el.dataset && __el.dataset.id); deleteSelection(__id); return; }
    if(act==='duplicate'){ const __el = (textboxObj && (textboxObj.element||textboxObj)); const __id = (textboxObj && textboxObj.id) || (__el && __el.dataset && __el.dataset.id); duplicateSelection(__id); return; }
  };
}

    
    function openWireMenu(x, y, wireElement){
      console.log('Opening wire menu at', x, y);
      closeMenus();
      wireMenu.style.left = x + 'px';
      wireMenu.style.top = y + 'px';
      wireMenu.classList.add('open');
      
      wireMenu.onmousedown = (e) => e.stopPropagation();
      wireMenu.onclick = (e) => {
        const act = e.target.dataset.action;
        if(!act) return;
        console.log('Wire menu action:', act);
        closeMenus();
        
        if(act === 'disconnect') {
          // Find the wire to disconnect
          disconnectWire(wireElement);
        }
      };
    }
    
    // --- PATCH: disconnectWire removes from DOM + state.wires ---
  function disconnectWire(wireElement) {
  console.log('Disconnecting wire:', wireElement);

  // Ensure state.wires exists
  if (!window.state) window.state = {};
  if (!Array.isArray(state.wires)) state.wires = [];

  // Helper: remove the wire object from state by matching its elements
  function removeWireFromState(matchElOrGroup) {
    if (!matchElOrGroup) return false;

    // find the entry whose refs equal OR are contained by the group
    const idx = state.wires.findIndex(w => {
      if (!w) return false;
      // direct element matches
      if (w.g   === matchElOrGroup) return true;
      if (w.path=== matchElOrGroup) return true;
      if (w.hit === matchElOrGroup) return true;

      // group containment matches
      const contains = (el) => !!(matchElOrGroup.contains && el && matchElOrGroup.contains(el));
      return contains(w.g) || contains(w.path) || contains(w.hit);
    });

    if (idx >= 0) {
      const w = state.wires[idx];

      // detach adjacency if you track it (optional)
      if (w && typeof getNodeById === 'function') {
        const from = getNodeById(w.fromId);
        const to   = getNodeById(w.toId);
        if (from && Array.isArray(from.connections)) {
          from.connections = from.connections.filter(cid => cid !== (w.id || w._id));
        }
        if (to && Array.isArray(to.connections)) {
          to.connections = to.connections.filter(cid => cid !== (w.id || w._id));
        }
      }

      // clear DOM refs + remove from state
      try { if (w.g && w.g.remove) w.g.remove(); } catch(_) {}
      w.g = w.path = w.hit = w.fromEl = w.toEl = null;
      state.wires.splice(idx, 1);
      return true;
    }
    return false;
  }

  // STRATEGY 1: nearest <g data-wire-id> (if you ever add IDs)
  const idGroup = wireElement.closest('g[data-wire-id]');
  if (idGroup) {
    const wireId = idGroup.dataset.wireId;
    console.log('Found wire group with ID:', wireId);

    // remove from state by group (works even without ID)
    const removed = removeWireFromState(idGroup);

    // remove DOM group
    try { idGroup.remove(); } catch(_) {}

    // refresh
    if (typeof updateAllWires === 'function') { try { updateAllWires(); } catch(_) {} }
    if (typeof markDirty === 'function') markDirty('wires');

    console.log(removed ? 'Wire disconnected (by ID group) and removed from state.' :
                          'Wire disconnected (by ID group) but no state entry matched.');
    return;
  }

  // STRATEGY 2: any parent group containing wire visuals
  let wireContainer = wireElement.closest('g');
  while (wireContainer) {
    const hasWirePath   = wireContainer.querySelector('.wire-path, .wire-hit-area');
    const hasWireHandle = wireContainer.querySelector('.wire-handle');

    if (hasWirePath || hasWireHandle) {
      console.log('Found wire container group, removing:', wireContainer);

      // remove from state using the container group (this is the path in your logs)
      const removed = removeWireFromState(wireContainer);

      // remove DOM
      try { wireContainer.remove(); } catch(_) {}

      // refresh
      if (typeof updateAllWires === 'function') { try { updateAllWires(); } catch(_) {} }
      if (typeof markDirty === 'function') markDirty('wires');

      console.log(removed ? 'Wire disconnected via container group (state updated).' :
                            'Wire disconnected via container group (no state match found).');
      return;
    }
    wireContainer = wireContainer.parentElement?.closest('g');
  }

  // STRATEGY 3: remove the immediate parent group (fallback)
  const immediateGroup = wireElement.closest('g');
  if (immediateGroup) {
    console.log('Removing immediate parent group as fallback');

    const removed = removeWireFromState(immediateGroup);
    try { immediateGroup.remove(); } catch(_) {}

    if (typeof updateAllWires === 'function') { try { updateAllWires(); } catch(_) {} }
    if (typeof markDirty === 'function') markDirty('wires');

    console.log(removed ? 'Wire disconnected via immediate group (state updated).' :
                          'Wire disconnected via immediate group (no state match found).');
    return;
  }

  // STRATEGY 4: remove the element itself (path/hit)
  if (wireElement.classList &&
      (wireElement.classList.contains('wire-path') || wireElement.classList.contains('wire-hit-area'))) {
    console.log('Removing wire element directly');

    const removed = removeWireFromState(wireElement);
    try { wireElement.remove(); } catch(_) {}

    if (typeof updateAllWires === 'function') { try { updateAllWires(); } catch(_) {} }
    if (typeof markDirty === 'function') markDirty('wires');

    console.log(removed ? 'Wire element removed directly (state updated).' :
                          'Wire element removed directly (no state match found).');
    return;
  }

  console.warn('Could not find a suitable wire element to remove');
}
// --- END PATCH --- //
    
function openChecklistMenu(x, y, checklistElement){
  console.log('Opening checklist menu at', x, y);
  closeMenus();
  const textboxMenu = document.getElementById('textboxMenu');
  textboxMenu.style.left = x + 'px';
  textboxMenu.style.top  = y + 'px';
  textboxMenu.classList.add('open');

  const el = checklistElement;
  const isLocked = el && (el.dataset.locked === '1' || el.classList.contains('locked'));

  const lockBtn = textboxMenu.querySelector('button[data-action="toggle-lock"]');
  if (lockBtn) lockBtn.textContent = (isLocked ? 'Unlock' : 'Lock');

  textboxMenu.onmousedown = (e)=> e.stopPropagation();
  textboxMenu.onclick = (e)=>{
    const act = e.target && e.target.getAttribute('data-action');
    if(!act) return;
    if (typeof closeMenus==='function') closeMenus();

    if (act==='toggle-lock'){
      const next = !(el.dataset.locked === '1' || el.classList.contains('locked'));
      el.classList.toggle('locked', next);
      el.dataset.locked = next ? '1' : '0';
      el.style.cursor = next ? 'default' : 'grab';
      const lockBtn2 = textboxMenu.querySelector('button[data-action="toggle-lock"]');
      if (lockBtn2) lockBtn2.textContent = next ? 'Unlock' : 'Lock';
      return;
    }

    if (act === 'connect'){
      if (typeof window.__startConnectFrom === 'function') {
        window.__startConnectFrom(el);
      }
      return;
    }
    if (act === 'delete'){ deleteSelection(el && el.dataset && el.dataset.id); return; }
    if (act==='duplicate'){ duplicateSelection(el && el.dataset && el.dataset.id); return; }
  };
}

    
    function closeMenus(){ 
      canvasMenu.classList.remove('open'); 
      nodeMenu.classList.remove('open'); 
      textboxMenu.classList.remove('open'); 
      wireMenu.classList.remove('open'); 
      const groupMenu = document.getElementById('groupMenu'); if(groupMenu) groupMenu.classList.remove('open'); 
      const timelineMenu = document.getElementById('timelineMenu'); if(timelineMenu) timelineMenu.classList.remove('open');
      const timestampMenu = document.getElementById('timestampMenu'); if(timestampMenu) timestampMenu.classList.remove('open');
    }

    function removeTextbox(textboxObj) {
      textboxObj.element.remove();
      state.textboxes = state.textboxes.filter(t => t !== textboxObj);
      state.selection.delete(textboxObj.id);
    }

    function duplicateTextbox(textboxObj) {
      const originalEl = textboxObj.element;
      const newPos = {
        x: parseFloat(originalEl.style.left) + 20,
        y: parseFloat(originalEl.style.top) + 20
      };
      
      const newTextbox = createFloatingTextbox(newPos);
      newTextbox.element.style.width = originalEl.style.width;
      newTextbox.element.style.height = originalEl.style.height;
      
      // Copy content properly, handling placeholder text
      if (!textboxObj.hasPlaceholder) {
        newTextbox.element.innerHTML = originalEl.innerHTML;
        newTextbox.hasPlaceholder = false;
      }
      newTextbox.element.blur();
      
      return newTextbox;
    }
    
    function deleteChecklistNode(checklistElement) {
      const checklistId = checklistElement.dataset.id;
      
      // Remove from DOM
      checklistElement.remove();
      
      // Remove from tracking array
      if(window.checklistNodes) {
        const index = window.checklistNodes.findIndex(c => c.id === checklistId);
        if(index !== -1) {
          window.checklistNodes.splice(index, 1);
        }
      }
    }
    
    
function duplicateChecklistNode(checklistElement) {
  const checklistId = checklistElement.dataset.id;
  const checklistData = window.checklistNodes ? window.checklistNodes.find(c => c.id === checklistId) : null;
  if(checklistData && window.addChecklistNodeAt) {
    const newX = checklistData.x + 20;
    const newY = checklistData.y + 20;
    const nodeEl = checklistData.element;
    const textEl = nodeEl ? nodeEl.querySelector('.checktext') : null;
    const w = nodeEl ? (nodeEl.style.width || nodeEl.offsetWidth) : null;
    const h = nodeEl ? (nodeEl.style.height || nodeEl.offsetHeight) : null;
    const bg = nodeEl && nodeEl.style.backgroundColor || null;
    const border = nodeEl && nodeEl.style.borderColor || null;
    const color = nodeEl && nodeEl.style.color || null;
    const fontSize = textEl && (textEl.style.fontSize || null);
  const tcs = textEl ? getComputedStyle(textEl) : null;
    const html = textEl ? sanitizeHtml(textEl.innerHTML) : null;
    window.addChecklistNodeAt(newX, newY, checklistData.text, checklistData.checked, w, h, {bg, border, color, html}, null, fontSize);
  }
}

    // Node creation
    function createNode(kind, assetUrl, size, at, extraMeta){
      const id = 'n'+(state.nextId++);
      const node = { 
        id, kind, x: at.x, y: at.y, w: size.w, h: size.h, assetUrl, textboxes:[], 
        meta: extraMeta||{}, metaShown:false, metaTextbox: null,
        title: generateNodeTitle(kind, extraMeta),
        locked:false
      };
      state.nodes.push(node);

      const el = document.createElement('div');
      el.className = `node ${kind}`;
      el.dataset.id = id;
      el.style.left = node.x+'px'; el.style.top = node.y+'px';
      el.style.width = node.w+'px'; el.style.height = node.h+'px'; 
      el.dataset.locked = node.locked ? '1' : '0';
      el.style.cursor = node.locked ? 'default' : 'grab'; 

      const title = document.createElement('div'); 
      title.className='title'; 
      title.textContent = node.title; 
      el.appendChild(title);

      const content = document.createElement('div'); 
      content.className='content'; 
      content.setAttribute('draggable','false'); 
      el.appendChild(content);
      
      if(kind==='image'){ 
        const img = document.createElement('img'); 
        img.src = assetUrl; 
        img.draggable=false; 
        content.appendChild(img); 
      }
      else if(kind==='video'){ 
        const vid = document.createElement('video'); 
        vid.src = assetUrl; 
        vid.controls = true; 
        vid.draggable=false; 
        content.appendChild(vid); 
      }
      else if(kind==='pdf'){ 
        const emb = document.createElement('embed'); 
        emb.src = assetUrl; 
        emb.type='application/pdf'; 
        emb.draggable=false; 
        content.appendChild(emb); 
      }
      else if(kind==='youtube'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        iframe.draggable = false;
        content.appendChild(iframe);
      }
      else if(kind==='map'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        iframe.draggable = false;
        iframe.loading = 'lazy';
        iframe.referrerPolicy = 'no-referrer-when-downgrade';
        content.appendChild(iframe);
      }
      else if(kind==='website'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        iframe.allow = (iframe.allow || '') + '; autoplay; encrypted-media; clipboard-write; picture-in-picture; web-share; fullscreen';
        iframe.allow = (iframe.allow || '') + '; autoplay; encrypted-media; clipboard-write; picture-in-picture; web-share; fullscreen';
        iframe.draggable = false;
        iframe.loading = 'lazy';
        iframe.referrerPolicy = 'no-referrer-when-downgrade';
        if (!/instagram\.com\/.*\/embed\/?/i.test(assetUrl)) {
        if (!/instagram\.com\/.*\/embed\/?/i.test(assetUrl)) { iframe.sandbox = 'allow-same-origin allow-modals allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox'; }
      }
        content.appendChild(iframe);
      }

      
      
      else if(kind==='video'){
        const wrapper = document.createElement('div');
        wrapper.className = 'video-host';
        wrapper.style.width='100%';
        wrapper.style.height='100%';
        wrapper.style.display='flex';
        wrapper.style.alignItems='center';
        wrapper.style.justifyContent='center';
        wrapper.style.background='#000';

        const video = document.createElement('video');
        video.controls = true;
        video.playsInline = true;
        video.style.width='100%';
        video.style.height='100%';
        video.style.objectFit='contain';
        wrapper.appendChild(video);
        content.appendChild(wrapper);

        const src = assetUrl;
        if (node.meta && node.meta.type === 'hls'){
          ensureHlsJs().then((Hls)=>{
            try{
              if (Hls && Hls.isSupported()){
                const hls = new Hls();
                hls.loadSource(src);
                hls.attachMedia(video);
              } else if (video.canPlayType('application/vnd.apple.mpegURL')){
                video.src = src;
              } else {
                video.outerHTML = '<div style="color:#fff;padding:12px;">HLS not supported in this browser.</div>';
              }
            }catch(err){
              console.warn('HLS init failed', err);
              video.outerHTML = '<div style="color:#fff;padding:12px;">HLS failed to initialize.</div>';
            }
          });
        } else {
          video.src = src;
        }
      }
else if(kind==='twitter'){
        const host = document.createElement('div');
        host.className = 'tweet-host';
        host.style.width='100%';
        host.style.height='100%';
        host.style.overflow='hidden';
        content.appendChild(host);
        ensureTwitterWidgets().then(function(tw){
          if (tw && tw.widgets && node.meta && node.meta.tweetId){
            tw.widgets.createTweet(node.meta.tweetId, host, { align: 'center' });
          }
        }).catch(console.warn);
      }
const toolbar = document.createElement('div'); 
      toolbar.className='toolbar';
      
      if(kind==='image'){
        const metaBtn = document.createElement('button'); 
        metaBtn.textContent='Show metadata';
        metaBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          if(node.metaShown){
            if(node.metaTextbox){ node.metaTextbox.remove(); node.metaTextbox = null; }
            node.metaShown = false; 
            metaBtn.textContent='Show metadata';
          }else{
            const box = createMetadataTextbox(node);
            node.metaTextbox = box;
            node.metaShown = true; 
            metaBtn.textContent='Close metadata';
          }
        });
        toolbar.appendChild(metaBtn);
      }
      el.appendChild(toolbar);

      setupTitleRename(title, node);

      if(kind==='image' || kind==='youtube' || kind==='pdf' || kind==='map' || kind==='website' || kind==='twitter'){
        const res = document.createElement('div'); 
        res.title="Resize";
        res.style.position='absolute'; res.style.width='12px'; res.style.height='12px';
        res.style.right='-6px'; res.style.bottom='-6px'; res.style.background='var(--handle-bg)';
        res.style.border='2px solid var(--handle-border)'; res.style.borderRadius='50%'; 
        res.style.cursor='nwse-resize'; res.style.zIndex='3';
        el.appendChild(res);
        
        res.addEventListener('mousedown', (e)=>{
          e.stopPropagation();
          const start = {x:e.clientX, y:e.clientY, w:node.w, h:node.h};
          function mm(ev){
                        const dx = (ev.clientX-start.x)/state.zoom;
            const dy = (ev.clientY-start.y)/state.zoom;
            node.w = Math.max(160, start.w + dx);
            node.h = Math.max(120, start.h + dy);
            el.style.width = node.w+'px'; 
            el.style.height = node.h+'px';
            if(node.metaTextbox){
              node.metaTextbox.style.left = (node.w + 16) + 'px';
            }
}
          function up(){ 
            window.removeEventListener('mousemove', mm); 
            window.removeEventListener('mouseup', up); 
          }
          window.addEventListener('mousemove', mm); 
          window.addEventListener('mouseup', up);
        });
      }

      board.appendChild(el);
      node.el = el;
      enableNodeInteractions(node);
      return node;
    }

    function setupTitleRename(titleEl, item) {
      let isRenaming = false;
      
      titleEl.addEventListener('click', (e)=>{
        e.stopPropagation();
        startRename();
      });
      
      function startRename(){
        if(isRenaming) return;
        isRenaming = true;
        
        const originalText = titleEl.textContent;
        titleEl.classList.add('editing');
        titleEl.contentEditable = true;
        titleEl.focus();
        
        const range = document.createRange();
        range.selectNodeContents(titleEl);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        
        function finishRename(){
          isRenaming = false;
          titleEl.contentEditable = false;
          titleEl.classList.remove('editing');
          
          const newText = titleEl.textContent.trim();
          if(newText && newText !== originalText){
            item.title = newText;
          } else {
            titleEl.textContent = originalText;
          }
        }
        
        function handleClickOutside(e) {
          if (!titleEl.contains(e.target)) {
            finishRename();
            document.removeEventListener('click', handleClickOutside);
          }
        }
        
        titleEl.addEventListener('blur', finishRename, {once: true});
        titleEl.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            titleEl.blur();
          }
          if(e.key === 'Escape'){
            titleEl.textContent = originalText;
            titleEl.blur();
          }
          e.stopPropagation();
        });
        
        setTimeout(() => {
          document.addEventListener('click', handleClickOutside);
        }, 10);
      }
    }

    function generateNodeTitle(kind, meta) {
      
      
      if (meta && meta.platform === 'twitter') {
        return 'X (Twitter) Post';
      }
    if (meta && meta.platform === 'instagram') {
        if (meta.type === 'p') return 'Instagram Post';
        if (meta.type === 'tv') return 'Instagram TV';
        return 'Instagram Reel';
      }
    if(kind === 'youtube' && meta && meta.videoId) {
        return meta.isShorts ? 'YouTube Shorts' : 'YouTube Video';
      }
      if(kind === 'map' && meta && meta.start && meta.destination) {
        const shortStart = meta.start.length > 15 ? meta.start.substring(0, 12) + "..." : meta.start;
        const shortDest = meta.destination.length > 15 ? meta.destination.substring(0, 12) + "..." : meta.destination;
        return `${shortStart} → ${shortDest}`;
      }
      if(kind === 'website' && meta && meta.domain) {
        return meta.domain.length > 25 ? meta.domain.substring(0, 22) + "..." : meta.domain;
      }
      if(meta && meta.file && meta.file.name) {
        let name = meta.file.name.replace(/\.[^/.]+$/, "");
        return name.length > 25 ? name.substring(0, 22) + "..." : name;
      }
      
      const kindNames = {
        image: 'Image',
        video: 'Video', 
        pdf: 'Document',
        youtube: 'YouTube Video',
        map: 'Google Map',
        website: 'Website'
      };
      
      return kindNames[kind] || 'Media';
    }

    function createMetadataTextbox(node){
      const meta = node.meta || {};
      const file = meta.file || {};
      const exif = meta.exif || null;
      const wrap = document.createElement('div');
      wrap.className='textbox metadata';
      wrap.contentEditable='false';
      wrap.style.left = (node.w + 16) + 'px';
      wrap.style.top = '0px';

      const kv = (k,v)=> `<div>${k}</div><div>${v ?? '-'}</div>`;
      const fileInfo = `
        <div class="section-title">File info</div>
        <div class="kv">
          ${kv('Name', file.name || '-')}
          ${kv('Type', file.type || '-')}
          ${kv('Size', formatSize(file.size))}
          ${kv('Dimensions', meta.dimensions ? meta.dimensions.w+'×'+meta.dimensions.h : '-')}
        </div>
      `;
      let exifInfo = `<div class="section-title">EXIF info</div>`;
      if(exif){
        exifInfo += `<div class="kv">
          ${kv('Camera', [exif.Make, exif.Model].filter(Boolean).join(' ') || '-')}
          ${kv('Lens', exif.LensModel || '-')}
          ${kv('Focal', exif.FocalLength ? exif.FocalLength+'mm' : '-')}
          ${kv('Exposure', exif.ExposureTime ? exif.ExposureTime+'s' : '-')}
          ${kv('Aperture', exif.FNumber ? 'f/'+exif.FNumber : '-')}
          ${kv('ISO', exif.ISO || '-')}
          ${kv('Taken', exif.DateTimeOriginal || '-')}
        </div>`;
      }else{
        exifInfo += `<div class="kv"><div>EXIF</div><div>No EXIF data found</div></div>`;
      }
      wrap.innerHTML = fileInfo + exifInfo;

      const rh = document.createElement('div'); 
      rh.className='tb-resizer'; 
      wrap.appendChild(rh);
      rh.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        const start = {x:e.clientX, y:e.clientY, w:wrap.offsetWidth, h:wrap.offsetHeight};
        function mm(ev){
          const dx = (ev.clientX-start.x)/state.zoom;
          const dy = (ev.clientY-start.y)/state.zoom;
          const w = Math.max(240, start.w + dx), h = Math.max(140, start.h + dy);
          wrap.style.width = w+'px'; wrap.style.height = h+'px';
        }
        function up(){ 
          window.removeEventListener('mousemove', mm); 
          window.removeEventListener('mouseup', up); 
        }
        window.addEventListener('mousemove', mm); 
        window.addEventListener('mouseup', up);
      });

      node.el.appendChild(wrap);
      return wrap;
    }

    function formatSize(bytes){
      if(!bytes && bytes!==0) return '-';
      const kb = bytes/1024, mb = kb/1024;
      return mb>=1 ? mb.toFixed(2)+' MB' : kb.toFixed(1)+' KB';
    }

    function createGroup(at){
      const id = 'g'+(state.nextId++);
      const g = { id, x: at.x, y: at.y, w: 420, h: 280, color:'#3b82f6', title:'Group '+id };
      state.groups.push(g);
      const el = document.createElement('div'); 
      el.className='group'; 
      el.dataset.id=id;
      el.style.left=g.x+'px'; 
      el.style.top=g.y+'px'; 
      el.style.width=g.w+'px'; 
      el.style.height=g.h+'px';
      el.style.borderColor = g.color;
      const title = document.createElement('div'); 
      title.className='title'; 
      title.textContent=g.title; 
      el.appendChild(title);
      const res = document.createElement('div'); 
      res.className='resizer'; 
      el.appendChild(res);
      
      setupTitleRename(title, g);
      
      board.appendChild(el);
      g.el = el;
      enableGroupInteractions(g);
      return g;
    }

    function enableNodeInteractions(node){
      const el = node.el;
      el.addEventListener('mousedown', (e)=>{
        if(e.button!==0) return;
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) toggleSelect(node.id); else selectId(node.id);
        if (node.locked || node.el.dataset.locked === '1') {
          startPanning(e);
        } else {
          startDragSelection(e);
        }
        e.stopPropagation();
      });
    }

    function enableGroupInteractions(g){
      const el = g.el;
      el.addEventListener('mousedown', (e)=>{
        if(e.button!==0) return;
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        const __locked = (g.locked===true) || (g.el && (g.el.dataset.locked==='1' || g.el.classList.contains('locked')));
        if (__locked){ startPanning(e); e.stopPropagation(); return; }
        if(additive) toggleSelect(g.id); else selectId(g.id);
        startDragSelection(e);
        e.stopPropagation();
      });
      
      const res = el.querySelector('.resizer');
      res.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        const start = {x:e.clientX, y:e.clientY, w:g.w, h:g.h};
        function mm(ev){
          const dx = (ev.clientX-start.x)/state.zoom;
          const dy = (ev.clientY-start.y)/state.zoom;
          g.w = Math.max(200, start.w + dx); 
          g.h = Math.max(160, start.h + dy);
          el.style.width = g.w+'px'; 
          el.style.height = g.h+'px';
        }
        function up(){ 
          window.removeEventListener('mousemove', mm); 
          window.removeEventListener('mouseup', up); 
        }
        window.addEventListener('mousemove', mm); 
        window.addEventListener('mouseup', up);
      });
    }

    function startDragSelection(e){
  const start = { x: e.clientX, y: e.clientY };
  const selected = Array.from(state.selection);
  const startRects = {};

  // Helper: robust checklist getter (works whether you have getChecklistById or just an array)
  const _getChecklistById = (id) => {
    if (typeof getChecklistById === 'function') return getChecklistById(id);
    const list = (window.checklistNodes || window.checklists || []);
    return Array.isArray(list) ? list.find(c => c && c.id === id) : null;
  };

  // Capture starting positions for all selected items (nodes, groups, textboxes, checklists)
  selected.forEach(sid => {
    const n = getNodeById(sid);
    const g = getGroupById(sid);
    const t = getTextboxById(sid);
    const c = _getChecklistById(sid);

    if (n) startRects[sid] = { x: n.x, y: n.y, type: 'node' };
    if (g) startRects[sid] = { x: g.x, y: g.y, type: 'group' };
    if (t) {
      const el = t.element || t.el || t;
      startRects[sid] = { 
        x: parseFloat(el.style.left) || 0, 
        y: parseFloat(el.style.top)  || 0, 
        type: 'textbox' 
      };
    }
    if (c) {
      // Prefer model x/y if present, else fall back to DOM style
      const cel = c.element || c.el || c;
      const cx = Number.isFinite(c.x) ? c.x : (parseFloat(cel?.style?.left) || 0);
      const cy = Number.isFinite(c.y) ? c.y : (parseFloat(cel?.style?.top)  || 0);
      startRects[sid] = { x: cx, y: cy, type: 'check' };
    }
  });

  function mm(ev){
    const dx = (ev.clientX - start.x) / state.zoom;
    const dy = (ev.clientY - start.y) / state.zoom;

    selected.forEach(sid => {
      const n = getNodeById(sid); 
      const g = getGroupById(sid);
      const t = getTextboxById(sid);
      const c = _getChecklistById(sid);

      if (n && startRects[sid]) {
        const __locked = (n.locked === true) || (n.el && (n.el.dataset.locked === '1' || n.el.classList.contains('locked')));
        if (!__locked) {
          n.x = startRects[sid].x + dx;
          n.y = startRects[sid].y + dy;
          if (n.el) {
            n.el.style.left = n.x + 'px';
            n.el.style.top  = n.y + 'px';
          }
        }
      }

      if (g && startRects[sid]) {
        const __locked = (g.locked === true) || (g.el && (g.el.dataset.locked === '1' || g.el.classList.contains('locked')));
        if (!__locked) {
          g.x = startRects[sid].x + dx;
          g.y = startRects[sid].y + dy;
          if (g.el) {
            g.el.style.left = g.x + 'px';
            g.el.style.top  = g.y + 'px';
          }
        }
      }

      if (t && startRects[sid]) {
        const __el = t.element || t.el || t;
        const __locked = __el && (__el.dataset.locked === '1' || __el.classList.contains('locked'));
        if (!__locked) {
          const newX = startRects[sid].x + dx;
          const newY = startRects[sid].y + dy;
          __el.style.left = newX + 'px';
          __el.style.top  = newY + 'px';
        }
      }

      // ✅ NEW: move checklists along with the selection
      if (c && startRects[sid]) {
        const cel = c.element || c.el || c;
        const __locked = cel && (cel.dataset?.locked === '1' || cel.classList?.contains('locked') || c.locked === true);
        if (!__locked) {
          const newX = startRects[sid].x + dx;
          const newY = startRects[sid].y + dy;
          // Update model (if used)
          c.x = newX;
          c.y = newY;
          // Update DOM
          if (cel && cel.style) {
            cel.style.left = newX + 'px';
            cel.style.top  = newY + 'px';
          }
        }
      }
    });

    // If your app has a wire/edge redraw, call it here safely:
    if (typeof refreshWires === 'function') refreshWires();
    else if (typeof redrawWires === 'function') redrawWires();
    else if (typeof scheduleRender === 'function') scheduleRender();
  }

  function up(){
    window.removeEventListener('mousemove', mm);
    // Optional: commit history / snap / persist after drag ends
    if (typeof onDragSelectionEnd === 'function') onDragSelectionEnd();
  }

  window.addEventListener('mousemove', mm);
  window.addEventListener('mouseup', up, { once: true });
}

    function beginMarquee(e){
      clearSelection();
      const start = screenToWorld(e.clientX, e.clientY);
      const rectEl = document.createElement('div'); 
      rectEl.className='marquee'; 
      board.appendChild(rectEl);
      
      
function mm(ev){
  const cur = screenToWorld(ev.clientX, ev.clientY);
  const x = Math.min(start.x, cur.x), y = Math.min(start.y, cur.y);
  const w = Math.abs(cur.x - start.x), h = Math.abs(cur.y - start.y);
  rectEl.style.left = x + 'px'; rectEl.style.top = y + 'px';
  rectEl.style.width = w + 'px'; rectEl.style.height = h + 'px';
  clearSelection();

  // Nodes
  if (Array.isArray(state.nodes)) {
    state.nodes.forEach(n => {
      if (intersects({x,y,w,h}, n)) selectId(n.id, true);
    });
  }

  // Checklists
  if (Array.isArray(window.checklistNodes)) {
    window.checklistNodes.forEach(c => {
      const el = c && c.element;
      if (!el) return;
      const cx = typeof c.x === 'number' ? c.x : parseFloat(el.style.left) || 0;
      const cy = typeof c.y === 'number' ? c.y : parseFloat(el.style.top) || 0;
      const cw = el.offsetWidth || parseFloat(el.style.width) || 0;
      const ch = el.offsetHeight || parseFloat(el.style.height) || 0;
      if (intersects({x,y,w,h}, {x:cx, y:cy, w:cw, h:ch})) selectId(c.id, true);
    });
  }

  // Groups
  if (Array.isArray(state.groups)) {
    state.groups.forEach(g => {
      if (intersects({x,y,w,h}, {x:g.x, y:g.y, w:g.w, h:g.h})) selectId(g.id, true);
    });
  }

  // Textboxes
  if (Array.isArray(state.textboxes)) {
    state.textboxes.forEach(t => {
      const el = t && t.element;
      if (!el) return;
      const tx = parseFloat(el.style.left) || 0;
      const ty = parseFloat(el.style.top) || 0;
      const tw = el.offsetWidth || parseFloat(el.style.width) || 0;
      const th = el.offsetHeight || parseFloat(el.style.height) || 0;
      if (intersects({x,y,w,h}, {x:tx, y:ty, w:tw, h:th})) selectId(t.id, true);
    });
  }
}
function up(){
        rectEl.remove();
        window.removeEventListener('mousemove', mm);
        window.removeEventListener('mouseup', up);
      }
      window.addEventListener('mousemove', mm);
      window.addEventListener('mouseup', up);
    }

    // Helper functions
    function screenToWorld(sx, sy){
      const rect = viewport.getBoundingClientRect();
      const x = (sx - rect.left - state.origin.x) / state.zoom;
      const y = (sy - rect.top - state.origin.y) / state.zoom;
      return {x,y};
    }
    
    function intersects(a,b){ 
      return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.h+a.y > b.y; 
    }
    
    function clearSelection(){ 
      state.selection.forEach(id=>{
        const el = getElement(id);
        if(el) el.classList.remove('selected');
      }); 
      state.selection.clear(); 
    }
    
    function selectId(id, additive=false){ 
      if(!additive) clearSelection(); 
      state.selection.add(id); 
      const el = getElement(id);
      if(el) el.classList.add('selected');
    }
    
    function toggleSelect(id){ 
      const el = getElement(id);
      if(state.selection.has(id)){ 
        state.selection.delete(id); 
        if(el) el.classList.remove('selected'); 
      } else { 
        state.selection.add(id); 
        if(el) el.classList.add('selected'); 
      } 
    }
    
    function getElement(id){ return document.querySelector(`[data-id="${id}"]`); }
    function getNodeById(id){ return state.nodes.find(n=>n.id===id); }
    function getGroupById(id){ return state.groups.find(g=>g.id===id); }
    function getTextboxById(id){ return state.textboxes.find(t=>t.id===id); }
    function getTextboxByElement(element){ return state.textboxes.find(t=>t.element===element); }
    function getIdForEl(el){
  if (!el) return null;
  // If this element has the id itself
  if (el.dataset && el.dataset.id) return el.dataset.id;
  // Otherwise, walk up to the nearest node/textbox/checknode shell
  const host = el.closest?.('.node, .textbox, .checknode, .group, .checklist');
  return (host && host.dataset && host.dataset.id) ? host.dataset.id : null;
}

    function deleteNode(node){ 
      node.el.remove(); 
      state.nodes = state.nodes.filter(n=>n!==node); 
      state.selection.delete(node.id); 
    }
    
    function duplicateNode(node){ 
      const at = {x: node.x + 20, y: node.y + 20}; 
      createNode(node.kind, node.assetUrl, {w: node.w, h: node.h}, at, node.meta); 
    }

    // File handling
    function handleFiles(fileList, atPos){
      console.log('Handling files:', fileList.length);
      if(!fileList || !fileList.length) return;
      let pos = atPos;
      if(!pos){
        const rect = viewport.getBoundingClientRect();
        pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      }
      const offsetStep = 24;
      let idx = 0;
      Array.from(fileList).forEach(async (f)=>{
        const url = URL.createObjectURL(f);
        const kind = fileKindFromMime(f.type);
        let size = {w:360, h:240};
        
        if(kind==='video'){ size = {w:480, h:270}; }
        if(kind==='pdf'){ size = {w:420, h:300}; }

        const at = {x: pos.x - size.w/2 + (idx%5)*offsetStep, y: pos.y - size.h/2 + Math.floor(idx/5)*offsetStep};

        let extraMeta = { file: { name: f.name, type: f.type, size: f.size }, dimensions: null, exif: null };
        
        if(kind==='image'){
          await new Promise((resolve)=>{
            const img = new Image();
            img.onload = ()=>{ 
              const naturalW = img.naturalWidth;
              const naturalH = img.naturalHeight;
              extraMeta.dimensions = {w: naturalW, h: naturalH};
              size = calculateOptimalImageSize(naturalW, naturalH);
              at.x = pos.x - size.w/2 + (idx%5)*offsetStep;
              at.y = pos.y - size.h/2 + Math.floor(idx/5)*offsetStep;
              resolve(); 
            };
            img.onerror = ()=> resolve();
            img.src = url;
          });
        }

        createNode(kind, url, size, at, extraMeta);
        idx++;
      });
    }

    function calculateOptimalImageSize(naturalWidth, naturalHeight) {
      const maxDisplayWidth = 800;
      const maxDisplayHeight = 600;
      const minDisplayWidth = 160;
      const minDisplayHeight = 120;
      
      let displayWidth = naturalWidth;
      let displayHeight = naturalHeight;
      
      if (naturalWidth > maxDisplayWidth || naturalHeight > maxDisplayHeight) {
        const widthRatio = maxDisplayWidth / naturalWidth;
        const heightRatio = maxDisplayHeight / naturalHeight;
        const scale = Math.min(widthRatio, heightRatio);
        
        displayWidth = Math.round(naturalWidth * scale);
        displayHeight = Math.round(naturalHeight * scale);
      }
      
      if (naturalWidth < minDisplayWidth && naturalHeight < minDisplayHeight) {
        const widthRatio = minDisplayWidth / naturalWidth;
        const heightRatio = minDisplayHeight / naturalHeight;
        const scale = Math.min(widthRatio, heightRatio, 3);
        
        displayWidth = Math.round(naturalWidth * scale);
        displayHeight = Math.round(naturalHeight * scale);
      }
      
      displayWidth = Math.max(displayWidth, minDisplayWidth);
      displayHeight = Math.max(displayHeight, minDisplayHeight);
      
      return { w: displayWidth, h: displayHeight };
    }

    function fileKindFromMime(mime){
      if(mime.startsWith('image/')) return 'image';
      if(mime.startsWith('video/')) return 'video';
      if(mime==='application/pdf') return 'pdf';
      return 'image';
    }

    // Fixed Save/Load functions with proper textbox state management
    

function saveBoard(){
  console.log('Saving board.');
  const name = prompt('Enter a name for this board:', `Board_${new Date().toLocaleDateString()}`);
  if(!name) return;

  Promise.all([ exportBoardDataWithFiles(), captureBoardSnapshot() ])
    .then(([boardData, snap]) => {
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      savedBoards[name] = {
        data: boardData,
        snapshot: snap,
        timestamp: new Date().toISOString(),
        name
      };
      localStorage.setItem('moodboards', JSON.stringify(savedBoards));
      updateSavedBoardsList();
      alert(`Board "${name}" saved successfully with all file data!`);
    }).catch(error => {
      console.error('Save error:', error);
      alert('Error saving board: ' + error.message);
    });
}


    function exportBoard(){
  console.log('Exporting board...');
  const btn = document.querySelector('#btnExport');
  const originalText = btn ? btn.textContent : null;
  if(btn) btn.textContent = 'Exporting...';

  Promise.all([ exportBoardDataWithFiles(), captureBoardSnapshot() ])
    .then(([boardData, snap]) => {
      const dataStr = JSON.stringify(boardData, null, 2);
      downloadTextAs(`moodboard_export_${new Date().toISOString().split('T')[0]}.json`, dataStr);
      const name = boardData?.name || `Export_${new Date().toLocaleDateString()}`;
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      savedBoards[name] = {
        data: boardData,
        snapshot: snap,
        timestamp: new Date().toISOString(),
        name
      };
      localStorage.setItem('moodboards', JSON.stringify(savedBoards));
      updateSavedBoardsList();
      if(btn) btn.textContent = originalText;
      alert('Board exported successfully with all file data! Check your downloads folder.');
    })
    .catch(error => {
      console.error('Export error:', error);
      if(btn) btn.textContent = originalText;
      alert('Error exporting board: ' + error.message);
    });
}


    function importBoard(event){
      console.log('Importing board...');
      const file = event.target.files[0];
      if(!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const boardData = JSON.parse(e.target.result);
          loadBoardData(boardData);
          alert('Board imported successfully with all file data restored!');
        } catch (error) {
          console.error('Import error:', error);
          alert('Error importing board: Invalid JSON file');
        }
      };
      reader.readAsText(file);
      
      event.target.value = '';
    }
// === Rich Text Sanitize Helper (global) ===
function sanitizeHtml(inputHtml){
  try{
    const tmp = document.createElement('div');
    tmp.innerHTML = inputHtml || '';
    const allowTags = new Set(['SPAN','BR']);
    (function walk(node){
      const kids = Array.from(node.childNodes);
      for(const child of kids){
        if(child.nodeType === Node.ELEMENT_NODE){
          if(!allowTags.has(child.tagName)){
            while(child.firstChild){ node.insertBefore(child.firstChild, child); }
            node.removeChild(child);
            continue;
          }
          if(child.hasAttribute('style')){
            const st = child.getAttribute('style') || '';
            const m = /font-size\s*:\s*([^;]+);?/i.exec(st);
            child.setAttribute('style', m ? ('font-size:'+m[1]) : '');
            if(!m) child.removeAttribute('style');
          }
          walk(child);
        } else if (child.nodeType === Node.COMMENT_NODE){
          node.removeChild(child);
        }
      }
    })(tmp);
    return tmp.innerHTML;
  }catch(_e){ return ''; }
}

// === End sanitize ===
async function exportBoardDataWithFiles() {
  const processedNodes = await Promise.all((state.nodes || []).map(async (node) => {
    const processedNode = { ...node };
    delete processedNode.el;
    delete processedNode.metaTextbox;

    const url = String(node.assetUrl || '');

    // Defaults so downstream code isn't dealing with "undefined"
    processedNode.isFileNode = processedNode.isFileNode ?? false;
    processedNode.hasBase64Data = false;

    if (url.startsWith('blob:')) {
      try {
        const base64Data = await blobUrlToBase64(url);
        processedNode.assetUrl = base64Data;
        processedNode.isFileNode = true;
        processedNode.hasBase64Data = true;
      } catch (error) {
        console.error('Error converting file to base64:', error);
        processedNode.assetUrl = '[FILE_CONVERSION_ERROR]';
        processedNode.isFileNode = true;
        processedNode.hasBase64Data = false;
      }
    } else if (url.startsWith('data:')) {
      // Already a data URL — keep as-is and mark as base64
      processedNode.hasBase64Data = true;
    }

    return processedNode;
  }));

  // ...return your full payload that includes processedNodes

  
// Textboxes
  // Lightweight RGBA parser for export scope
  function __parseRGBA(str){
    const m = String(str||'').match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/i);
    if(!m) return {r:255,g:255,b:255,a:1};
    return { r:+m[1], g:+m[2], b:+m[3], a:(m[4]!==undefined? Math.max(0,Math.min(1,parseFloat(m[4]))) : 1) };
  }

  const processedTextboxes = (state.textboxes || []).map(textbox => {
    const el = textbox.element;
    let content = '';
    let hasActualContent = false;
    if (!textbox.hasPlaceholder && textbox.element.textContent.trim() !== '') {
      content = el.innerHTML;
      hasActualContent = true;
    }

  // capture inline or computed styles
  const cs = getComputedStyle(el);
  const style = {
    background: el.style.background || cs.backgroundColor || '',
    borderColor: el.style.borderColor || cs.borderColor || '',
    color: el.style.color || cs.color || ''
  };

    
    // derive background alpha: prefer dataset.alpha, else parse from inline/computed background
    let __bgSeed = el.style.background || el.style.backgroundColor || cs.backgroundColor || '';
    let __bgA = (el.dataset && el.dataset.alpha != null && !isNaN(parseFloat(el.dataset.alpha))) ? parseFloat(el.dataset.alpha) : __parseRGBA(__bgSeed).a;
return {
      id: textbox.id,
      content,
      hasPlaceholder: textbox.hasPlaceholder,
      hasActualContent,
      left: el.style.left,
      top: el.style.top,
      width: el.style.width,
      height: el.style.height,
      bgAlpha: __bgA,
      style
    };
  });

  // Groups
  const processedGroups = (state.groups || []).map(group => {
    const g = { ...group };
    delete g.el;
    return g;
  });

  
  // Timelines
  const processedTimelines = (state.timelines || []).map(function(tl){
    // Guard element references
    var el = (tl && tl.el) || document.querySelector('.timeline[data-id="'+(tl && tl.id || '')+'"]') || null;
    var cs = el ? getComputedStyle(el) : null;
    var line = (tl && tl.line) || (el ? el.querySelector('.timeline-line') : null);
    var ls = line ? getComputedStyle(line) : null;
    var firstTsEl = (tl && tl.timestamps && tl.timestamps[0] && tl.timestamps[0].el) ? tl.timestamps[0].el : null;

    function _num(v,d){ v = parseFloat(v); return isFinite(v)?v:(d||0); }

    return {
      id: (tl && tl.id) || (el && el.dataset && el.dataset.id) || null,
      x: _num(tl && tl.x != null ? tl.x : (el && el.style && el.style.left)),
      y: _num(tl && tl.y != null ? tl.y : (el && el.style && el.style.top)),
      w: _num(tl && tl.w != null ? tl.w : (el && el.style && el.style.width)),
      h: _num(tl && tl.h != null ? tl.h : (el && el.style && el.style.height)),
      direction: (tl && tl.direction) || ((el && el.classList && el.classList.contains('vertical')) ? 'v' : 'h'),
      stroke: (tl && tl.stroke) || (cs ? cs.color : ''),
      strokeWidth: _num(
        (tl && tl.strokeWidth != null) ? tl.strokeWidth :
        (cs ? (( (tl && tl.direction) === 'h') ? cs.height : cs.width) : 0)
      ),
      fill: (tl && tl.fill) || (ls ? ls.backgroundColor : ''),
      border: (tl && tl.border) || (cs ? cs.borderColor : ''),
      pattern: (tl && tl.pattern) || (cs ? cs.borderStyle : 'solid'),
      markRadius: (typeof (tl && tl.markRadius) === 'number') ? tl.markRadius : 12,
      markShape: (tl && tl.markShape) || 'circle',
      markFill: (tl && tl.markFill) || (firstTsEl ? getComputedStyle(firstTsEl).backgroundColor : ''),
      timestamps: ((tl && tl.timestamps) || []).map(function(m){
        var mel = (m && m.el) || null;
        return {
          x: _num(m && m.x != null ? m.x : (mel && mel.style && mel.style.left)),
          y: _num(m && m.y != null ? m.y : (mel && mel.style && mel.style.top)),
          size: _num(m && m.size != null ? m.size : (mel && mel.offsetWidth)) || 24,
          linkedGroupId: (m && m.linkedGroupId) || (mel && mel.dataset && mel.dataset.linkedGroupId) || null
        };
      })
    };
  });

  // --- Checklists (robust) ---
const processedChecklists = (()=>{
  try{
    // Both names are used across versions; prefer the richer one if present
    const list = (window.checklistNodes || window.checklists || []);
    if (!Array.isArray(list)) return [];

    function numAny(v, fb){
      const n = (typeof v === 'number') ? v : parseFloat(v);
      return Number.isFinite(n) ? n : (Number.isFinite(fb) ? fb : 0);
    }

    return list.filter(Boolean).map((ck)=>{
      // DOM element + text element
      const el = ck.element || document.querySelector(`.checknode[data-id="${ck.id}"]`) || null;
      const textEl = el ? el.querySelector('.checktext') : null;
      const cs = el ? getComputedStyle(el) : null;

      // Geometry (prefer model x/y/w/h, fall back to inline style/offsets)
      const x = Number.isFinite(ck.x) ? ck.x : numAny(el && el.style && el.style.left, 0);
      const y = Number.isFinite(ck.y) ? ck.y : numAny(el && el.style && el.style.top,  0);
      const w = Number.isFinite(ck.w) ? ck.w :
                numAny(el && el.style && el.style.width,  el ? el.offsetWidth  : 0);
      const h = Number.isFinite(ck.h) ? ck.h :
                numAny(el && el.style && el.style.height, el ? el.offsetHeight : 0);

      // Content (preserve HTML if you have it; sanitize if helper exists)
      const htmlRaw = (ck.html != null) ? ck.html : (textEl ? textEl.innerHTML : '');
      const textHtml = (typeof sanitizeHtml === 'function') ? sanitizeHtml(htmlRaw) : htmlRaw;
      const textPlain = (ck.text != null) ? ck.text : (textEl ? textEl.textContent : '');

      // Styles
      const bg     = ck.bg     || (cs ? cs.backgroundColor : '');
      const border = ck.border || (cs ? cs.borderColor     : '');
      const color  = ck.color  || (cs ? cs.color           : '');
      const fontSize = ck.fontSize || (textEl ? getComputedStyle(textEl).fontSize : '');
      const tcs = textEl ? getComputedStyle(textEl) : null;

      return {
        id: ck.id ?? null,
        x, y, w, h,
        width: w,
        height: h,
        text: textPlain,
        textHtml,
        checked: !!ck.checked,
        bg, border, color, fontSize,
        textStyle: {
          fontFamily: tcs ? tcs.fontFamily : '',
          fontWeight: tcs ? tcs.fontWeight : '',
          lineHeight: tcs ? tcs.lineHeight : '',
          letterSpacing: tcs ? tcs.letterSpacing : '',
          textAlign: tcs ? tcs.textAlign : ''
        }
      };
    });
  }catch(_e){
    // Fail-safe: never break export even if something unexpected happens
    return [];
  }
})();

  // Wires (endpoints + control points)
  const processedWires = (state.wires || []).map(w => ({
    fromId: getIdForEl(w.fromEl),
    toId:   getIdForEl(w.toEl),
    c1: { x: (w.c1 && w.c1.x) || 0, y: (w.c1 && w.c1.y) || 0 },
    c2: { x: (w.c2 && w.c2.x) || 0, y: (w.c2 && w.c2.y) || 0 }
  })).filter(w => w.fromId && w.toId);

  return  {
    version: '4.8',
    timestamp: new Date().toISOString(),
    hasBase64Files: true,
    viewport: {
      zoom: state.zoom,
      origin: state.origin
    },
    nodes: processedNodes,
    groups: processedGroups,
    textboxes: processedTextboxes,
    checklists: processedChecklists,
    wires: processedWires,
    nextId: state.nextId
  };
}



    function blobUrlToBase64(blobUrl) {
      return new Promise((resolve, reject) => {
        fetch(blobUrl)
          .then(response => response.blob())
          .then(blob => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          })
          .catch(reject);
      });
    }

    function base64ToBlob(base64Data) {
      const parts = base64Data.split(',');
      const mimeMatch = parts[0].match(/:(.*?);/);
      const mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
      const byteString = atob(parts[1]);
      const byteNumbers = new Array(byteString.length);
      
      for (let i = 0; i < byteString.length; i++) {
        byteNumbers[i] = byteString.charCodeAt(i);
      }
      
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], {type: mime});
    }

    // Fixed loadBoardData with proper textbox restoration
    async function loadBoardData(boardData) {
      clearBoard();
      
      if(boardData.viewport) {
        state.zoom = boardData.viewport.zoom || 1;
        state.origin = boardData.viewport.origin || {x: 0, y: 0};
      }
      // Restore timelines
      if (Array.isArray(boardData.timelines)){
        boardData.timelines.forEach(tld => {
          try{
            const tl = window.createTimeline({
              direction: (tld.direction==='v' ? 'v' : 'h'),
              at:{ x: tld.x||0, y: tld.y||0 },
              length: (tld.direction==='h' ? (tld.w||300) : (tld.h||300)),
              thickness: (tld.direction==='h' ? (tld.h||6)   : (tld.w||6)),
              suppressDefaults: true
            });
            if (typeof tld.markRadius==='number') tl.markRadius = tld.markRadius;
            if (tld.markShape) { tl.markShape = tld.markShape; if (typeof applyMarkShapeToAll==='function') applyMarkShapeToAll(tl); }
if (typeof tld.strokeWidth==='number'){
              tl.strokeWidth = tld.strokeWidth;
              if (tl.direction==='h'){ tl.h = tld.strokeWidth; tl.el.style.height = tld.strokeWidth+'px'; }
              else { tl.w = tld.strokeWidth; tl.el.style.width = tld.strokeWidth+'px'; }
            }
            if (tld.stroke){ tl.stroke = tld.stroke; tl.el.style.color = tld.stroke; }
            if (tld.fill){ tl.fill = tld.fill; if (tl.line) tl.line.style.background = tld.fill; }            if (tld.border){ tl.border = tld.border; tl.el.style.borderColor = tld.border; }

            
            // Reflect styles on timeline object so the style panel reads correct values
            try {
              tl.stroke = tld.stroke || tl.stroke;
              tl.strokeWidth = (typeof tld.strokeWidth==='number') ? tld.strokeWidth : tl.strokeWidth;
              tl.fill = tld.fill || tl.fill;
              tl.border = tld.border || tl.border;
              tl.markRadius = (typeof tld.markRadius==='number') ? tld.markRadius : tl.markRadius;
              tl.markShape = tld.markShape || tl.markShape;
            } catch(_){}
    // Apply border pattern if present
            if (tld.pattern){
              if (tld.pattern === 'dashed'){
                try{
                  tl.el.style.borderStyle = 'dashed';
                  tl.el.style.borderWidth = '1px';
                  tl.el.style.borderColor = tl.stroke || tld.border || '#111';
                }catch(_){}
              } else {
                try{
                  tl.el.style.borderStyle = 'solid';
                  // Keep width minimal unless explicitly styled, avoid visual shift
                  tl.el.style.borderWidth = '0px';
                }catch(_){}
              }
              tl.pattern = tld.pattern;

            // Apply timestamp fill (timeline-level)
            if (tld.markFill){
              try { tl.markFill = tld.markFill; } catch(_){}
              try { if (tl.el && tl.el.style && tl.el.style.setProperty) tl.el.style.setProperty('--tl-mark-fill', tld.markFill); } catch(_){}
            }
            }
                // Add timestamps
            if (Array.isArray(tld.timestamps)){
              tld.timestamps.forEach(mo => {
                const pos = (tl.direction==='h') ? (mo.x||0) : (mo.y||0);
                const mark = window.addTimelineTimestamp(tl, pos);
                if (mo.size){ mark.style.width = mo.size+'px'; mark.style.height = mo.size+'px'; }
                // Recenter based on axis
                if (tl.direction==='h'){
                  mark.style.top = (tl.h/2 - (mark.offsetHeight||24)/2) + 'px';
                }else{
                  mark.style.left = (tl.w/2 - (mark.offsetWidth||24)/2) + 'px';
                }
                // Restore link
                try{
                  const obj = (tl.timestamps||[]).find(o=>o && o.el===mark);
                  if (obj) obj.linkedGroupId = mo.linkedGroupId || null;
                }catch(_){}
              
            // After creating timestamps, apply timeline-level mark fill if present
            try { if (tld.markFill && typeof window.applyTimelineMarkFill==='function') window.applyTimelineMarkFill(tl, tld.markFill); } catch(_){}
        });
            // If we have a timeline-level markFill, apply to created marks
            try {
              if (tld.markFill && tl.timestamps){
                tl.timestamps.forEach(function(m){ if (m && m.el) m.el.style.background = tld.markFill; });
              }
            } catch(_){}

            }
          }catch(err){ console.error('Timeline import error', err); }
        });
      }

        applyTransform();
      
      
      state.nextId = boardData.nextId || 1;
      
      // Restore groups
      if(boardData.groups) {
        boardData.groups.forEach(groupData => {
          const group = createGroup({x: groupData.x, y: groupData.y});
          Object.assign(group, groupData);
          group.el.style.width = group.w + 'px';
          group.el.style.height = group.h + 'px';
          group.el.style.borderColor = group.color;
          group.el.querySelector('.title').textContent = group.title;
          if (typeof groupData.locked !== 'undefined'){
            group.locked = !!groupData.locked;
            group.el.classList.toggle('locked', group.locked);
            group.el.dataset.locked = group.locked ? '1' : '0';
            group.el.style.cursor = group.locked ? 'default' : 'grab';
          }
        });
      }
      
      // Restore nodes with base64 file conversion
      if(boardData.nodes) {
        for(const nodeData of boardData.nodes) {
          let assetUrl = nodeData.assetUrl;
          
          if(nodeData.isFileNode && nodeData.hasBase64Data && nodeData.assetUrl.startsWith('data:')) {
            try {
              const blob = base64ToBlob(nodeData.assetUrl);
              assetUrl = URL.createObjectURL(blob);
            } catch (error) {
              console.error('Error converting base64 to blob:', error);
              console.warn('Skipping file node with conversion error:', nodeData.title);
              continue;
            }
          } else if(nodeData.isFileNode && !nodeData.hasBase64Data) {
            console.warn('Skipping file node with lost data:', nodeData.title);
            continue;
          }
          
          const node = createNode(
            nodeData.kind,
            assetUrl,
            {w: nodeData.w, h: nodeData.h},
            {x: nodeData.x, y: nodeData.y},
            nodeData.meta
          );
          
          
          // Preserve original node id for wiring
          try {
            const savedId = nodeData.id || nodeData.nodeId || nodeData.nid || null;
            if (savedId) {
              const prevId = node.id;
              node.id = savedId;
              if (node.el) node.el.dataset.id = savedId;
            }
          } catch(_e){}node.title = nodeData.title;
          node.el.querySelector('.title').textContent = node.title;
        }
      }
      
      // Fixed textbox restoration with proper state management
      if(boardData.textboxes) {
        boardData.textboxes.forEach(textboxData => {
          const pos = {
            x: parseFloat(textboxData.left) || 0, 
            y: parseFloat(textboxData.top) || 0
          };
          
          // Create new textbox but don't auto-focus it
          const textbox = createFloatingTextbox(pos);
          
          // Restore ID and properties
          textbox.id = textboxData.id;
          textbox.element.dataset.id = textboxData.id;
          
          // Set dimensions
          if (textboxData.width) textbox.element.style.width = textboxData.width;
          if (textboxData.height) textbox.element.style.height = textboxData.height;
          
          // Restore content and placeholder state properly
          if (textboxData.hasActualContent && textboxData.content && textboxData.content.trim() !== '') {
            // Has real content - restore it
            textbox.element.innerHTML = textboxData.content;
            textbox.hasPlaceholder = false;
          } else {
            // Empty or placeholder - ensure placeholder is shown
            setPlaceholderText(textbox);
          }

          
    // Apply saved textbox colors (if present)
if (textboxData.style) {
    const s = textbox.element.style;
    if (textboxData.style.background)  s.background  = textboxData.style.background;
    if (textboxData.style.borderColor) s.borderColor = textboxData.style.borderColor;
    if (textboxData.style.color)       s.color       = textboxData.style.color;
    }

    // If bgAlpha is provided, recompose rgba so the theme cannot override it
    if (typeof textboxData.bgAlpha === 'number') {
      try{
        // get base color from style.background or fallback to computed, strip alpha, then apply bgAlpha
        const cs2 = getComputedStyle(textbox.element);
        const seed = (textboxData.style && (textboxData.style.background || textboxData.style.backgroundColor)) || cs2.backgroundColor || 'rgb(255,255,255)';
        const m = String(seed).match(/rgba?\((\d+),\s*(\d+),\s*(\d+)\s*(?:,\s*([0-9.]+))?\)/i);
        const r = m ? +m[1] : 255, g = m ? +m[2] : 255, b = m ? +m[3] : 255;
        const a = Math.max(0, Math.min(1, textboxData.bgAlpha));
        const rgba = 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(3) + ')';
        s.backgroundColor = rgba;
        s.background = rgba;
        s.backgroundImage = 'none';
        s.backgroundBlendMode = 'normal';
        s.backgroundClip = 'padding-box';
        s.opacity = '1';
        s.filter = '';
        textbox.element.dataset.alpha = String(a);
      }catch(_e){}
    }
          // Ensure proper state
          textbox.isEditing = false;
          textbox.element.blur();
        });
      }
      
      
// Restore checklist nodes
      if(boardData.checklists && window.addChecklistNodeAt) {
        boardData.checklists.forEach(cd => {
          
// Dimensions (support w/h + width/height)
const w = (cd.w != null ? cd.w : (cd.width != null ? parseFloat(cd.width) : null));
const h = (cd.h != null ? cd.h : (cd.height != null ? parseFloat(cd.height) : null));
const x = (cd.x != null ? cd.x : 0);
const y = (cd.y != null ? cd.y : 0);

// Text (plain + html)
const textPlain = (cd.text != null ? cd.text : (cd.textPlain != null ? cd.textPlain : ''));
const textHtml  = (cd.textHtml != null ? cd.textHtml : (cd.html != null ? cd.html : ''));

// Colors and font props
const bg   = (cd.bg   != null ? cd.bg   : '');
const border = (cd.border != null ? cd.border : '');
const color  = (cd.color  != null ? cd.color  : '');
const fontSize = (cd.fontSize != null ? cd.fontSize : '');

// Create checklist at saved coords with size & styles
const el = window.addChecklistNodeAt(x, y, textPlain, !!cd.checked, w, h, {bg, border, color, html: textHtml}, cd.id || null, fontSize);

// Apply style aliases if only width/height string was saved
try{
  if (el && typeof el === 'object') {
    if (cd.width && !w)  el.style.width  = String(cd.width);
    if (cd.height && !h) el.style.height = String(cd.height);
  }
}catch(_){}

// Re-apply inner text HTML & styles
try{
  const textEl = (el && el.querySelector) ? el.querySelector('.checktext') : null;
  if (textEl) {
    if (textHtml) textEl.innerHTML = textHtml;
    if (fontSize) textEl.style.fontSize = fontSize;
    if (color)    textEl.style.color    = color;
    if (cd.textStyle) {
      const ts = cd.textStyle || {};
      if (ts.fontFamily)   textEl.style.fontFamily   = ts.fontFamily;
      if (ts.fontWeight)   textEl.style.fontWeight   = ts.fontWeight;
      if (ts.lineHeight)   textEl.style.lineHeight   = ts.lineHeight;
      if (ts.letterSpacing)textEl.style.letterSpacing= ts.letterSpacing;
      if (ts.textAlign)    textEl.style.textAlign    = ts.textAlign;
    }
  }
}catch(_){}

        });
      }
}

    function clearBoard() {

  try{
    // Remove nodes
    (state.nodes||[]).forEach(n => { try{ n.el && n.el.remove(); }catch(_){}});
    state.nodes = [];

    // Remove groups (including any timezone groups)
    (state.groups||[]).forEach(g => { try{ g.el && g.el.remove(); }catch(_){}});
    state.groups = [];

    // Remove textboxes
    if (Array.isArray(state.textboxes)) {
      state.textboxes.forEach(tb => { try{ (tb.element||tb.el) && (tb.element||tb.el).remove(); }catch(_){} });
      state.textboxes = [];
    }
    if (Array.isArray(window.textboxes)) {
      window.textboxes.forEach(tb => { try{ (tb.element||tb.el) && (tb.element||tb.el).remove(); }catch(_){} });
      window.textboxes.length = 0;
    }

    // Remove checklists
    if (Array.isArray(window.checklistNodes)){
      window.checklistNodes.forEach(ch => { try{ ch.element && ch.element.remove(); }catch(_){} });
      window.checklistNodes.length = 0;
    }

    // Remove timelines (and their marks)
    if (Array.isArray(state.timelines)){
      state.timelines.forEach(tl => { try{ tl.el && tl.el.remove(); }catch(_){} });
      state.timelines = [];
    }

    // Remove wires
    if (Array.isArray(state.wires)){
      state.wires.forEach(w => { try{ w.g && w.g.remove(); }catch(_){} });
      state.wires = [];
    }
    var wiresLayer = document.getElementById('wires');
    if (wiresLayer) wiresLayer.innerHTML = '';

    // Clear selection and reset drag state
    if (typeof clearSelection==='function') clearSelection();
  }catch(e){ console.warn('[clearBoard] error', e); }

}


    function updateSavedBoardsList() {
  const saveList = document.getElementById('saveList');
  const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');

  if (!saveList) return;

  saveList.innerHTML = '';

  const names = Object.keys(savedBoards);
  if (names.length === 0) {
    saveList.innerHTML = '<div style="text-align:center;color:var(--muted);font-size:12px;">No saved boards</div>';
    return;
  }

  names.forEach((name) => {
    const info = savedBoards[name] || {};
    const date = new Date(info.timestamp || Date.now()).toLocaleString();
    const hasFiles = info.data && info.data.hasBase64Files ? ' 📁' : '';
    const thumb = info.snapshot && info.snapshot.thumb;

    const card = document.createElement('div');
    card.className = 'save-card';
    card.innerHTML = `
      ${thumb ? `<img alt="Board snapshot" src="${thumb}">` : `<div style="height:96px;border-radius:8px;background:rgba(255,255,255,.08);display:grid;place-items:center;font-size:12px;color:var(--muted)">No Preview</div>`}
      <div class="meta">
        <div style="font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${name}${hasFiles}</div>
        <div>${date}</div>
      </div>
      <div class="row">
        <button data-act="load" data-name="${name}">Load</button>
        <button data-act="json" data-name="${name}">JSON</button>
        <button data-act="png"  data-name="${name}">PNG</button>
        <button data-act="del"  data-name="${name}" class="danger">Delete</button>
      </div>
    `;
    saveList.appendChild(card);
  });

  saveList.onclick = (e)=>{
    const btn = e.target.closest('button'); if(!btn) return;
    const act = btn.getAttribute('data-act');
    const name = btn.getAttribute('data-name');
    const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
    const info = savedBoards[name]; if(!info) return;

    if (act === 'load') {
      if (confirm(`Load board "${name}"? This will replace your current board.`)) {
        loadBoardData(info.data);
        alert(`Board "${name}" loaded successfully!`);
      }
    } else if (act === 'json') {
      const dataStr = JSON.stringify(info.data || {}, null, 2);
      downloadTextAs(`${name}.json`, dataStr);
    } else if (act === 'png') {
      const full = (info.snapshot && (info.snapshot.full || info.snapshot.thumb));
      if (full) downloadDataUrl(full, `${name}.png`);
      else alert('No PNG available for this item.');
    } else if (act === 'del') {
      if (confirm(`Delete board "${name}"? This cannot be undone.`)) {
        delete savedBoards[name];
        localStorage.setItem('moodboards', JSON.stringify(savedBoards));
        updateSavedBoardsList();
        alert(`Board "${name}" deleted.`);
      }
    }
  };
    }
function loadSavedBoard(name) {
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      const boardInfo = savedBoards[name];
      
      if(!boardInfo) {
        alert('Board not found!');
        return;
      }
      
      if(confirm(`Load board "${name}"? This will replace your current board.`)) {
        loadBoardData(boardInfo.data);
        alert(`Board "${name}" loaded successfully!`);
      }
    }

    function deleteSavedBoard(name) {
      if(confirm(`Delete board "${name}"? This cannot be undone.`)) {
        const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
        delete savedBoards[name];
        localStorage.setItem('moodboards', JSON.stringify(savedBoards));
        updateSavedBoardsList();
        alert(`Board "${name}" deleted.`);
      }
    }

    function loadSavedBoards(){
      console.log('Loading saved boards list...');
      updateSavedBoardsList();
    }

    // Make functions globally available for onclick handlers
    window.loadSavedBoard = loadSavedBoard;
    window.deleteSavedBoard = deleteSavedBoard;

    // Initialize the app
    console.log('About to initialize...');
    init();
  
    // === Shift + Drag to move textboxes (without interfering with typing) ===
    (function enableShiftDragTextboxes(){
      document.addEventListener('mousedown', (e)=>{
        const tb = e.target.closest('.textbox');
        if(!tb) return;
        const locked = tb.dataset.locked==='1' || tb.classList.contains('locked');
        if (locked) { if (e.cancelable) e.preventDefault(); e.stopPropagation(); startPanning(e); return; }
        // Ignore the resize handle, and only act when Shift is held
        if (!e.shiftKey || e.target.classList.contains('tb-resizer')) return;

        // Prevent canvas pan/selection; we'll move the textbox itself
        e.preventDefault();
        e.stopPropagation();

        // World-space helpers
        function screenToWorldLocal(sx, sy){
          try{
            if (typeof screenToWorld === 'function') return screenToWorld(sx, sy);
          }catch(_e){}
          const vp = document.getElementById('viewport');
          const rect = vp.getBoundingClientRect();
          const zoom = (window.state && window.state.zoom) ? window.state.zoom : 1;
          const origin = (window.state && window.state.origin) ? window.state.origin : {x:0,y:0};
          const x = (sx - rect.left - origin.x) / zoom;
          const y = (sy - rect.top  - origin.y) / zoom;
          return {x,y};
        }

        // Establish starting positions in world coords
        const startWorld = screenToWorldLocal(e.clientX, e.clientY);
        const startLeft = parseFloat(tb.style.left) || 0;
        const startTop  = parseFloat(tb.style.top)  || 0;

        // Visual feedback
        const prevCursor = tb.style.cursor;
        tb.style.cursor = 'grabbing';
        tb.classList.add('dragging');

        // Disable text selection while dragging
        const prevUserSelect = document.body.style.userSelect;
        document.body.style.userSelect = 'none';

        function onMove(ev){
          const w = screenToWorldLocal(ev.clientX, ev.clientY);
          const dx = w.x - startWorld.x;
          const dy = w.y - startWorld.y;
          tb.style.left = (startLeft + dx) + 'px';
          tb.style.top  = (startTop  + dy) + 'px';
          // <— add this
          try { if (window.updateAllWires) updateAllWires(); } catch(_){ }
        }
        function onUp(){
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
          tb.style.cursor = prevCursor;
          tb.classList.remove('dragging');
          document.body.style.userSelect = prevUserSelect;
        }
        window.addEventListener('mousemove', onMove, {passive:false});
        window.addEventListener('mouseup', onUp, {passive:false});
      }, true); // capture to beat other handlers
    })();
</script>

<script>

const board =
  document.getElementById('board') ||
  document.querySelector('.board, #canvas, .canvas') ||
  document.body;

  // ---- Helpers: Bezier math ----
  function bezierPoint(a,c1,c2,b,t){
    const mt = 1-t, mt2 = mt*mt, t2 = t*t;
    const x = a.x*mt*mt2 + 3*c1.x*t*mt2 + 3*c2.x*t2*mt + b.x*t*t2;
    const y = a.y*mt*mt2 + 3*c1.y*t*mt2 + 3*c2.y*t2*mt + b.y*t*t2;
    return {x,y};
  }
  function bezierDeriv(a,c1,c2,b,t){
    const mt = 1-t;
    const x = 3*mt*mt*(c1.x - a.x) + 6*mt*t*(c2.x - c1.x) + 3*t*t*(b.x - c2.x);
    const y = 3*mt*mt*(c1.y - a.y) + 6*mt*t*(c2.y - c1.y) + 3*t*t*(b.y - c2.y);
    return {x,y};
  }
  // Solve C1 so that B(t1) = P  (linear in C1)
  function solveC1FromPoint(a,c2,b,t,P){
    const mt = 1-t, mt2 = mt*mt, t2 = t*t;
    const denom = 3*mt2*t || 1e-6;
    return {
      x: (P.x - (a.x*mt*mt2 + 3*c2.x*t2*mt + b.x*t*t2)) / denom,
      y: (P.y - (a.y*mt*mt2 + 3*c2.y*t2*mt + b.y*t*t2)) / denom
    };
  }
  // Solve C2 so that B(t2) = P  (linear in C2)
  function solveC2FromPoint(a,c1,b,t,P){
    const mt = 1-t, mt2 = mt*mt, t2 = t*t;
    const denom = 3*mt*t2 || 1e-6;
    return {
      x: (P.x - (a.x*mt*mt2 + 3*c1.x*t*mt2 + b.x*t*t2)) / denom,
      y: (P.y - (a.y*mt*mt2 + 3*c1.y*t*mt2 + b.y*t*t2)) / denom
    };
  }

  // ---- Wires layer (below nodes) ----
  function ensureWiresLayer(){
    let svg = document.getElementById('wires');
    if (!svg){
      svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.id = 'wires';
      svg.setAttribute('viewBox','0 0 50000 50000');
      svg.setAttribute('width','50000');
      svg.setAttribute('height','50000');
      // insert as FIRST CHILD to ensure it's behind other absolute layers
      board.insertBefore(svg, board.firstChild || null);
    } else if (svg !== board.firstChild){
      // always keep it first
      board.insertBefore(svg, board.firstChild || null);
    }
    return svg;
  }

  // ---- State ----
  window.state = window.state || {};
  state.wires = state.wires || [];
  state.connecting = state.connecting || null;

  function getCenter(el){
    return {
      x: (parseFloat(el.style.left)||0) + el.offsetWidth/2,
      y: (parseFloat(el.style.top)||0)  + el.offsetHeight/2
    };
  }

  // create wire
  function makeWire(fromEl, toEl){
    const svg = ensureWiresLayer();
    const g = document.createElementNS('http://www.w3.org/2000/svg','g'); g.classList.add('wire');
    const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.classList.add('wire-path');

    // on-wire handles (groups with icon + hit + dot)
    function makeHandle(){
      const hg = document.createElementNS('http://www.w3.org/2000/svg','g'); hg.classList.add('wire-handle');
      const hit = document.createElementNS('http://www.w3.org/2000/svg','circle'); hit.setAttribute('class','hit'); hit.setAttribute('r','12');
      const dot = document.createElementNS('http://www.w3.org/2000/svg','circle'); dot.setAttribute('class','dot'); dot.setAttribute('r','4.5');
      const icon = document.createElementNS('http://www.w3.org/2000/svg','path'); icon.setAttribute('class','icon');
      icon.setAttribute('d','M -8 0 Q -4 -6 0 0 T 8 0'); // small S-curve
      hg.appendChild(hit); hg.appendChild(dot); hg.appendChild(icon);
      return hg;
    }
    const h1 = makeHandle(), h2 = makeHandle();

    g.appendChild(path); g.appendChild(h1); g.appendChild(h2);
    svg.appendChild(g);

    const a = getCenter(fromEl);
    const b = toEl ? getCenter(toEl) : a;
    const defaultMag = Math.min(240, Math.max(80, Math.abs(b.x-a.x)*.35));
    const sign = (b.x - a.x) >= 0 ? 1 : -1;

    const wire = {
      fromEl, toEl: toEl || null, g, path, h1, h2,
      c1: { x: a.x + sign*defaultMag, y: a.y },
      c2: { x: b.x - sign*defaultMag, y: b.y },
      tempTarget: null
    };

    // handles only visible after attached
    if (!toEl){ h1.style.display='none'; h2.style.display='none'; }

    // dragging on-wire handles -> solve for C1/C2 at t=⅓,⅔
    function startHandleDrag(which, down){
      down.preventDefault(); down.stopPropagation();
      const t = (which===1) ? 1/3 : 2/3;
      const handle = (which===1) ? h1 : h2;
      handle.classList.add('dragging');

      function move(ev){
        const W = (typeof screenToWorld==='function') ? screenToWorld(ev.clientX, ev.clientY) : {x:ev.clientX,y:ev.clientY};
        const A = getCenter(wire.fromEl);
        const B = wire.toEl ? getCenter(wire.toEl) : (wire.tempTarget || A);
        if (which===1){
          wire.c1 = solveC1FromPoint(A, wire.c2, B, t, W);
        }else{
          wire.c2 = solveC2FromPoint(A, wire.c1, B, t, W);
        }
        updateWire(wire);
      }

      function updateAllWires(){
         (state.wires || []).forEach(w => {
         try { updateWire(w); } catch (e) { /* ignore a broken wire during deletes */ }
        });
      }
      window.updateAllWires = updateAllWires; // used from movers/zoom wrappers

      function up(){
        window.removeEventListener('mousemove', move, true);
        window.removeEventListener('mouseup', up, true);
        handle.classList.remove('dragging');
      }
      window.addEventListener('mousemove', move, true);
      window.addEventListener('mouseup', up, true);
    }
    h1.addEventListener('mousedown', (e)=>startHandleDrag(1,e), true);
    h2.addEventListener('mousedown', (e)=>startHandleDrag(2,e), true);

    state.wires.push(wire);
    updateWire(wire);
    return wire;
  }

  function updateWire(wire){
    // cleanup
    if (!wire.fromEl?.isConnected || (wire.toEl && !wire.toEl.isConnected)){
      try{ wire.g.remove(); }catch(_){}
      state.wires = state.wires.filter(w=>w!==wire);
      return;
    }
    const A = getCenter(wire.fromEl);
    const B = wire.toEl ? getCenter(wire.toEl) : (wire.tempTarget || A);
    const C1 = wire.c1, C2 = wire.c2;

    // path
    wire.path.setAttribute('d', `M ${A.x} ${A.y} C ${C1.x} ${C1.y}, ${C2.x} ${C2.y}, ${B.x} ${B.y}`);

    // handles on-curve at t=1/3 and t=2/3
    const t1 = 1/3, t2 = 2/3;
    const P1 = bezierPoint(A,C1,C2,B,t1), T1 = bezierDeriv(A,C1,C2,B,t1);
    const P2 = bezierPoint(A,C1,C2,B,t2), T2 = bezierDeriv(A,C1,C2,B,t2);
    const a1 = Math.atan2(T1.y,T1.x)*180/Math.PI;
    const a2 = Math.atan2(T2.y,T2.x)*180/Math.PI;

    wire.h1.setAttribute('transform', `translate(${P1.x} ${P1.y}) rotate(${a1})`);
    wire.h2.setAttribute('transform', `translate(${P2.x} ${P2.y}) rotate(${a2})`);
  }

  ;
  state.wires.forEach(function(w){
    try { updateWire(w); } catch(e){}
  });

  // ---- Connection mode (block node actions while connecting) ----
  function startConnectFrom(el){
    ensureWiresLayer();

    const temp = makeWire(el, null);
    temp.g.classList.add('connecting');

    let hoverEl = null;
    function setHover(el2){
      if (hoverEl === el2) return;
      if (hoverEl) hoverEl.classList.remove('connect-hover');
      hoverEl = el2;
      if (hoverEl) hoverEl.classList.add('connect-hover');
    }

    function onMove(e){
      const W = (typeof screenToWorld==='function') ? screenToWorld(e.clientX,e.clientY) : {x:e.clientX,y:e.clientY};
      temp.tempTarget = W;
      updateWire(temp);
      const hit = document.elementFromPoint(e.clientX, e.clientY);
      const cand = hit?.closest && hit.closest('.node, .textbox, .checknode');
      setHover(cand && cand!==el ? cand : null);
    }

    function onDown(e){
      const target = hoverEl;
      setHover(null);

      if (target && target!==el){
        temp.toEl = target;
        temp.h1.style.display=''; temp.h2.style.display='';
        updateWire(temp);
      } else {
        try{ temp.g.remove(); }catch(_){}
        state.wires = state.wires.filter(w=>w!==temp);
      }
      end();
    }

    function end(){
      window.removeEventListener('mousemove', onMove, true);
      window.removeEventListener('mousedown', onDown, true);
      state.connecting = null;
      document.documentElement.classList.remove('connecting');
    }

    state.connecting = { wire: temp, fromEl: el };
    document.documentElement.classList.add('connecting');

    // High-priority listeners
    window.addEventListener('mousemove', onMove, true);
    window.addEventListener('mousedown', onDown, true);
  }
  window.__startConnectFrom = startConnectFrom;

  // Global blocker: while connecting, prevent clicks from triggering node/textbox actions.
  function blockWhileConnecting(e){
    if (!state.connecting) return;
    if (e.target?.closest && e.target.closest('.node, .textbox, .checknode')){
      e.preventDefault();
      e.stopImmediatePropagation();
    }
  }
  ['mousedown','click','mouseup','dblclick'].forEach(type=>{
    document.addEventListener(type, blockWhileConnecting, true); // capture
  });

  // Keep wires fresh on zoom/pan (wrap applyTransform if present)
  if (typeof window.applyTransform === 'function'){
    const __apply = window.applyTransform;
    window.applyTransform = function(...args){
      const r = __apply.apply(this, args);
      try { if (window.updateAllWires) updateAllWires(); } catch(_){ }
      return r;
    };
  }

  // Ensure layer order on first run
  ensureWiresLayer();

</script>

<script>
// ===== Standalone Checklist Node + Board Context Menu =====
(function(){
  // Try to find your board element; fall back to document.body
  // If your board container has a specific ID/class, put it first in the selector list:
  const board = document.querySelector('#board, .board, #canvas, .canvas') || document.body;

  // Keep track of checklist nodes for save/load integration
  const checklistNodes = [];

  // Bring-to-front helper via z-index bump
  let zTop = 2000;
  function bringToFront(el){ el.style.zIndex = ++zTop; }

  // Core: create a draggable checklist node
  function createChecklistNode(x, y, textValue = 'New item', checked = false, opts = {}){
    const id = (opts && opts.id) ? String(opts.id) : 'c' + Date.now() + Math.random().toString(36).substr(2, 9);
    const node = document.createElement('div');
    node.className = 'checknode';
    node.dataset.type = 'checknode';
    node.dataset.id = id;
    node.setAttribute('role', 'group');

    // Drag handle
    const grip = document.createElement('span');
    grip.className = 'drag-handle';
    grip.setAttribute('aria-label', 'Drag checklist');
    grip.setAttribute('role', 'button');

    // Checkbox
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = !!checked;

    // Single-line text (editable)
    const text = document.createElement('div');
    text.className = 'checktext';
    text.contentEditable = 'true';
    if (opts && opts.html) { text.innerHTML = sanitizeHtml(opts.html); } else { text.textContent = textValue; }

    node.appendChild(grip);
    node.appendChild(cb);
    node.appendChild(text);

    // Initial position
    node.style.left = Math.round(x) + 'px';
    node.style.top  = Math.round(y) + 'px';
    bringToFront(node);

// Apply provided dimensions/styles/html if given
try {
  if (opts) {
    const w = opts.w || opts.width;
    const h = opts.h || opts.height;
    if (w) node.style.width = (typeof w === 'number') ? (w + 'px') : String(w);
    if (h) node.style.height = (typeof h === 'number') ? (h + 'px') : String(h);
    if (opts.bg) node.style.backgroundColor = opts.bg;
    if (opts.border) node.style.borderColor = opts.border;
    if (opts.color) node.style.color = opts.color;
    const textEl = node.querySelector('.checktext');
    const fs = opts.fontSize || (opts.text && opts.text.fontSize);
    if (textEl && fs) textEl.style.fontSize = (typeof fs === 'number') ? (fs + 'px') : String(fs);
    if (textEl && opts.html) textEl.innerHTML = sanitizeHtml(opts.html);
  }
} catch(_e){}


    // Create checklist data object
    const checklistData = {
      id: id,
      x: x,
      y: y,
      text: textValue,
      checked: checked,
      element: node
    };
    
    // Add to tracking array
    checklistNodes.push(checklistData);

    // Toggle visual on check (removed strikethrough)
    const syncChecked = ()=> {
      // Update data when checkbox changes
      checklistData.checked = cb.checked;
    };
    cb.addEventListener('change', syncChecked);
    syncChecked();
    
    
// Keep HTML and plain text in sync for per-word styles
const syncHtml = () => {
  const html = sanitizeHtml(text.innerHTML);
  if (html !== checklistData.textHtml) checklistData.textHtml = html;
  checklistData.text = text.innerText || text.textContent || '';
};
const __mo = new MutationObserver(syncHtml);
__mo.observe(text, {subtree:true, childList:true, characterData:true, attributes:true, attributeFilter:['style']});
text.addEventListener('input', syncHtml);
text.addEventListener('blur', syncHtml);
syncHtml();

    // Update data when text changes
    text.addEventListener('input', ()=> {
      checklistData.text = text.textContent;
    });
    text.addEventListener('blur', ()=> {
      checklistData.text = text.textContent;
    });

    // ---- Drag logic (handle-only) ----
    let dragging = false;

    function startDrag(e){
      const locked = node.dataset.locked==='1' || node.classList.contains('locked');
      if (locked) { if (e.cancelable) e.preventDefault(); e.stopPropagation(); startPanning(e); return; }
      e.preventDefault();
      e.stopPropagation(); // Prevent canvas pan/selection
      bringToFront(node);
      dragging = true;
      node.setAttribute('aria-grabbed', 'true');
      // Use world-space coordinates (accounts for zoom + origin)
      const toWorld = (sx, sy) => {
        if (typeof screenToWorld === 'function') return screenToWorld(sx, sy);
        // Fallback (shouldn't be needed in your app)
        const vp = document.getElementById('viewport');
        const rect = vp.getBoundingClientRect();
        const zoom = (typeof state !== 'undefined' && state.zoom) ? state.zoom : 1;
        const origin = (typeof state !== 'undefined' && state.origin) ? state.origin : {x:0,y:0};
        return { x: (sx - rect.left - origin.x) / zoom,
                 y: (sy - rect.top  - origin.y) / zoom };
      };
      const startWorld = toWorld(e.clientX, e.clientY);
      const startLeft  = parseFloat(node.style.left) || 0;
      const startTop   = parseFloat(node.style.top)  || 0;
      // Multiselect: capture start positions for all selected items
      const selectedIds = (typeof state!=='undefined' && state.selection && state.selection.size)
        ? Array.from(state.selection)
        : [id];
      if(selectedIds.indexOf(id)===-1) selectedIds.push(id);
      const startPositions = {};
      selectedIds.forEach(sid=>{
        let n = (typeof getNodeById==='function') && getNodeById(sid);
        let g = (typeof getGroupById==='function') && getGroupById(sid);
        let t = (typeof getTextboxById==='function') && getTextboxById(sid);
        let c = (window.checklistNodes||[]).find(c=>c.id===sid);
        if(n) startPositions[sid] = {x:n.x, y:n.y, type:'node'};
        else if(g) startPositions[sid] = {x:g.x, y:g.y, type:'group'};
        else if(t) startPositions[sid] = {x:parseFloat(t.element.style.left), y:parseFloat(t.element.style.top), type:'textbox'};
        else if(c) startPositions[sid] = {x:c.x, y:c.y, type:'check'};
      });
      function onMove(ev){
        if (!dragging) return;
        const w = toWorld(ev.clientX, ev.clientY);
        const dx = Math.round(w.x - startWorld.x);
        const dy = Math.round(w.y - startWorld.y);
        selectedIds.forEach(sid=>{
          const sp = startPositions[sid]; if(!sp) return;
          if(sp.type==='node'){
            const n = getNodeById(sid);
            const locked = n && (n.locked===true || (n.el && (n.el.dataset.locked==='1' || n.el.classList.contains('locked'))));
            if(n && !locked){ n.x = sp.x + dx; n.y = sp.y + dy; n.el.style.left = n.x+'px'; n.el.style.top = n.y+'px'; }
          } else if(sp.type==='group'){
            const g = getGroupById(sid);
            const locked = g && (g.locked===true || (g.el && (g.el.dataset.locked==='1' || g.el.classList.contains('locked'))));
            if(g && !locked){ g.x = sp.x + dx; g.y = sp.y + dy; g.el.style.left = g.x+'px'; g.el.style.top = g.y+'px'; }
          } else if(sp.type==='textbox'){
            const t = getTextboxById(sid); if(t){ const nx = sp.x + dx, ny = sp.y + dy; t.element.style.left = nx+'px'; t.element.style.top = ny+'px'; }
          } else if(sp.type==='check'){
            const c = (window.checklistNodes||[]).find(c=>c.id===sid); if(c && c.element){ c.x = sp.x + dx; c.y = sp.y + dy; c.element.style.left = c.x+'px'; c.element.style.top = c.y+'px'; }
          }
        });
        try { if (window.updateAllWires) updateAllWires(); } catch(_){ }
      }
      function endDrag(ev){
        if (ev){ ev.preventDefault(); ev.stopPropagation(); }
        dragging = false;
        node.setAttribute('aria-grabbed', 'false');
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', endDrag);
      }
      window.addEventListener('mousemove', onMove, { passive: false });
      window.addEventListener('mouseup', endDrag, { passive: false });
    }

    // Start drag ONLY from the handle
    grip.addEventListener('mousedown', startDrag);

    // Keep clicks on checkbox/text behaving normally, but prevent canvas interaction
    node.addEventListener('mousedown', (e)=>{
      e.stopPropagation(); // Always prevent canvas interaction
      if (e.target === grip) return; // drag via grip already handled
      const additive = e.shiftKey || e.metaKey || e.ctrlKey;
      if(additive){ if(typeof toggleSelect==='function') toggleSelect(id); }
      else { if(typeof selectId==='function') selectId(id); }
    });
    
    // Prevent any canvas interaction when clicking anywhere on the checklist
    node.addEventListener('click', (e)=>{
      e.stopPropagation();
    });

    // Optional: Enter creates a new sibling node below (Shift+Enter stays in current)
    text.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        const belowY = (parseFloat(node.style.top)||0) + node.offsetHeight + 8;
        const nx = (parseFloat(node.style.left)||0);
        const nn = createChecklistNode(nx, belowY, '', false);
        // Focus new node's text
        setTimeout(()=>{
          const t = nn.element.querySelector('.checktext');
          const r = document.createRange(); const s = window.getSelection();
          r.selectNodeContents(t); r.collapse(false); s.removeAllRanges(); s.addRange(r);
          t.focus();
        }, 0);
      }
    });

    board.appendChild(node);
    // Focus text right after creation
    setTimeout(()=>{
      const r = document.createRange(); const s = window.getSelection();
      r.selectNodeContents(text); r.collapse(false); s.removeAllRanges(); s.addRange(r);
      text.focus();
    }, 0);

    return checklistData; // Return the data object instead of the node
  }

  // Public API for integration with existing canvas menu
  
window.addChecklistNodeAt = (x, y, text, checked, w, h, extra, forcedId, fontSize) => {
  if (x && typeof x === 'object' && x.x != null) {
    const o = x;
    return createChecklistNode(o.x, o.y, o.text, !!o.checked, {
      id: o.id, w: o.w || o.width, h: o.h || o.height,
      bg: o.bg || (o.style && o.style.background),
      border: o.border || (o.style && o.style.borderColor),
      color: o.color || (o.style && o.style.color),
      fontSize: o.fontSize || (o.text && o.text.fontSize),
      html: o.textHtml || o.html
    });
  }
  const opts = {
    id: forcedId, w: w, h: h,
    bg: extra && extra.bg, border: extra && extra.border, color: extra && extra.color,
    fontSize: fontSize, html: extra && extra.html
  };
  return createChecklistNode(x, y, text, !!checked, opts);
};

  
  // Expose checklist nodes array for save/load integration
  window.checklistNodes = checklistNodes;
})();

  

// === Instagram helpers (final) ===
function extractInstagramEmbed(url){
  const typeMatch = url.match(/(?:reel|reels|p|tv)/i);
  const codeMatch = url.match(/(?:reel|reels|p|tv)\/([A-Za-z0-9_-]+)/i);
  if(!typeMatch || !codeMatch) return null;
  const type = typeMatch[0].toLowerCase().replace('reels','reel');
  const shortcode = codeMatch[1].replace(/[^A-Za-z0-9_-].*$/, '');
  const embedUrl = `https://www.instagram.com/${type}/${shortcode}/embed`;
  const ar = (type === 'p') ? 0.8 : (9/16);
  return { embedUrl, shortcode, type, ar };
}

function createInstagramNode(originalUrl, at){
  const parsed = extractInstagramEmbed(originalUrl);
  if(!parsed){ alert('Invalid Instagram URL'); return; }
  const size = (parsed.type==='p') ? { w: 480, h: 600 } : { w: 420, h: 740 };
  const meta = {
    platform: 'instagram',
    type: parsed.type,
    shortcode: parsed.shortcode,
    embedUrl: parsed.embedUrl,
    originalUrl: originalUrl,
    ar: parsed.ar
  };
  if (typeof window.createNode === 'function') {
    return window.createNode('website', parsed.embedUrl, size, at, meta);
  }
  if (typeof window.createWebsiteNode === 'function') {
    return window.createWebsiteNode(parsed.embedUrl, at);
  }
  console.warn('No node creator found for Instagram.');
}

// === Video helpers ===
function ensureHlsJs(){
  return new Promise((resolve, reject)=>{
    if (window.Hls) return resolve(window.Hls);
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
    script.async = true;
    script.onload = ()=> resolve(window.Hls);
    script.onerror = ()=> reject(new Error('Failed to load hls.js'));
    document.head.appendChild(script);
  });
}
function createVideoNode(src, at, opts){
  const size = { w: 640, h: 360 };
  const meta = { platform:'video', src, type: (opts && opts.kind) || 'file' };
  if (typeof window.createNode === 'function') {
    return window.createNode('video', src, size, at, meta);
  }
  // Fallback: website path if createNode is unavailable
  if (typeof window.createWebsiteNode === 'function') {
    return window.createWebsiteNode(src, at);
  }
}

</script>


<script>
// === X (Twitter) helpers ===
function extractTweetId(url){
  const m = url.match(/status\/(\d+)/);
  return m ? m[1] : null;
}
function ensureTwitterWidgets(){
  return new Promise((resolve, reject)=>{
    if (window.twttr && window.twttr.widgets) return resolve(window.twttr);
    if (document.querySelector('script[src*="platform.twitter.com/widgets.js"]')) {
      let tries = 0;
      const t = setInterval(()=>{
        tries++;
        if (window.twttr && window.twttr.widgets){ clearInterval(t); resolve(window.twttr); }
        if (tries>50){ clearInterval(t); reject(new Error('Twitter widgets not ready')); }
      }, 100);
      return;
    }
    const s = document.createElement('script');
    s.async = true;
    s.src = 'https://platform.twitter.com/widgets.js';
    s.charset = 'utf-8';
    s.onload = ()=> resolve(window.twttr || {});
    s.onerror = ()=> reject(new Error('Failed to load Twitter widgets.js'));
    document.head.appendChild(s);
  });
}
function createTwitterNode(originalUrl, at){
  const id = extractTweetId(originalUrl);
  if(!id){ alert('Invalid X/Twitter URL'); return; }
  const size = { w: 600, h: 560 };
  const meta = { platform:'twitter', tweetId:id, originalUrl: originalUrl };
  if (typeof window.createNode === 'function') {
    return window.createNode('twitter', originalUrl, size, at, meta);
  }
  if (typeof window.createWebsiteNode === 'function') {
    return window.createWebsiteNode(originalUrl, at);
  }
}
</script>

  <!-- Floating Text Toolbar (injected) -->
  <aside id="textToolbar" class="ftb" aria-label="Text formatting toolbar">
    <div class="ftb-row">
      <button id="tbBold"      class="ftb-btn" title="Bold"><span>𝐁</span></button>
      <button id="tbItalic"    class="ftb-btn" title="Italic"><span>𝑖</span></button>
      <button id="tbUnderline" class="ftb-btn" title="Underline"><span>U̲</span></button>
      <button id="tbStrike"    class="ftb-btn" title="Strikethrough"><span>S̶</span></button>

      <div class="ftb-sep"></div>

      <label class="ftb-swatch" title="Text color"><input id="tbColor" type="color" value="#ffffff"/></label>
      <label class="ftb-swatch" title="Highlight"><input id="tbBg" type="color" value="#2f80ed"/></label>

      <div class="ftb-sep"></div>

      <select id="tbFont" class="ftb-select" title="Font family">
        <option value="system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">System UI</option>
        <option value="Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">Inter</option>
        <option value="Arial, Helvetica, sans-serif">Arial</option>
        <option value="Helvetica, Arial, sans-serif">Helvetica</option>
        <option value="'Times New Roman', Times, serif">Times New Roman</option>
        <option value="Georgia, 'Times New Roman', Times, serif">Georgia</option>
        <option value="'Courier New', Courier, monospace">Courier New</option>
        <option value="Menlo, Monaco, Consolas, 'Courier New', monospace">Menlo</option>
        <option value="Verdana, Geneva, Tahoma, sans-serif">Verdana</option>
   <option value="'Noto Sans', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">Noto Sans</option>
   <option value="'Noto Serif', Georgia, 'Times New Roman', Times, serif">Noto Serif</option>
   
<!-- Chinese fonts from your system -->
  <option value="'SimSun-ExtB', 'SimSun', '宋体', serif">    宋体  </option>
  <option value="'FangSong', '仿宋', 'STFangsong', serif">    仿宋   </option>
  <option value="'Microsoft YaHei', '微软雅黑', 'PingFang SC', 'Noto Sans SC', sans-serif">    微软雅黑  </option>
  <option value="'NSimSun', '新宋体', serif">    新宋体  </option>
  <option value="'KaiTi', '楷体', 'STKaiti', serif">    楷体   </option>
  <option value="'DengXian', '等线', sans-serif">    等线   </option>
  <option value="'SimHei', '黑体', 'Heiti SC', 'PingFang SC', sans-serif">    黑体   </option>
  <option value="'Noto Sans SC', 'Microsoft YaHei', 'PingFang SC', sans-serif">    Noto Sans SC  </option>

</select>


      <input id="tbFontSize" class="ftb-number" type="number" min="8" max="200" step="1" value="16" title="Font size (px)" />
      <span class="ftb-unit">px</span>

      <div class="ftb-sep"></div>

      <button id="tbAlignL" class="ftb-btn" title="Align left">⟸</button>
      <button id="tbAlignC" class="ftb-btn" title="Center">╷</button>
      <button id="tbAlignR" class="ftb-btn" title="Align right">⟹</button>
      <button id="tbAlignJ" class="ftb-btn" title="Justify">≋</button>

      <div class="ftb-sep"></div>

      <input id="tbLink" class="ftb-link" type="text" placeholder="https://…"/>
      <button id="tbMakeLink" class="ftb-btn" title="Make link">🔗</button>
      <button id="tbUnlink"   class="ftb-btn" title="Remove link">✖︎</button>

      <div class="ftb-sep"></div>

      <button id="tbClear"    class="ftb-btn" title="Clear formatting">⌫</button>
    </div>
  </aside>


<script>
(function(){
  const bar = document.getElementById('textToolbar');
  const MIN_OFFSET = -100, MARGIN = 8;
  let activeTextbox = null, savedRange = null;

  const isIn = (el, host) => !!(el && host && host.contains(el));
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const getRange = () => { const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return null; return sel.getRangeAt(0); };
  const saveSelection = () => { const r = getRange(); if (r) savedRange = r.cloneRange(); };
  const restoreSelection = () => { const sel = window.getSelection(); if (!sel || !savedRange) return; sel.removeAllRanges(); sel.addRange(savedRange); };

  function positionToTextbox(){
    if (!activeTextbox || !document.body.contains(activeTextbox)) { hideBar(); return; }
    const rect = activeTextbox.getBoundingClientRect();
    bar.classList.add('is-visible');
    const tbw = bar.offsetWidth, tbh = bar.offsetHeight;
    const vw = document.documentElement.clientWidth, vh = document.documentElement.clientHeight;
    let left = rect.left + (rect.width/2) - (tbw/2);
    left = clamp(Math.round(left), MARGIN, vw - tbw - MARGIN);
    let top = rect.top + MIN_OFFSET;
    if (top + tbh + MARGIN > vh) top = Math.max(MARGIN, vh - tbh - MARGIN);
    bar.style.left = left + 'px'; bar.style.top  = Math.round(top) + 'px';
  }
  function showBarForTextbox(tb){ activeTextbox = tb; bar.classList.add('is-visible'); positionToTextbox(); saveSelection(); }
  function hideBar(){ bar.classList.remove('is-visible'); bar.style.left='-9999px'; bar.style.top='-9999px'; activeTextbox=null; }

  // Focus behavior: support .textbox or any contenteditable=true
  document.addEventListener('focusin', (e)=>{
    const tb = e.target.closest && (e.target.closest('.textbox') || e.target.closest('[contenteditable=\"true\"]'));
    if (tb) showBarForTextbox(tb);
  });
  document.addEventListener('mousedown', (e)=>{
    const target = e.target;
    const inToolbar = isIn(target, bar);
    const tb = target.closest && (target.closest('.textbox') || target.closest('[contenteditable=\"true\"]'));
    if (inToolbar || (tb && tb === activeTextbox)) return;
    if (tb && tb !== activeTextbox) { showBarForTextbox(tb); return; }
    hideBar();
  }, true);
  window.addEventListener('resize', positionToTextbox);
  window.addEventListener('scroll', positionToTextbox, true);
  bar.addEventListener('mousedown', (e)=>{
    if (e.target.closest('input, select, textarea')) { saveSelection(); return; }
    e.preventDefault(); restoreSelection();
  });

  // Keep savedRange synced with current selection inside active textbox
  document.addEventListener('selectionchange', function(){
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0 || !activeTextbox) return;
    const r = sel.getRangeAt(0);
    const node = r.commonAncestorContainer.nodeType === 1 ? r.commonAncestorContainer : r.commonAncestorContainer.parentNode;
    if (activeTextbox && activeTextbox.contains(node)) { savedRange = r.cloneRange(); }
  });
  document.addEventListener('mouseup', function(){
    const r = getRange(); if (!r || !activeTextbox) return;
    const node = r.commonAncestorContainer.nodeType === 1 ? r.commonAncestorContainer : r.commonAncestorContainer.parentNode;
    if (activeTextbox.contains(node)) savedRange = r.cloneRange();
  });
  document.addEventListener('keyup', function(){
    const r = getRange(); if (!r || !activeTextbox) return;
    const node = r.commonAncestorContainer.nodeType === 1 ? r.commonAncestorContainer : r.commonAncestorContainer.parentNode;
    if (activeTextbox.contains(node)) savedRange = r.cloneRange();
  });

  // Inline style helper
  function cssProp(name){ return name.replace(/[A-Z]/g, m => '-' + m.toLowerCase()); }
  function applyInlineStyle(styleObj) {
    restoreSelection();
    const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    let css=''; for (const k in styleObj) css += cssProp(k) + ':' + styleObj[k] + ';';
    span.setAttribute('style', css);
    if (range.collapsed) {
      span.appendChild(document.createTextNode('\u200b'));
      range.insertNode(span);
      const r = document.createRange(); r.setStart(span.firstChild, 1); r.collapse(true); sel.removeAllRanges(); sel.addRange(r);
    } else {
      const frag = range.cloneContents(); span.appendChild(frag); range.deleteContents(); range.insertNode(span);
      const r = document.createRange(); r.selectNodeContents(span); r.collapse(false); sel.removeAllRanges(); sel.addRange(r);
    }
    positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true});
  }

  // Align blocks intersecting the selection (fallback to textbox itself)
  function setAlignment(align){
    restoreSelection();
    const sel = window.getSelection(); if (!sel || sel.rangeCount === 0 || !activeTextbox) return;
    const range = sel.getRangeAt(0);
    const blocks = Array.from(activeTextbox.querySelectorAll('p,div,li,h1,h2,h3,h4,h5,h6'));
    let applied = false;
    blocks.forEach(el => { if (range.intersectsNode(el)) { el.style.textAlign = (align === 'justify' ? 'justify' : align); applied = true; } });
    if (!applied) { activeTextbox.style.textAlign = (align === 'justify' ? 'justify' : align); }
    positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true});
  }

  function onRelease(el, fn){ if (!el) return; el.addEventListener('mouseup', (e)=>{ if (e.button !== 0) return; fn(e); }); el.addEventListener('touchend', (e)=>{ fn(e); }, {passive:false}); }
  const exec = (cmd, val=null) => { restoreSelection(); document.execCommand(cmd,false,val); positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true}); };

  // Buttons
  onRelease(document.getElementById('tbBold'),      ()=> exec('bold'));
  onRelease(document.getElementById('tbItalic'),    ()=> exec('italic'));
  onRelease(document.getElementById('tbUnderline'), ()=> exec('underline'));
  onRelease(document.getElementById('tbStrike'),    ()=> exec('strikeThrough'));

  // Align
  onRelease(document.getElementById('tbAlignL'),    ()=> setAlignment('left'));
  onRelease(document.getElementById('tbAlignC'),    ()=> setAlignment('center'));
  onRelease(document.getElementById('tbAlignR'),    ()=> setAlignment('right'));
  onRelease(document.getElementById('tbAlignJ'),    ()=> setAlignment('justify'));

  // Clear
  onRelease(document.getElementById('tbClear'),     ()=> { restoreSelection(); document.execCommand('removeFormat'); document.execCommand('unlink'); positionToTextbox(); });

  // Colors on change
  document.getElementById('tbColor').addEventListener('change', (e)=> exec('foreColor', e.target.value));
  document.getElementById('tbBg').addEventListener('change', (e)=>{ restoreSelection(); if (!document.execCommand('hiliteColor', false, e.target.value)) document.execCommand('backColor', false, e.target.value); positionToTextbox(); });

  // Font family + size
  const fontSel = document.getElementById('tbFont');
  function updateFontPreview(){ fontSel.style.fontFamily = fontSel.value; }
  fontSel.addEventListener('change', ()=>{ applyInlineStyle({ fontFamily: fontSel.value }); updateFontPreview(); });
  updateFontPreview();

  const sizeInput = document.getElementById('tbFontSize');
  function applySize() { let px = parseInt(sizeInput.value, 10); if (isNaN(px)) return; px = Math.max(parseInt(sizeInput.min,10), Math.min(parseInt(sizeInput.max,10), px)); sizeInput.value = px; applyInlineStyle({ fontSize: px + 'px' }); }
  sizeInput.addEventListener('change', applySize);
  sizeInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { e.preventDefault(); applySize(); } });

  // Links
  function makeLink(){
    let url = (document.getElementById('tbLink').value || '').trim(); if (!url) return;
    if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
    restoreSelection();
    const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0);
    if (range.collapsed){
      const a = document.createElement('a'); a.href = url; a.target = '_blank'; a.rel='noopener noreferrer'; a.textContent = url;
      range.insertNode(a); range.setStartAfter(a); range.collapse(true); sel.removeAllRanges(); sel.addRange(range);
    } else {
      document.execCommand('createLink', false, url);
      let node = sel.focusNode; if (node && node.nodeType === 3) node = node.parentNode; const a = node && node.closest('a');
      if (a) { a.target = '_blank'; a.rel = 'noopener noreferrer'; a.href = url; }
    }
    positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true});
  }
  onRelease(document.getElementById('tbMakeLink'), makeLink);
  onRelease(document.getElementById('tbUnlink'), ()=> exec('unlink'));

  // Show for already-focused contenteditable
  if (document.activeElement && (document.activeElement.matches?.('.textbox,[contenteditable=\"true\"]'))) {
    showBarForTextbox(document.activeElement);
  }
})();
</script>


  <!-- Floating Spotlight Search -->
  <div id="spotlightOverlay" aria-hidden="true">
    <div class="spotlight-card" role="dialog" aria-modal="true" aria-label="Search the web">
      <div class="spotlight-row">
        <input id="spotlightInput" class="spotlight-input" type="text" placeholder="Search Google…" autocomplete="off">
        <button id="spotlightGo" class="spotlight-btn" title="Search Google">Search</button>
      </div>
      <div class="spotlight-hint">
        <span>Tip: Use quotes for exact matches.</span>
        <span><span class="kbd">Left Ctrl</span> + <span class="kbd">Space</span> to open • <span class="kbd">Esc</span> to close • <span class="kbd">Enter</span> to search</span>
      </div>
    </div>
  </div>

<script>
(function(){
  const overlay = document.getElementById('spotlightOverlay');
  const input = document.getElementById('spotlightInput');
  const goBtn = document.getElementById('spotlightGo');
  let isLeftCtrlDown = false;
  let lastActiveEl = null;
  let savedSelection = null;

  function openOverlay(){
    // Save focus & selection (for editors using selection restore)
    lastActiveEl = document.activeElement;
    const sel = window.getSelection && window.getSelection();
    if (sel && sel.rangeCount) savedSelection = sel.getRangeAt(0).cloneRange();

    overlay.classList.add('is-open');
    overlay.setAttribute('aria-hidden', 'false');
    setTimeout(()=>{ input.focus(); input.select(); }, 0);
  }
  function closeOverlay(restore=true){
    overlay.classList.remove('is-open');
    overlay.setAttribute('aria-hidden', 'true');
    if (restore){
      // Restore focus & selection
      if (lastActiveEl && typeof lastActiveEl.focus === 'function') {
        try { lastActiveEl.focus({preventScroll:true}); } catch(e){}
      }
      if (savedSelection) {
        const sel = window.getSelection && window.getSelection();
        if (sel) { sel.removeAllRanges(); sel.addRange(savedSelection); }
      }
    }
  }
  function searchNow(){
    const q = (input.value || '').trim();
    if (!q) { input.focus(); return; }
    const url = 'https://www.google.com/search?q=' + encodeURIComponent(q);
    window.open(url, '_blank', 'noopener');
    closeOverlay();
  }

  // Keyboard handling — detect LeftCtrl + Space to open
  document.addEventListener('keydown', (e)=>{
    if (e.code === 'ControlLeft') isLeftCtrlDown = true;
    if (e.code === 'Space' && isLeftCtrlDown && !e.shiftKey && !e.altKey && !e.metaKey) {
      e.preventDefault();
      e.stopPropagation();
      openOverlay();
    }
  }, true);
  document.addEventListener('keyup', (e)=>{
    if (e.code === 'ControlLeft') isLeftCtrlDown = false;
  }, true);

  // Overlay interactions
  overlay.addEventListener('click', (e)=>{ if (e.target === overlay) closeOverlay(); });
  document.addEventListener('keydown', (e)=>{
    if (!overlay.classList.contains('is-open')) return;
    if (e.key === 'Escape') { e.preventDefault(); closeOverlay(); }
    if (e.key === 'Enter' && document.activeElement === input) { e.preventDefault(); searchNow(); }
  });

  goBtn.addEventListener('click', (e)=>{ e.preventDefault(); searchNow(); });
})();
</script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script>
// ==== Canvas → PNG snapshot + utilities ====
const SNAP_MAX_W = 640, SNAP_MAX_H = 360; // thumbnail bounds

async function captureBoardSnapshot(){
  const node = document.getElementById('viewport'); // full canvas container
  const canvas = await html2canvas(node, {
    backgroundColor: null,
    useCORS: true,
    scale: 1
  });
  const full = canvas.toDataURL('image/png', 0.92);
  const thumb = await downscaleDataUrl(full, SNAP_MAX_W, SNAP_MAX_H);
  return { full, thumb };
}

async function downscaleDataUrl(dataUrl, maxW, maxH){
  const img = new Image();
  img.src = dataUrl;
  await img.decode();
  const r = Math.min(maxW / img.width, maxH / img.height, 1);
  const w = Math.max(1, Math.round(img.width * r));
  const h = Math.max(1, Math.round(img.height * r));
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const x = c.getContext('2d');
  x.drawImage(img, 0, 0, w, h);
  return c.toDataURL('image/png', 0.92);
}

/* Download helpers (used by panel buttons) */
function downloadTextAs(name, text, mime='application/json'){
  const blob = new Blob([text], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement('a'), { href:url, download:name });
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}
function downloadDataUrl(dataUrl, filename){
  const a = Object.assign(document.createElement('a'), { href:dataUrl, download:filename });
  document.body.appendChild(a); a.click(); a.remove();
}
</script>

<div id="tbCtxMenu" role="menu" aria-hidden="true">
  <div class="title">Textbox color</div>
  <div class="row seg">
    <button type="button" data-prop="bg" class="active">Background</button>
    <button type="button" data-prop="text">Text</button>
    <button type="button" data-prop="border">Border</button>
  </div>
  <div class="row"><input id="tbColorPicker" type="color" value="#8b5cf6" /></div>
  
<div class="row alpha" id="tbAlphaRow" style="display:flex;gap:8px;align-items:center;">
  <span class="alpha-label" style="font-size:12px;color:#cfd7ff;opacity:.85;width:60px;">Opacity</span>
  <input id="tbAlpha" type="range" min="0" max="100" value="100" style="flex:1">
  <span id="tbAlphaVal" style="font-size:12px;color:#e8ecff;min-width:36px;text-align:right;">100%</span>
</div>
<div class="row swatch" id="tbSwatches"></div>
</div>


<script id="tb-ctx-js">
(function(){
  const menu = document.getElementById('tbCtxMenu');
  const picker = document.getElementById('tbColorPicker');
  const swatches = document.getElementById('tbSwatches');
  const propBtns = menu ? Array.from(menu.querySelectorAll('[data-prop]')) : [];
  
const alphaRow = document.getElementById('tbAlphaRow');
const alpha = document.getElementById('tbAlpha');
const alphaVal = document.getElementById('tbAlphaVal');
let currentAlpha = 1; // 0..1
let currentTarget = null;
  let currentProp = 'bg';

  const QUICK = ['#ffffff','#000000','#111827','#1f2937','#6b7280','#9ca3af','#ef4444','#f59e0b','#fbbf24','#10b981','#3b82f6','#8b5cf6'];

  

function hexToRgb(hex){
  try{
    let h = hex.replace('#','').trim();
    if(h.length === 3){ h = h.split('').map(c=>c+c).join(''); }
    const num = parseInt(h, 16);
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }catch(e){
    return {r:139,g:92,b:246};
  }
}

function parseRGBA(str){
  const m = String(str||'').match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/i);
  if(!m) return {r:139,g:92,b:246,a:1};
  return { r: +m[1], g: +m[2], b: +m[3], a: m[4]!==undefined ? Math.max(0, Math.min(1, parseFloat(m[4]))) : 1 };
}

function updateBackground(){
  if(!currentTarget || currentProp!=='bg') return;
  const rgb = hexToRgb(picker ? picker.value : '#8b5cf6');
  const a = (typeof currentAlpha === 'number' ? currentAlpha : 1);
  currentTarget.style.background = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + a.toFixed(2) + ')';
}
function ensureSwatches(){
    if(!swatches || swatches.childElementCount) return;
    QUICK.forEach(c=>{
      const b = document.createElement('button');
      b.style.background = c;
      b.title = c;
      b.addEventListener('click', ()=> applyColor(c));
      swatches.appendChild(b);
    });
  }
  function rgbToHex(rgb){
    const m = rgb && rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!m) return '#8b5cf6';
    return '#' + [m[1],m[2],m[3]].map(v=> parseInt(v,10).toString(16).padStart(2,'0')).join('');
  }
  

function applyColor(hex){
  if(!currentTarget) return;
  if (picker && typeof hex === 'string') { try { picker.value = hex; } catch(_){} }
  if(currentProp==='bg'){
    updateBackground();
  } else if(currentProp==='text'){
    currentTarget.style.color = hex;
  } else if(currentProp==='border'){
    currentTarget.style.borderColor = hex;
  }
}


  
function setProp(prop){
    currentProp = prop || 'bg';
    if(currentTarget){
      const cs = getComputedStyle(currentTarget);
      let seed = '#8b5cf6';
      if(currentProp==='bg' && cs.backgroundColor){
        const rgba = parseRGBA(cs.backgroundColor);
        seed = '#' + [rgba.r, rgba.g, rgba.b].map(v=> v.toString(16).padStart(2,'0')).join('');
        if(alpha){
          currentAlpha = rgba.a;
          alpha.value = Math.round((currentAlpha || 1)*100);
        }
        if(alphaVal){
          alphaVal.textContent = Math.round((currentAlpha || 1)*100) + '%';
        }
        if(alphaRow){ alphaRow.style.display = 'flex'; }
      } else {
        if(alphaRow){ alphaRow.style.display = 'none'; }
      }
      if(currentProp==='text' && cs.color) seed = rgbToHex(cs.color);
      if(currentProp==='border' && cs.borderColor) seed = rgbToHex(cs.borderColor);
      if(picker) picker.value = seed;
    }
    propBtns.forEach(b=> b.classList.toggle('active', (b.getAttribute('data-prop')===currentProp)));
  }

  function openAt(x,y,target){ if(!menu) return; ensureSwatches(); currentTarget = target; setProp(currentProp);
    menu.style.left = Math.max(8, Math.min(window.innerWidth - 240, x)) + 'px';
    menu.style.top  = Math.max(8, Math.min(window.innerHeight - 180, y)) + 'px';
    menu.style.display = 'block';
    menu.setAttribute('aria-hidden','false');
    setProp(currentProp);
  }
  function close(){
    if(!menu) return;
    menu.style.display = 'none';
    menu.setAttribute('aria-hidden','true');
    currentTarget = null;
  }

  // Expose for context menu integration
  window.openTextboxColorAt = openAt;
  window.closeTextboxColorMenu = close;

  // Bind picker and prop buttons
  if(picker) picker.addEventListener('input', (e)=> applyColor(e.target.value));
  propBtns.forEach(btn=>{
    btn.addEventListener('click', ()=> setProp(btn.getAttribute('data-prop')||'bg'));
  });

  // Prevent menu from closing itself via right-click
  // Close when clicking outside on canvas or document
  document.addEventListener('click', function(e){
    if (window.__openingTextboxColor) { return; }
    if(menu && menu.style.display==='block'){
      if(!menu.contains(e.target)){
        close();
      }
    }
  });
  if(menu) menu.addEventListener('contextmenu', (e)=> e.preventDefault());


  if (alpha) {
    alpha.addEventListener('input', function() {
      const v = Math.max(0, Math.min(100, parseInt(this.value, 10) || 0));
      currentAlpha = v / 100;
      if (alphaVal) alphaVal.textContent = v + '%';
      // Live update only for background
      updateBackground();
    });
  }

})();
</script>

<script id="mobile-enhance-js">
(function(){
  // --- Proportional panel resize based on viewport ---
  function resizePanelsForViewport(){
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const urlPanel = document.querySelector('.url-panel');
    const savePanel = document.querySelector('.save-panel');
    // Compute a scale from 360px base width up to 420px; scale down on small screens
    const base = 420;
    const pad = 24;
    const usable = vw - pad*2;
    const width = Math.min(base, Math.max(280, Math.floor(usable * 0.92)));
    const maxH = Math.floor(vh - 140);

    [urlPanel, savePanel].forEach(el=>{
      if(!el) return;
      el.style.width = width + 'px';
      el.style.maxHeight = maxH + 'px';
      el.style.overflow = 'auto';
    });
  }
  window.addEventListener('resize', resizePanelsForViewport);
  window.addEventListener('orientationchange', resizePanelsForViewport);
  document.addEventListener('DOMContentLoaded', resizePanelsForViewport);

  // --- One-finger touch = mouse drag (synthesizer) ---
  const board = document.getElementById('viewport');
  if(board){
    // Avoid duplicating listeners
    if(!board.__oneFingerDragEnabled){
      const synth = (type, touch, target)=>{
        const ev = new MouseEvent(type, {
          bubbles: true, cancelable: true, view: window,
          clientX: touch.clientX, clientY: touch.clientY,
          screenX: touch.screenX, screenY: touch.screenY,
          buttons: type==='mouseup' ? 0 : 1
        });
        target.dispatchEvent(ev);
      };

      let touching = false, lastTarget = null;
      board.addEventListener('touchstart', (e)=>{
        if(e.touches.length !== 1) return;
        touching = true;
        const t = e.touches[0];
        lastTarget = document.elementFromPoint(t.clientX, t.clientY) || board;
        // Route to underlying target (node/textbox) to reuse existing mouse handlers
        e.preventDefault();
        synth('mousedown', t, lastTarget);
      }, {passive:false});

      board.addEventListener('touchmove', (e)=>{
        if(!touching || e.touches.length !== 1) return;
        const t = e.touches[0];
        const tgt = document.elementFromPoint(t.clientX, t.clientY) || lastTarget || board;
        e.preventDefault();
        synth('mousemove', t, tgt);
      }, {passive:false});

      board.addEventListener('touchend', (e)=>{
        if(!touching) return;
        touching = false;
        const t = (e.changedTouches && e.changedTouches[0]) || {clientX:0, clientY:0, screenX:0, screenY:0};
        const tgt = document.elementFromPoint(t.clientX, t.clientY) || lastTarget || board;
        e.preventDefault();
        synth('mouseup', t, tgt);
        lastTarget = null;
      }, {passive:false});

      board.addEventListener('touchcancel', ()=>{ touching = false; lastTarget=null; }, {passive:true});
      board.__oneFingerDragEnabled = true;
    }
  }
})();
</script>

<script id="zoom-btn-js">
(function(){
  const levels = [0.05, 0.10, 0.25, 0.50, 1.00, 1.50, 2.00, 4.00];
  const zoomPctEl = document.getElementById('zoomPct');
  const minusBtn = document.querySelector('#zoomControls [data-zoom-dir="-"]');
  const plusBtn = document.querySelector('#zoomControls [data-zoom-dir="+"]');

  function updateZoomDisplay(){
  try {
    var z = (window.state && typeof state.zoom === 'number') ? state.zoom : 1;
    var el = document.getElementById('zoomDisplay') || document.querySelector('[data-zoom-display]');
    if (el) el.textContent = Math.round(z * 100) + '%';
  } catch(_) { /* ignore */ }
}

  function setZoomTo(value, anchorPx){
    const MIN = levels[0], MAX = levels[levels.length-1];
    const prev = state.zoom;
    const next = Math.min(MAX, Math.max(MIN, value));
    if(next === prev) return;
    const rectV = viewport.getBoundingClientRect();
    const cx = anchorPx ? anchorPx.x : rectV.width/2;
    const cy = anchorPx ? anchorPx.y : rectV.height/2;
    const ox = (cx - state.origin.x) / prev;
    const oy = (cy - state.origin.y) / prev;
    state.origin.x = cx - ox * next;
    state.origin.y = cy - oy * next;
    state.zoom = next;
    applyTransform();
    updateZoomDisplay();
  }

  function stepZoom(dir){
    const current = state.zoom;
    const idx = levels.findIndex(l=> Math.abs(l - current) < 0.001);
    if(idx === -1){
      // if current zoom is custom, find nearest
      let nearestIdx = 0, diff = Infinity;
      for(let i=0;i<levels.length;i++){
        const d = Math.abs(levels[i]-current);
        if(d<diff){ diff=d; nearestIdx=i; }
      }
      if(dir==='+' && nearestIdx < levels.length-1) setZoomTo(levels[nearestIdx+1]);
      else if(dir==='-' && nearestIdx > 0) setZoomTo(levels[nearestIdx-1]);
    } else {
      if(dir==='+' && idx < levels.length-1) setZoomTo(levels[idx+1]);
      else if(dir==='-' && idx > 0) setZoomTo(levels[idx-1]);
    }
  }

  if(minusBtn) minusBtn.addEventListener('click', ()=> stepZoom('-'));
  if(plusBtn) plusBtn.addEventListener('click', ()=> stepZoom('+'));

  // keep % updated when zoom changes elsewhere
  const _applyTransform = window.applyTransform || function(){};
  window.applyTransform = function(){
    _applyTransform();
    updateZoomDisplay();
  };
  updateZoomDisplay();
})();
</script>

<script id="zoom-steps-js">
(function(){
  const steps = [0.05, 0.10, 0.25, 0.50, 1.00, 1.50, 2.00, 4.00];
  const minus = document.getElementById('zoomMinus');
  const plus  = document.getElementById('zoomPlus');
  const label = document.getElementById('zoomLabel');
  const pctEl = document.getElementById('zoomPct');
  const viewport = document.getElementById('viewport');
  const board = document.getElementById('board');
  const bar = document.querySelector('.scale-bar');

  function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
  function fmt(z){ return Math.round(z*100) + '%'; }

  function matrixScaleFrom(el){
    if(!el) return null;
    const t = getComputedStyle(el).transform;
    if(!t || t === 'none') return null;
    // matrix(a,b,c,d,tx,ty) -> scaleX = sqrt(a^2 + b^2)
    const m = t.match(/matrix\(([^)]+)\)/);
    if(m){
      const parts = m[1].split(',').map(v=>parseFloat(v));
      if(parts.length >= 4){
        const a = parts[0], b = parts[1];
        const scale = Math.sqrt(a*a + b*b);
        if(scale && isFinite(scale)) return scale;
      }
    }
    // matrix3d / other cases
    const m3 = t.match(/matrix3d\(([^)]+)\)/);
    if(m3){
      const p = m3[1].split(',').map(v=>parseFloat(v));
      // scaleX = length of first column (m11, m12, m13)
      if(p.length >= 16){
        const s = Math.sqrt(p[0]*p[0] + p[1]*p[1] + p[2]*p[2]);
        if(s && isFinite(s)) return s;
      }
    }
    return null;
  }

  function currentZoom(){
    // Prefer reading from transform of the board (source of truth)
    const m = matrixScaleFrom(board);
    if(m) return m;
    // Fallback to state.zoom
    try{ return window.state?.zoom ?? 1; } catch { return 1; }
  }

  function updateLabel(){
    const z = currentZoom();
    if(label) label.textContent = fmt(z);
    if(pctEl) pctEl.textContent = fmt(z);
  }

  function setZoom(z, anchorPx){
    // If your app uses state + applyTransform, use that path;
    // label will be corrected by our hooks below.
    if(window.state && typeof window.applyTransform === 'function'){
      const rectV = viewport.getBoundingClientRect();
      const prev = window.state.zoom ?? currentZoom();
      const next = clamp(z, steps[0], steps[steps.length-1]);

      const cx = anchorPx ? anchorPx.x : rectV.width  / 2;
      const cy = anchorPx ? anchorPx.y : rectV.height / 2;
      const ox = (cx - window.state.origin.x) / prev;
      const oy = (cy - window.state.origin.y) / prev;
      window.state.origin.x = cx - ox * next;
      window.state.origin.y = cy - oy * next;
      window.state.zoom = next;
      window.applyTransform();
    }else{
      // As a fallback, directly set transform on board
      const next = clamp(z, steps[0], steps[steps.length-1]);
      board && (board.style.transform = `scale(${next})`);
    }
    updateLabel();
  }

  function nearestIndex(z){
    let idx = 0;
    for(let i=0;i<steps.length;i++){
      if(z >= steps[i]) idx = i;
    }
    if(idx < steps.length-1){
      const a = Math.abs(z - steps[idx]);
      const b = Math.abs(z - steps[idx+1]);
      if(b < a) idx = idx+1;
    }
    return idx;
  }
  function step(dir){
    const z = currentZoom();
    const i = nearestIndex(z) + (dir>0 ? 1 : -1);
    const j = clamp(i, 0, steps.length-1);
    const rectV = viewport.getBoundingClientRect();
    setZoom(steps[j], {x: rectV.width/2, y: rectV.height/2});
  }

  if(minus) minus.addEventListener('click', ()=> step(-1));
  if(plus)  plus.addEventListener('click',  ()=> step(+1));

  // --- Keep label synced no matter what ---
  const _applyTransform = window.applyTransform;
  if(typeof _applyTransform === 'function'){
    window.applyTransform = function(){
      _applyTransform();
      updateLabel();
    };
  }

  // Observe transform style changes on #board
  if(board){
    const mo = new MutationObserver((muts)=>{
      for(const m of muts){
        if(m.type === 'attributes' && m.attributeName === 'style'){
          updateLabel();
        }
      }
    });
    mo.observe(board, { attributes: true, attributeFilter: ['style'] });
  }

  // Also refresh on common interactions (click, wheel, touch, pointer)
  const events = ['mousedown','mouseup','click','wheel','pointerdown','pointerup','touchstart','touchend'];
  events.forEach(ev=> viewport && viewport.addEventListener(ev, updateLabel, {passive:true}));

  // rAF watcher only updates when value changes (very light)
  let lastZ = null;
  function watchZoom(){
    const z = currentZoom();
    if(z !== lastZ){
      lastZ = z;
      updateLabel();
    }
    requestAnimationFrame(watchZoom);
  }

  // --- Keep controls on-screen ---
  function clampBarIntoView(){
    if(!bar) return;
    const r = bar.getBoundingClientRect();
    let x = r.left, y = r.top;
    const pad = 12;
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    // If it's out of view for any reason, snap back to bottom-left
    if(r.right < 0 || r.bottom < 0 || r.left > vw || r.top > vh){
      bar.style.left = pad + 'px';
      bar.style.bottom = pad + 'px';
      bar.style.top = 'auto';
      bar.style.right = 'auto';
    }
  }
  ['resize','orientationchange','scroll'].forEach(ev=> window.addEventListener(ev, clampBarIntoView, {passive:true}));

  document.addEventListener('DOMContentLoaded', ()=>{
    updateLabel();
    clampBarIntoView();
    watchZoom();
  });
})();
</script>
<script id="center-zoom-and-panel-toggle-js">
(function(){
  // --- Position zoom above the footer hint by 25px ---
  function findFooterHint(){
    // Try an id first if exists, else search by text
    let el = document.getElementById('footerHint');
    if(el) return el;
    const all = Array.from(document.querySelectorAll('div,footer,section,span,p'));
    const needle = 'Google Search Shortcut (Left Ctrl + Space)';
    for(const n of all){
      if(n && n.textContent && n.textContent.trim().includes(needle)){
        return n;
      }
    }
    return null;
  }

  function updateZoomBottom(){
    const hint = findFooterHint();
    const safeBottom = 0; // env() is used in CSS; we just offset relative to viewport here
    let offset = 20; // default
    if(hint){
      const r = hint.getBoundingClientRect();
      const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      // Distance from bottom of viewport to be 25px above the hint's top edge
      const fromBottom = Math.max(12, (vh - r.top) + 25);
      offset = fromBottom;
    } else {
      offset = 32; // fallback
    }
    // write to root variable so CSS takes it
    document.documentElement.style.setProperty('--zoom-bottom-offset', offset + 'px');
  }

  window.addEventListener('resize', updateZoomBottom, {passive:true});
  window.addEventListener('orientationchange', updateZoomBottom);
  document.addEventListener('DOMContentLoaded', updateZoomBottom);

  // --- Install minimalistic collapse/expand toggles on panels ---
  function makePanelCollapsible(panel){
    if(!panel || panel.classList.contains('panel-collapsible')) return;
    panel.classList.add('panel-collapsible');

    // Wrap everything after the first H3 as panel-body
    let header = panel.querySelector('h3');
    if(!header){
      // create a fallback header if missing
      header = document.createElement('h3');
      header.textContent = 'Panel';
      panel.insertBefore(header, panel.firstChild);
    }
    let body = panel.querySelector('.panel-body');
    if(!body){
      body = document.createElement('div');
      body.className = 'panel-body';
      // Move all siblings after header into body
      let sib = header.nextSibling;
      const toMove = [];
      while(sib){
        const next = sib.nextSibling;
        toMove.push(sib);
        sib = next;
      }
      toMove.forEach(n=> body.appendChild(n));
      panel.appendChild(body);
    }

    // Add a toggle button
    let btn = panel.querySelector('.panel-toggle');
    if(!btn){
      btn = document.createElement('button');
      btn.className = 'panel-toggle';
      btn.setAttribute('aria-expanded', 'true');
      btn.title = 'Collapse/Expand';
      btn.textContent = '–'; // collapse symbol
      panel.appendChild(btn);
    }

    const setCollapsed = (yes)=>{
      panel.classList.toggle('collapsed', !!yes);
      btn.setAttribute('aria-expanded', (!yes).toString());
      btn.textContent = yes ? '+' : '–';
    };

    btn.addEventListener('click', ()=> setCollapsed(!panel.classList.contains('collapsed')));
    // Optional: click header to toggle
    header.addEventListener('click', (e)=>{
      // avoid toggling when clicking buttons inside header
      if(e.target.closest('.panel-toggle')) return;
      setCollapsed(!panel.classList.contains('collapsed'));
    });
  }

  function setupPanels(){
    const urlPanel = document.querySelector('.url-panel');
    const savePanel = document.querySelector('.save-panel');
    makePanelCollapsible(urlPanel);
    makePanelCollapsible(savePanel);
  }

  document.addEventListener('DOMContentLoaded', setupPanels);
})();
</script>

<script id="panel-align-js">
(function(){
  function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }

  function layoutPanels(){
    const url = document.querySelector('.url-panel');
    const save = document.querySelector('.save-panel');
    if(!url || !save) return;

    // Ensure measured sizes are up to date
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const pad = 12;

    // Constrain widths
    const maxW = Math.min(520, vw - pad*2);
    [url, save].forEach(el=>{
      el.style.maxWidth = maxW + 'px';
      el.style.width = Math.min(el.offsetWidth || maxW, maxW) + 'px';
      el.style.left = pad + 'px';
    });

    // Place URL panel near top-left with header buffer
    const headerBuffer = 72; // beneath the app header
    const urlTop = clamp(headerBuffer, pad, vh - pad - 100);
    url.style.top = urlTop + 'px';

    // Place Save panel directly under URL panel with gap
    const gap = 12;
    const urlRect = url.getBoundingClientRect();
    let saveTop = Math.round(urlRect.bottom + gap);
    const saveHeight = save.getBoundingClientRect().height || 200;

    // If save panel would fall off bottom, clamp and make scrollable
    if (saveTop + saveHeight + pad > vh){
      saveTop = vh - saveHeight - pad;
      // If still too tall, set max-height so it fits
      const maxH = Math.max(140, vh - saveTop - pad);
      save.style.maxHeight = maxH + 'px';
      save.style.overflow = 'auto';
    } else {
      // reset if previously constrained
      save.style.maxHeight = '';
      save.style.overflow = '';
    }
    save.style.top = clamp(saveTop, urlTop + gap, vh - pad - 100) + 'px';
  }

  window.addEventListener('resize', layoutPanels, {passive:true});
  window.addEventListener('orientationchange', layoutPanels);
  document.addEventListener('DOMContentLoaded', layoutPanels);

  // Re-run after panels collapse/expand to keep alignment
  const url = document.querySelector('.url-panel');
  const save = document.querySelector('.save-panel');
  const rerun = ()=> setTimeout(layoutPanels, 0);
  if(url) url.addEventListener('click', rerun, true);
  if(save) save.addEventListener('click', rerun, true);
})();
</script>


<script id="touch-gestures-js">
(function(){
  const viewport = document.getElementById('viewport');
  const board = document.getElementById('board');
  if(!viewport || !board) return;

  // Ensure browser doesn't hijack gestures
  viewport.style.touchAction = 'none';

  // --- Utilities ---
  function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
  function getZoom(){
    try{ return window.state?.zoom ?? 1; }catch{ return 1; }
  }
  function setZoomAround(nextZoom, anchor){
    if(!window.applyTransform || !window.state) return;
    const rect = viewport.getBoundingClientRect();
    const prev = getZoom();
    const next = clamp(nextZoom, 0.05, 4);
    const cx = anchor ? anchor.x : rect.width/2;
    const cy = anchor ? anchor.y : rect.height/2;
    const ox = (cx - window.state.origin.x) / prev;
    const oy = (cy - window.state.origin.y) / prev;
    window.state.origin.x = cx - ox * next;
    window.state.origin.y = cy - oy * next;
    window.state.zoom = next;
    window.applyTransform();
  }
  function midpoint(a,b){
    return { x: (a.clientX+b.clientX)/2, y: (a.clientY+b.clientY)/2 };
  }
  function distance(a,b){
    const dx = a.clientX - b.clientX, dy = a.clientY - b.clientY;
    return Math.hypot(dx, dy);
  }
  function synthMouse(type, pt, opts){
    const target = document.elementFromPoint(pt.clientX, pt.clientY) || viewport;
    const ev = new MouseEvent(type, {
      bubbles: true, cancelable: true, view: window,
      clientX: pt.clientX, clientY: pt.clientY,
      screenX: pt.screenX || 0, screenY: pt.screenY || 0,
      buttons: type==='mouseup' ? 0 : (opts && opts.buttons || 1),
      button: opts && ('button' in opts) ? opts.button : 0,
      shiftKey: !!(opts && opts.shiftKey),
      ctrlKey: !!(opts && opts.ctrlKey),
      altKey: !!(opts && opts.altKey),
      metaKey: !!(opts && opts.metaKey)
    });
    target.dispatchEvent(ev);
    return target;
  }

  // --- One-finger double-tap => right-click (context menu)
  let lastTap = { t: 0, x: 0, y: 0 };
  viewport.addEventListener('touchend', (e)=>{
    if(e.changedTouches.length !== 1 || (e.touches && e.touches.length)) return;
    const t = e.changedTouches[0];
    const now = performance.now();
    const dt = now - lastTap.t;
    const dx = Math.abs(t.clientX - lastTap.x);
    const dy = Math.abs(t.clientY - lastTap.y);
    if(dt < 300 && dx < 20 && dy < 20){
      e.preventDefault();
      const target = document.elementFromPoint(t.clientX, t.clientY) || viewport;
      // Fire a native-like contextmenu
      const cm = new MouseEvent('contextmenu', {
        bubbles: true, cancelable: true, view: window,
        clientX: t.clientX, clientY: t.clientY, button: 2, buttons: 2
      });
      target.dispatchEvent(cm);
      lastTap.t = 0; // reset
    } else {
      lastTap = { t: now, x: t.clientX, y: t.clientY };
    }
  }, {passive:true});

  // --- Two-finger gestures (pinch zoom vs shift+drag) ---
  let pinchStart = null;   // { d0, z0, mid0 }
  let twoDrag = null;      // { startPt, active, tgt }
  const PINCH_THRESHOLD = 6;      // px change in distance to qualify as zoom
  const DRAG_VECTOR_THRESHOLD = 4; // px movement coherence to qualify as drag

  viewport.addEventListener('touchstart', (e)=>{
    if(e.touches.length === 2){
      e.preventDefault();
      const a = e.touches[0], b = e.touches[1];
      pinchStart = { d0: distance(a,b), z0: getZoom(), mid0: midpoint(a,b) };
      twoDrag = { startPt: midpoint(a,b), active: false, tgt: null };
    }
  }, {passive:false});

  viewport.addEventListener('touchmove', (e)=>{
    if(e.touches.length === 2 && pinchStart){
      e.preventDefault();
      const a = e.touches[0], b = e.touches[1];
      const d = distance(a,b);
      const mid = midpoint(a,b);
      const deltaD = d - pinchStart.d0;
      const vec = { x: mid.x - (twoDrag.startPt?.x||mid.x), y: mid.y - (twoDrag.startPt?.y||mid.y) };
      const vecLen = Math.hypot(vec.x, vec.y);

      // Decide gesture: pinch or two-finger drag
      if(Math.abs(deltaD) > PINCH_THRESHOLD){
        // PINCH TO ZOOM
        const scale = d / pinchStart.d0;
        const next = clamp(pinchStart.z0 * scale, 0.05, 4);
        const rect = viewport.getBoundingClientRect();
        const anchor = { x: mid.x - rect.left, y: mid.y - rect.top };
        setZoomAround(next, anchor);
      } else if(vecLen > DRAG_VECTOR_THRESHOLD){
        // TWO-FINGER DRAG => Shift + Left Drag
        const pt = { clientX: mid.x, clientY: mid.y, screenX: 0, screenY: 0 };
        if(!twoDrag.active){
          twoDrag.active = True;
        }
        if(!twoDrag.tgt){
          twoDrag.tgt = synthMouse('mousedown', pt, { shiftKey: true, buttons: 1, button: 0 });
        } else {
          synthMouse('mousemove', pt, { shiftKey: true, buttons: 1, button: 0 });
        }
      }
    }
  }, {passive:false});

  viewport.addEventListener('touchend', (e)=>{
    if(pinchStart && e.touches.length < 2){
      // End pinch/drag
      if(twoDrag && twoDrag.active && twoDrag.tgt){
        const endPt = twoDrag.startPt || {x:0,y:0};
        const pt = { clientX: endPt.x, clientY: endPt.y, screenX: 0, screenY: 0 };
        synthMouse('mouseup', pt, { shiftKey: true, buttons: 0, button: 0 });
      }
      pinchStart = null;
      twoDrag = null;
    }
  }, {passive:true});

  viewport.addEventListener('touchcancel', ()=>{ pinchStart=null; twoDrag=null; }, {passive:true});
})();
</script>





<script id="pointer-gestures-js">
(function(){
  const viewport = document.getElementById('viewport');
  const board = document.getElementById('board');
  if(!viewport || !board) return;

  // Track multiple touch pointers
  const active = new Map(); // pointerId -> {x,y}
  let pinch = null;         // {d0, z0, mid0, lastScale}
  let twoDrag = null;       // {active:boolean, last:{x,y}, tgt:EventTarget|null}
  let mode = 'none';        // 'none' | 'pinch' | 'drag'

  function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
  function getZoom(){ try{ return window.state?.zoom ?? 1; }catch{ return 1; } }
  function setZoomAround(nextZoom, anchor){
    if(!window.applyTransform || !window.state) return;
    const rect = viewport.getBoundingClientRect();
    const prev = getZoom();
    const next = clamp(nextZoom, 0.05, 4);
    const cx = anchor ? anchor.x : rect.width/2;
    const cy = anchor ? anchor.y : rect.height/2;
    const ox = (cx - window.state.origin.x) / prev;
    const oy = (cy - window.state.origin.y) / prev;
    window.state.origin.x = cx - ox * next;
    window.state.origin.y = cy - oy * next;
    window.state.zoom = next;
    window.applyTransform();
  }
  function midpoint(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }
  function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function synthMouse(type, pt, opts){
    const target = document.elementFromPoint(pt.x, pt.y) || viewport;
    const ev = new MouseEvent(type, {
      bubbles:true, cancelable:true, view:window,
      clientX:pt.x, clientY:pt.y,
      buttons: type==='mouseup' ? 0 : (opts && opts.buttons || 1),
      button: (opts && 'button' in opts) ? opts.button : 0,
      shiftKey: !!(opts && opts.shiftKey),
      ctrlKey: !!(opts && opts.ctrlKey),
      altKey: !!(opts && opts.altKey),
      metaKey: !!(opts && opts.metaKey),
    });
    target.dispatchEvent(ev);
    return target;
  }

  // Synthesize a wheel event at (x,y) with deltaY mapped to scale change.
  // Positive deltaY => zoom out, Negative => zoom in (typical browser convention).
  function synthWheelAt(x, y, deltaY){
    const target = document.elementFromPoint(x, y) || viewport;
    const ev = new WheelEvent('wheel', {
      bubbles: true, cancelable: true,
      clientX: x, clientY: y,
      deltaY: deltaY, deltaMode: 0, // pixel
      ctrlKey: true  // many apps treat ctrl+wheel as intentional zoom
    });
    target.dispatchEvent(ev);
    return target;
  }

  function dynamicThresholds(){
    const z = getZoom() || 1;
    const dpr = (window.devicePixelRatio || 1);
    const BASE_PINCH = 10;  // slightly permissive to favor pinch
    const BASE_DRAG  = 12;  // favor pinch over drag when ambiguous
    const zoomFactor = Math.max(0.7, 1 / Math.sqrt(z));
    const pinch = BASE_PINCH * dpr * zoomFactor;
    const drag  = BASE_DRAG  * dpr * zoomFactor;
    return { PINCH_THRESH: pinch, DRAG_THRESH: drag };
  }

  function onPointerDown(e){
    if(e.pointerType !== 'touch') return;
    try{ viewport.setPointerCapture(e.pointerId); }catch{}
    active.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(active.size === 2){
      const pts = Array.from(active.values());
      pinch = { d0: distance(pts[0], pts[1]), z0: getZoom(), mid0: midpoint(pts[0], pts[1]), lastScale: 1 };
      twoDrag = { active:false, last: pinch.mid0, tgt: null };
      mode = 'none';
      e.preventDefault();
    }
  }
  function onPointerMove(e){
    if(e.pointerType !== 'touch') return;
    if(!active.has(e.pointerId)) return;
    active.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(active.size === 2 && pinch){
      const { PINCH_THRESH, DRAG_THRESH } = dynamicThresholds();
      const pts = Array.from(active.values());
      const mid = midpoint(pts[0], pts[1]);
      const d = distance(pts[0], pts[1]);
      const deltaD = d - pinch.d0;
      const vec = { x: mid.x - twoDrag.last.x, y: mid.y - twoDrag.last.y };
      const vecLen = Math.hypot(vec.x, vec.y);

      if(mode === 'none'){
        if(Math.abs(deltaD) > PINCH_THRESH && Math.abs(deltaD) > vecLen * 1.15){
          mode = 'pinch';
        } else if(vecLen > DRAG_THRESH){
          mode = 'drag';
        }
      }

      if(mode === 'pinch'){
        const scale = d / pinch.d0;
        const step = scale / (pinch.lastScale || 1);
        pinch.lastScale = scale;

        // Map to wheel deltaY (log-ish to keep it smooth). Negative = zoom in.
        const k = 480; // sensitivity factor
        const deltaY = -Math.sign(step-1) * Math.min(240, Math.abs(Math.log(step)) * k || 0);

        // Dispatch a wheel event at the pinch midpoint
        const rect = viewport.getBoundingClientRect();
        const px = mid.x; const py = mid.y;
        synthWheelAt(px, py, deltaY);

        // Fallback: if zoom didn't change after 2 frames, use setZoomAround
        const zBefore = getZoom();
        let checks = 0;
        function verify(){
          checks++;
          const zNow = getZoom();
          if(zNow === zBefore && checks < 2){
            requestAnimationFrame(verify);
          } else if(zNow === zBefore){
            // wheel not handled; fallback to direct zoom
            setZoomAround(pinch.z0 * scale, { x: mid.x - rect.left, y: mid.y - rect.top });
          }
        }
        requestAnimationFrame(verify);

        twoDrag.last = mid;
        e.preventDefault();
      } else if(mode === 'drag'){
        if(!twoDrag.active){
          twoDrag.active = true;
          twoDrag.tgt = synthMouse('mousedown', mid, { shiftKey:true, buttons:1, button:0 });
        } else {
          synthMouse('mousemove', mid, { shiftKey:true, buttons:1, button:0 });
        }
        twoDrag.last = mid;
        e.preventDefault();
      }
    }
  }
  function endDragIfNeeded(pt){
    if(twoDrag && twoDrag.active){
      synthMouse('mouseup', pt, { shiftKey:true, buttons:0, button:0 });
    }
  }
  function onPointerUp(e){
    if(e.pointerType !== 'touch') return;
    active.delete(e.pointerId);
    endDragIfNeeded({x:e.clientX, y:e.clientY});
    if(active.size < 2){ pinch = null; twoDrag = null; mode = 'none'; }
  }
  function onPointerCancel(e){
    active.delete(e.pointerId);
    endDragIfNeeded({x:e.clientX, y:e.clientY});
    if(active.size < 2){ pinch = null; twoDrag = null; mode = 'none'; }
  }

  // Use passive:false to ensure preventDefault is honored
  viewport.addEventListener('pointerdown', onPointerDown, {passive:false});
  viewport.addEventListener('pointermove', onPointerMove, {passive:false});
  viewport.addEventListener('pointerup', onPointerUp, {passive:false});
  viewport.addEventListener('pointercancel', onPointerCancel, {passive:false});
})();
</script>

<script id="panel-collapse-to-button-js">
(function(){
  function snapshotStyles(panel){
    if(panel.__snapshotDone) return;
    const cs = getComputedStyle(panel);
    // Save inline styles (what we can faithfully restore)
    panel.__orig = {
      width: panel.style.width || '',
      height: panel.style.height || '',
      maxHeight: panel.style.maxHeight || '',
      maxWidth: panel.style.maxWidth || '',
      overflow: panel.style.overflow || '',
      left: panel.style.left || '',
      right: panel.style.right || '',
      top: panel.style.top || '',
      bottom: panel.style.bottom || ''
    };
    // Also save computed width/height in case there were none inline set
    panel.__origComputed = {
      width: cs.width,
      height: cs.height,
      maxHeight: cs.maxHeight,
      maxWidth: cs.maxWidth
    };
    panel.__snapshotDone = true;
  }

  function restoreStyles(panel){
    if(!panel.__orig) return;
    const o = panel.__orig;
    panel.style.width = o.width;
    panel.style.height = o.height;
    panel.style.maxHeight = o.maxHeight;
    panel.style.maxWidth = o.maxWidth;
    panel.style.overflow = o.overflow;
    panel.style.left = o.left;
    panel.style.right = o.right;
    panel.style.top = o.top;
    panel.style.bottom = o.bottom;
  }

  function applyCollapsedStyles(panel){
    // Keep position, but shrink into a neat button footprint.
    panel.style.width = "44px";
    panel.style.height = "44px";
    panel.style.maxHeight = "44px";
    panel.style.maxWidth = "44px";
    panel.style.overflow = "hidden";
  }

  function makeCollapsible(panel, icon){
    if(!panel || panel.__collapsible) return;
    panel.__collapsible = true;

    // Wrap contents after header into .panel-body for easier hide/show
    let header = panel.querySelector('h3');
    if(!header){
      header = document.createElement('h3');
      header.textContent = 'Panel';
      panel.insertBefore(header, panel.firstChild);
    }
    let body = panel.querySelector('.panel-body');
    if(!body){
      body = document.createElement('div');
      body.className = 'panel-body';
      let sib = header.nextSibling;
      const move = [];
      while(sib){
        const next = sib.nextSibling;
        move.push(sib);
        sib = next;
      }
      move.forEach(n=> body.appendChild(n));
      panel.appendChild(body);
    }

    // Toggle button
    let btn = panel.querySelector('.panel-toggle');
    if(!btn){
      btn = document.createElement('button');
      btn.className = 'panel-toggle';
      btn.title = 'Collapse/Expand';
      btn.textContent = '–';
      panel.appendChild(btn);
    }

    function setCollapsed(yes){
      if(yes){
        snapshotStyles(panel);
        panel.classList.add('panel-collapsed');
        applyCollapsedStyles(panel);
      }else{
        panel.classList.remove('panel-collapsed');
        restoreStyles(panel);
      }
      btn.textContent = yes ? label : '–';
      btn.setAttribute('aria-expanded', (!yes).toString());
    }

    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      setCollapsed(!panel.classList.contains('panel-collapsed'));
    });

    // Clicking the collapsed button area should expand
    panel.addEventListener('click', (e)=>{
      if(panel.classList.contains('panel-collapsed')){
        e.stopPropagation();
        setCollapsed(false);
      }
    });

    // Initialize expanded (keeps current dimensions)
    setCollapsed(false);
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    makeCollapsible(document.querySelector('.url-panel'), '⇧');   // URL panel collapses to button
    makeCollapsible(document.querySelector('.save-panel'), '⇧');  // Save panel collapses to button
  });
})();
</script>


<script id="node-title-edit-js">
(function(){
  function focusEditable(el){
    // Make it contenteditable only during edit
    el.setAttribute('contenteditable','true');
    el.classList.add('editing');
    setTimeout(()=>{
      try{
        const sel = window.getSelection();
        const rng = document.createRange();
        rng.selectNodeContents(el);
        rng.collapse(false);
        sel.removeAllRanges(); sel.addRange(rng);
        el.focus({preventScroll:true});
      }catch(_){ el.focus(); }
    },0);

    function commit(){
      el.removeEventListener('blur', onBlur);
      el.removeEventListener('keydown', onKey);
      el.classList.remove('editing');
      // Keep contenteditable for easier mobile re-focus next time
      el.setAttribute('contenteditable','true');
    }
    function onBlur(){ commit(); }
    function onKey(e){
      if(e.key === 'Enter' || e.key === 'Escape'){
        e.preventDefault();
        commit();
      }
    }
    el.addEventListener('blur', onBlur);
    el.addEventListener('keydown', onKey);
  }

  // Tap or click title to edit
  document.addEventListener('click', function(e){
    const t = e.target.closest('.node .title');
    if(!t) return;
    focusEditable(t);
    // Do not stop propagation; we rely on global code not to preventDefault on click in titles
  }, {passive:true});

  // Prevent global gesture code from hijacking text selection in titles
  // Hint: If there are pointer handlers elsewhere, they should check e.target.closest('.title')
  // and skip preventDefault.
})();
</script>


<script id="group-menu-js">
(function(){
  const groupMenu = document.getElementById('groupMenu');
  const board = document.getElementById('board');

  window.openGroupMenu = function(x, y, group){
    if(!groupMenu || !group) return;
    const vw = window.innerWidth, vh = window.innerHeight;
    const w = 220, h = 140;
    const left = Math.max(8, Math.min(vw - w - 8, x));
    const top  = Math.max(8, Math.min(vh - h - 8, y));
    groupMenu.style.left = left + 'px';
    groupMenu.style.top  = top + 'px';
    groupMenu.classList.add('open');

    
    // Set initial Lock/Unlock label
    (function(){
      const el = (group && (group.el || group)) || null;
      const isLocked = !!(el && (el.dataset.locked==='1' || el.classList.contains('locked'))) || !!group.locked;
      const lockBtn = groupMenu.querySelector('button[data-action="toggle-lock"]');
      if (lockBtn) lockBtn.textContent = isLocked ? 'Unlock' : 'Lock';
    })();
    // Prevent menu from starting drags
    groupMenu.onmousedown = (e)=> e.stopPropagation();
groupMenu.onclick = (e)=>{
      const act = e.target && e.target.dataset && e.target.dataset.action;
      if(!act) return;
      if(act==='toggle-lock'){
        // try to resolve the current group element + data
        const el = (typeof group !== 'undefined' && (group.el || group)) || document.querySelector('.menu.open')?.__ctxEl;
        if (!el) return;
        const next = !(el.dataset.locked === '1' || el.classList.contains('locked'));
        el.classList.toggle('locked', next);
        el.dataset.locked = next ? '1' : '0';
        el.style.cursor = next ? 'default' : 'grab';
        // sync back to group object if available
        if (typeof group !== 'undefined' && group && group.id){
          try { group.locked = next; } catch(_){}
        }
        // flip label
        const lockBtn = groupMenu.querySelector('button[data-action="toggle-lock"]');
        if (lockBtn) lockBtn.textContent = next ? 'Unlock' : 'Lock';
        // close menu after action
        if (typeof closeMenus==='function') closeMenus();
        return;
      }

      if(act==='rename'){
        try{
          const el = group.el || group;
          const t = el.querySelector('.title');
          if(t){
            // Immediate inline rename with caret at end
            t.classList.add('editing');
            t.setAttribute('contenteditable','true');
            setTimeout(()=>{
              try{
                const sel = window.getSelection();
                const rng = document.createRange();
                rng.selectNodeContents(t);
                rng.collapse(false);
                sel.removeAllRanges(); sel.addRange(rng);
                t.focus({preventScroll:true});
              }catch(_){ t.focus(); }
            }, 0);
            // Commit on Enter / Blur
            function commit(){
              t.classList.remove('editing');
              t.setAttribute('contenteditable','true'); // keep editable for mobile ease
              t.removeEventListener('blur', onBlur);
              t.removeEventListener('keydown', onKey);
              // sync title into model if present
              if(group && group.title !== undefined){
                group.title = t.textContent.trim();
              }
            }
            function onBlur(){ commit(); }
            function onKey(ev){
              if(ev.key==='Enter' || ev.key==='Escape'){ ev.preventDefault(); commit(); }
            }
            t.addEventListener('blur', onBlur);
            t.addEventListener('keydown', onKey);
          }
        }catch(err){ console.error('Rename group failed', err); }
      } else if(act==='duplicate'){
        try{
          const src = group;
          const srcEl = src.el || src;
          // Use canonical creation path
          const br = document.getElementById('board').getBoundingClientRect();
          const r  = srcEl.getBoundingClientRect();
          const at = { x: r.left - br.left + 24, y: r.top - br.top + 24 };
          if(typeof createGroup === 'function'){
            const g2 = createGroup(at);
            // Copy properties
            if(g2){
              g2.w = src.w || srcEl.offsetWidth;
              g2.h = src.h || srcEl.offsetHeight;
              g2.color = src.color || (getComputedStyle(srcEl).borderColor);
              g2.title = src.title || (srcEl.querySelector('.title')?.textContent || 'Group');
              // Apply to DOM
              g2.el.style.width  = g2.w + 'px';
              g2.el.style.height = g2.h + 'px';
              g2.el.style.borderColor = g2.color;
              const t2 = g2.el.querySelector('.title');
              if(t2) t2.textContent = g2.title;
            }
          }else{
            console.warn('createGroup() not available; falling back to shallow clone');
            const clone = srcEl.cloneNode(true);
            clone.classList.remove('selected');
            clone.style.left = at.x + 'px';
            clone.style.top  = at.y + 'px';
            document.getElementById('board').appendChild(clone);
          }
        }catch(err){ console.error('Duplicate group failed', err); }
      } else if(act==='delete'){
        try{
          const el = group.el || group;
          el.remove();
          // remove from state if present
          if(window.state && Array.isArray(state.groups)){
            state.groups = state.groups.filter(g=> g.id !== (group.id || el.dataset.id));
          }
        }catch(err){ console.error('Delete group failed', err); }
      }
      groupMenu.classList.remove('open');
    };
  };
})();
</script>


<script>
(function(){
  function positionMinimized(urlPanel, savePanel){
    if(!urlPanel || !savePanel) return;
    if(urlPanel.classList.contains('panel-collapsed')){
      const urlRectTop = parseInt(urlPanel.style.top || 80, 10);
      const urlRectLeft = parseInt(urlPanel.style.left || 16, 10);
      urlPanel.style.left = (isNaN(urlRectLeft)?16:urlRectLeft) + 'px';
      urlPanel.style.top  = (isNaN(urlRectTop)?80:urlRectTop) + 'px';
      if(savePanel.classList.contains('panel-collapsed')){
        const gap = 12;
        savePanel.style.left = urlPanel.style.left;
        const baseTop = parseInt(urlPanel.style.top,10) || 80;
        savePanel.style.top  = (baseTop + 56 + gap) + 'px';
      }
    }
    window.__positionMinimized = positionMinimized;
  }
  window.__positionMinimized = positionMinimized;
  window.addEventListener('resize', ()=>{
    const urlPanel=document.querySelector('.url-panel'); const savePanel=document.querySelector('.save-panel');
    positionMinimized(urlPanel, savePanel);
  });
})();
</script>

<script>

/* === Wire ID helpers (for export/import) === */
function getIdForEl(el){
  if (!el) return null;
  if (el.dataset && el.dataset.id) return el.dataset.id;
  const n = (state.nodes || []).find(n => n.el === el); if (n) return n.id;
  const t = (state.textboxes || []).find(t => t.element === el); if (t) return t.id;
  if (window.checklistNodes){
    const c = window.checklistNodes.find(c => c.element === el); if (c) return c.id;
  }
  return null;
}
function resolveElementById(id){
  if (!id) return null;
  const n = (state.nodes || []).find(n => n.id === id); if (n && n.el) return n.el;
  const t = (state.textboxes || []).find(t => t.id === id); if (t && t.element) return t.element;
  if (window.checklistNodes){
    const c = window.checklistNodes.find(c => c.id === id); if (c && c.element) return c.element;
  }
  return document.querySelector('[data-id=\"' + id + '\"]');
}

</script>

<script>
  (function(){
    'use strict';
  
    /* ---------- Small polyfills / guards ---------- */
    if (!window.CSS) window.CSS = {};
    if (typeof CSS.escape !== 'function') {
      CSS.escape = function (s) {
        return String(s).replace(/[^a-zA-Z0-9_\-]/g, '\\$&');
      };
    }
  
    /* ---------- Wire layer + drawing (keeps your semantics) ---------- */
    if (typeof window.ensureWiresLayer !== 'function') {
      window.ensureWiresLayer = function ensureWiresLayer(){
        var svg = document.getElementById('wires');
        if (svg) return svg;
        var host = document.getElementById('viewport') || document.body;
        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'wires';
        svg.setAttribute('width','50000');
        svg.setAttribute('height','50000');
        svg.style.position = 'absolute';
        svg.style.left = '0px';
        svg.style.top = '0px';
        svg.style.pointerEvents = 'none';
        host.insertBefore(svg, host.firstChild);
        return svg;
      };
    }
  
    function centerOf(el){
      if (!el) return {x:0,y:0};
      var vp = document.getElementById('viewport') || document.body;
      var vr = vp.getBoundingClientRect();
      var r  = el.getBoundingClientRect();
      return { x: (r.left + r.width/2) - vr.left, y: (r.top + r.height/2) - vr.top };
    }
  
    function pathEl(cls, w){
      var p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      p.setAttribute('class', cls);
      p.setAttribute('fill', 'none');
      p.setAttribute('stroke-width', String(w));
      p.setAttribute('stroke-linecap', 'round');
      p.setAttribute('stroke-linejoin', 'round');
      return p;
    }
  
    if (typeof window.makeWire !== 'function') {
      window.makeWire = function makeWire(fromEl, toEl){
        var svg = ensureWiresLayer();
        var g   = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  
        var path = pathEl('wire-path', 2);  path.setAttribute('stroke', '#ffffffA0');
        var hit  = pathEl('wire-hit-area', 14); hit.setAttribute('stroke', 'transparent'); hit.style.pointerEvents = 'stroke';
  
        g.appendChild(path);
        g.appendChild(hit);
        svg.appendChild(g);
  
        var wire = { fromEl: fromEl, toEl: toEl, c1: null, c2: null, g: g, path: path, hit: hit };
  
        try {
          g.dataset.fromId = (fromEl && fromEl.dataset && fromEl.dataset.id) || '';
          g.dataset.toId   = (toEl   && toEl.dataset   && toEl.dataset.id)   || '';
        } catch (_){}
  
        if (!window.state) window.state = {};
        if (!Array.isArray(state.wires)) state.wires = [];
        state.wires.push(wire);
  
        updateWire(wire);
        return wire;
      };
    }
  
    if (typeof window.updateWire !== 'function') {
      window.updateWire = function updateWire(w){
        if (!w || !w.fromEl || !w.toEl) return;
        var p0 = centerOf(w.fromEl);
        var p3 = centerOf(w.toEl);
        var c1 = (w.c1 && Number.isFinite(w.c1.x)) ? w.c1 : { x: p0.x + (p3.x - p0.x) * 0.33, y: p0.y };
        var c2 = (w.c2 && Number.isFinite(w.c2.x)) ? w.c2 : { x: p3.x - (p3.x - p0.x) * 0.33, y: p3.y };
        var d  = "M " + p0.x + " " + p0.y + " C " + c1.x + " " + c1.y + ", " + c2.x + " " + c2.y + ", " + p3.x + " " + p3.y;
        if (w.path && typeof w.path.setAttribute === 'function') w.path.setAttribute('d', d);
        if (w.hit  && typeof w.hit.setAttribute  === 'function') w.hit.setAttribute('d', d);
      };
    }
  
    if (typeof window.updateAllWires !== 'function') {
      window.updateAllWires = function updateAllWires(){
        if (!window.state || !Array.isArray(state.wires)) return;
        state.wires = state.wires.filter(function(w){ return w && w.fromEl && w.toEl; });
        for (var i=0; i<state.wires.length; i++){
          try { updateWire(state.wires[i]); } catch (_){}
        }
      };
      window.addEventListener('resize', function(){ try { updateAllWires(); } catch(_){} });
    }
  
    /* ---------- Anchor fallback for missing endpoints ---------- */
    if (typeof window.createWireAnchor !== 'function') {
      window.createWireAnchor = function createWireAnchor(x, y){
        var vp = document.getElementById('viewport') || document.body;
        var el = document.createElement('div');
        el.className = 'wire-anchor';
        el.style.position = 'absolute';
        el.style.left = (x||0) + 'px';
        el.style.top  = (y||0) + 'px';
        el.style.width = '2px';
        el.style.height = '2px';
        el.style.pointerEvents = 'none';
        if (!window.state) window.state = {};
        if (typeof state.nextId !== 'number') state.nextId = 100000;
        el.dataset.id = 'anchor-' + (state.nextId++);
        vp.appendChild(el);
        return el;
      };
    }
  
    /* ---------- Robust ID resolver across nodes/textboxes/checklists ---------- */
    function resolveById(id){
      if (!id) return null;
  
      // Prefer your app's helpers if present
      if (typeof window.getElement === 'function'){
        var e1 = window.getElement(id);
        if (e1) return e1;
      }
      if (typeof window.resolveElementById === 'function'){
        var e2 = window.resolveElementById(id);
        if (e2) return e2;
      }
  
      // Fallback to [data-id="..."]
      try {
        return document.querySelector('[data-id="' + CSS.escape(id) + '"]');
      } catch (_){
        // ultra-safe fallback without CSS.escape
        return document.querySelector('[data-id="' + String(id).replace(/"/g, '\\"') + '"]');
      }
    }
  
    /* ---------- Unified, safe restore (this is your replacement) ---------- */
    function restoreWiresFromBoardData(boardData){
      var list = (boardData && boardData.wires) ? boardData.wires : [];
      if (!list.length) { console.log('[Wires] No wires to restore.'); return; }
  
      // Defer to next frame so layout & dataset ids are ready
      requestAnimationFrame(function(){
        var restored = 0;
  
        for (var i=0; i<list.length; i++){
          var wd = list[i];
  
          // Resolve endpoints by ID, regardless of type (node/textbox/checklist)
          var fromEl = resolveById(wd.fromId);
          var toEl   = resolveById(wd.toId);
  
          // Fallback to anchor positions if provided in JSON
          if (!fromEl && wd.fromAt) fromEl = createWireAnchor(wd.fromAt.x || 0, wd.fromAt.y || 0);
          if (!toEl   && wd.toAt)   toEl   = createWireAnchor(wd.toAt.x   || 0, wd.toAt.y   || 0);
  
          if (!fromEl || !toEl) {
            console.warn('[Wires] Skipping, endpoint missing', wd);
            continue;
          }
  
          var wire = makeWire(fromEl, toEl);
  
          // Respect saved bezier handles (only fall back if absent)
          if (wd.c1 && Number.isFinite(wd.c1.x) && Number.isFinite(wd.c1.y)) wire.c1 = { x: wd.c1.x, y: wd.c1.y };
          if (wd.c2 && Number.isFinite(wd.c2.x) && Number.isFinite(wd.c2.y)) wire.c2 = { x: wd.c2.x, y: wd.c2.y };
  
          updateWire(wire);
          restored++;
          try { console.log('[Wires] Restored', wd.fromId, '→', wd.toId, wire); } catch(_){}
        }
  
        try { updateAllWires(); } catch(_){}
        console.log('[Wires] Done. Restored:', restored);
      });
    }
  
    // Export the unified restore (overwrites older duplicates)
    window.restoreWiresFromBoardData = restoreWiresFromBoardData;
  
    /* ---------- Optional: ensure restore runs after loadBoardData ---------- */
    if (!window.__patchedLoadBoardData && typeof window.loadBoardData === 'function') {
      var __orig = window.loadBoardData;
      window.loadBoardData = async function(boardData){
        try { console.log('Importing board: wires=', (boardData && boardData.wires && boardData.wires.length) || 0); } catch(_){}
        var res = await __orig.call(this, boardData);
        try {
          requestAnimationFrame(function(){
            try { restoreWiresFromBoardData(boardData); } catch(e){ console.warn('[Wires] restore error:', e); }
          });
        } catch(e){ console.warn('[Wires] rAF missing:', e); }
        return res;
      };
      window.__patchedLoadBoardData = true;
    }
  })();
  </script>
  
<script id="unified-multidrag-checklists">
/* Unified multi-drag when a checklist is selected */
(function(){
  if (!window.state || !window.getElement) return;

  function screenToWorldLocal(sx, sy){
    try{ if (typeof screenToWorld === 'function') return screenToWorld(sx, sy); }catch(_){}
    const vp = document.getElementById('viewport') || document.body;
    const rect = vp.getBoundingClientRect();
    const zoom = (window.state && window.state.zoom) ? window.state.zoom : 1;
    const origin = (window.state && window.state.origin) ? window.state.origin : {x:0,y:0};
    return { x: (sx - rect.left - origin.x) / zoom, y: (sy - rect.top - origin.y) / zoom };
  }

  function getChecklistById(id){
    const arr = (window.checklistNodes || []);
    for (let i=0;i<arr.length;i++){
      if (arr[i].id === id) return arr[i];
    }
    return null;
  }

  function anyChecklistSelected(){
    const ids = Array.from(window.state.selection || []);
    for (const id of ids){
      const el = window.getElement(id);
      if (el && el.classList && el.classList.contains('checknode')) return true;
    }
    return false;
  }

  function buildStartMap(){
    const map = new Map();
    const ids = Array.from(window.state.selection || []);
    ids.forEach((sid)=>{
      // Node
      const n = (typeof getNodeById==='function') ? getNodeById(sid) : null;
      if (n && n.el){ map.set(sid, {type:'node', x:n.x, y:n.y, w:n.w, h:n.h, el:n.el}); return; }
      // Group
      const g = (typeof getGroupById==='function') ? getGroupById(sid) : null;
      if (g && g.el){ map.set(sid, {type:'group', x:g.x, y:g.y, w:g.w, h:g.h, el:g.el}); return; }
      // Textbox
      const t = (typeof getTextboxById==='function') ? getTextboxById(sid) : null;
      if (t && t.element){
        const lx = parseFloat(t.element.style.left)||0;
        const ly = parseFloat(t.element.style.top)||0;
        const lw = t.element.offsetWidth || parseFloat(t.element.style.width) || 0;
        const lh = t.element.offsetHeight || parseFloat(t.element.style.height) || 0;
        map.set(sid, {type:'textbox', x:lx, y:ly, w:lw, h:lh, el:t.element});
        return;
      }
      // Checklist
      const c = getChecklistById(sid);
      if (c && c.element){
        const cx = parseFloat(c.element.style.left)||c.x||0;
        const cy = parseFloat(c.element.style.top)||c.y||0;
        const cw = c.element.offsetWidth || parseFloat(c.element.style.width) || 0;
        const ch = c.element.offsetHeight || parseFloat(c.element.style.height) || 0;
        map.set(sid, {type:'check', x:cx, y:cy, w:cw, h:ch, el:c.element});
        return;
      }
    });
    return map;
  }

  function startUnifiedDrag(e, hostEl){
    // Only run when selection includes a checklist (avoid fighting existing handlers)
    if (!anyChecklistSelected()) return false;

    // For textboxes: require Shift unless clicking chrome (so normal typing stays)
    if (hostEl && hostEl.classList.contains('textbox')){
      const isContentEditable = e.target.closest('.textbox');
      const isResizer = e.target.classList && e.target.classList.contains('tb-resizer');
      if (isContentEditable && !e.shiftKey && !isResizer){
        return false;
      }
    }

    // Skip controls that shouldn't initiate override
    if (e.target.closest('.tb-resizer, input, textarea, [contenteditable="true"]')) return false;

    e.preventDefault();
    e.stopPropagation();

    const startWorld = screenToWorldLocal(e.clientX, e.clientY);
    const startMap   = buildStartMap();

    // Feedback
    const prevCursor = hostEl && hostEl.style ? hostEl.style.cursor : '';
    if (hostEl && hostEl.style) hostEl.style.cursor = 'grabbing';

    const prevUserSelect = document.body.style.userSelect;
    document.body.style.userSelect = 'none';

    function onMove(ev){
      const w = screenToWorldLocal(ev.clientX, ev.clientY);
      const dx = w.x - startWorld.x;
      const dy = w.y - startWorld.y;

      startMap.forEach((sp, sid)=>{
        if (sp.type==='node'){
          const x = sp.x + dx, y = sp.y + dy;
          const n = (typeof getNodeById==='function') ? getNodeById(sid) : null;
          if (n){ n.x = x; n.y = y; }
          if (sp.el){ sp.el.style.left = x+'px'; sp.el.style.top = y+'px'; }
        } else if (sp.type==='group'){
          const x = sp.x + dx, y = sp.y + dy;
          const g = (typeof getGroupById==='function') ? getGroupById(sid) : null;
          if (g){ g.x = x; g.y = y; }
          if (sp.el){ sp.el.style.left = x+'px'; sp.el.style.top = y+'px'; }
        } else if (sp.type==='textbox'){
          const x = sp.x + dx, y = sp.y + dy;
          if (sp.el){ sp.el.style.left = x+'px'; sp.el.style.top = y+'px'; }
        } else if (sp.type==='check'){
          const x = sp.x + dx, y = sp.y + dy;
          const c = getChecklistById(sid);
          if (c){ c.x = x; c.y = y; }
          if (sp.el){ sp.el.style.left = x+'px'; sp.el.style.top = y+'px'; }
        }
      });

      try{ if (typeof updateAllWires==='function') updateAllWires(); }catch(_){}
    }

    function onUp(){
      window.removeEventListener('mousemove', onMove, {passive:false});
      window.removeEventListener('mouseup', onUp,   {passive:false});
      if (hostEl && hostEl.style) hostEl.style.cursor = prevCursor || '';
      document.body.style.userSelect = prevUserSelect;
    }

    window.addEventListener('mousemove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp,   {passive:false});
    return true;
  }

  // Capture early so we can cancel the app's native node/group drag when needed
  document.addEventListener('mousedown', function(e){
    const host = e.target.closest('.node, .group, .textbox');
    if (!host) return;
    if (e.button !== 0) return; // left only
    if (!window.state || !(window.state.selection && window.state.selection.size)) return;

    // If clicked item isn't yet in selection, add it without clearing
    const hid = (host && host.dataset && host.dataset.id) ? host.dataset.id : null;
    if (hid && !window.state.selection.has(hid)) {
      try{ window.state.selection.add(hid); host.classList.add('selected'); }catch(_){}
    }

    // Only take over when at least one checklist is part of the selection
    if (!anyChecklistSelected()) return;

    // Start unified drag and block the native handler
    startUnifiedDrag(e, host);
  }, true); // capture
})();
</script>

    <script id="retro-theme-persist">
    (function(){
      const sel = document.getElementById('theme');
      try{
        const saved = localStorage.getItem('blankspace-theme');
        if (saved) {
          document.documentElement.classList.remove('light','retro');
          if (saved==='light') document.documentElement.classList.add('light');
          if (saved==='retro') document.documentElement.classList.add('retro');
          if (sel) sel.value = saved;
        }
        if (sel){
          sel.addEventListener('change', function(){
            try{ localStorage.setItem('blankspace-theme', sel.value); }catch(_){}
          });
        }
      }catch(_){}
    })();
    

// --- PATCH: reusable duplication helpers ---

// --- PATCH: reusable deletion helpers ---
function deleteGroupObject(group){
  if (!group) return;
  if (state && state.selection) state.selection.delete(group.id);
  if (group.el && group.el.remove) try { group.el.remove(); } catch(_){}
  if (window.state && Array.isArray(state.groups)){
    state.groups = state.groups.filter(g => g !== group);
  }
}

function deleteSelection(anchorId){
  if (!window.state) return;
  const selection = (state && state.selection) ? state.selection : new Set();
  const ids = (selection.size > 1 && selection.has(anchorId))
    ? Array.from(selection)
    : [anchorId];

  ids.forEach((sid)=>{
    // remove sid from active selection
    if (state && state.selection) state.selection.delete(sid);

    // Node
    if (typeof getNodeById === 'function'){
      const n = getNodeById(sid);
      if (n && typeof deleteNode === 'function'){ deleteNode(n); return; }
    }
    // Group (inline behavior from group menu)
    if (typeof getGroupById === 'function'){
      const g = getGroupById(sid);
      if (g){ deleteGroupObject(g); return; }
    }
    // Textbox
    if (typeof getTextboxById === 'function'){
      const t = getTextboxById(sid);
      if (t && typeof removeTextbox === 'function'){ removeTextbox(t); return; }
    }
    // Checklist
    if (Array.isArray(window.checklistNodes)){
      const c = window.checklistNodes.find(x => x && x.id === sid);
      if (c && c.element && typeof deleteChecklistNode === 'function'){
        deleteChecklistNode(c.element); return;
      }
      // fallback: query by data-id
      const el = document.querySelector(`[data-id="${CSS.escape(String(sid))}"].checknode`);
      if (el && typeof deleteChecklistNode === 'function'){ deleteChecklistNode(el); return; }
    }
  });

  if (typeof updateAllWires === 'function'){
    try { updateAllWires(); } catch(_) {}
  }
  if (typeof markDirty === 'function') markDirty('delete');
}


// Reuse the same behavior your group menu already performs for a single group
function duplicateGroup(group){
  if (!group || typeof createGroup !== 'function') return null;
  const g2 = createGroup({ x: group.x + 20, y: group.y + 20 });
  if (g2){
    g2.w = group.w; g2.h = group.h;
    g2.color = group.color; g2.title = (group.title || ('Group '+g2.id)) + ' copy';
    g2.locked = !!group.locked;
    if (g2.el){
      g2.el.style.width  = g2.w + 'px';
      g2.el.style.height = g2.h + 'px';
      g2.el.style.borderColor = g2.color;
      const tt = g2.el.querySelector('.title'); if (tt) tt.textContent = g2.title;
      g2.el.classList.toggle('locked', !!g2.locked);
      g2.el.dataset.locked = g2.locked ? '1' : '0';
      g2.el.style.cursor = g2.locked ? 'default' : 'grab';
    }
  }
  return g2;
}

// Duplicate either the entire selection (if the anchor is selected and multiple are selected)
// or just the anchor itself.
function duplicateSelection(anchorId){
  if (!window.state) return;
  const selection = (state && state.selection) ? state.selection : new Set();
  const ids = (selection.size > 1 && selection.has(anchorId))
    ? Array.from(selection)
    : [anchorId];

  ids.forEach((sid)=>{
    // Node
    if (typeof getNodeById === 'function'){
      const n = getNodeById(sid);
      if (n && typeof duplicateNode === 'function'){ duplicateNode(n); return; }
    }
    // Group
    if (typeof getGroupById === 'function'){
      const g = getGroupById(sid);
      if (g){ duplicateGroup(g); return; }
    }
    // Textbox
    if (typeof getTextboxById === 'function'){
      const t = getTextboxById(sid);
      if (t && typeof duplicateTextbox === 'function'){ duplicateTextbox(t); return; }
    }
    // Checklist
    if (Array.isArray(window.checklistNodes)){
      const c = window.checklistNodes.find(x => x && x.id === sid);
      if (c && c.element && typeof duplicateChecklistNode === 'function'){
        duplicateChecklistNode(c.element);
        return;
      }
    }
  });
}

</script>
    

<script>
if (!window.state) window.state = {};
if (!state.timelines) state.timelines = [];
if (!state.nextId) state.nextId = 100000;

window.getTimelineById = function(id){
  return (state.timelines || []).find(tl => String(tl.id) === String(id));
};
function _nextId(){ state.nextId = (state.nextId || 1) + 1; return state.nextId; }

window.createTimeline = function(opts){
  const dir = (opts && opts.direction) || 'h';
  const at  = (opts && opts.at) || {x:100, y:100};
  const len = (opts && opts.length) || 300;
  const thick = (opts && opts.thickness) || 6;

  const el = document.createElement('div');
  el.className = 'timeline ' + (dir==='v' ? 'vertical' : 'horizontal');
  el.style.left = at.x + 'px';
  el.style.top  = at.y + 'px';
  el.style.width  = (dir==='v' ? (thick + 'px') : (len + 'px'));
  el.style.height = (dir==='v' ? (len + 'px')   : (thick + 'px'));
  const id = _nextId(); el.dataset.id = String(id);

  const line = document.createElement('div');
  line.className = 'timeline-line';
  line.style.color = '#111';
  el.appendChild(line);

  const hit = document.createElement('div'); hit.className='tl-hit'; el.appendChild(hit);
    if (dir==='v'){
    const h1 = document.createElement('div'); h1.className = 'tl-handle top'; el.appendChild(h1);
    const h2 = document.createElement('div'); h2.className = 'tl-handle bottom'; el.appendChild(h2);
  } else {
    const h1 = document.createElement('div'); h1.className = 'tl-handle left'; el.appendChild(h1);
    const h2 = document.createElement('div'); h2.className = 'tl-handle right'; el.appendChild(h2);
  }

  (window.board || document.getElementById('board')).appendChild(el);

  const tl = { id, x:at.x, y:at.y, w:(dir==='v'?thick:len), h:(dir==='v'?len:thick), direction:dir,
               el, line, timestamps:[], stroke:'#111', strokeWidth:thick, fill:'transparent', border:'transparent', locked:false };
  tl.markRadius = (typeof tl.markRadius==='number' ? tl.markRadius : 12);
  tl.markShape = tl.markShape || 'circle';
  tl.markRadius = 12;
  enableTimelineInteractions(tl);
  (opts && opts.suppressDefaults) ? void 0 : (function addDefaultStamps(){

    try {
      const r = (typeof tl.markRadius==='number') ? tl.markRadius : 12;
      const size = r*2;
      if (tl.direction==='h'){
        window.addTimelineTimestamp(tl, Math.max(0, Math.round(0.2*tl.w - size/2)));
        window.addTimelineTimestamp(tl, Math.max(0, Math.round(0.5*tl.w - size/2)));
        window.addTimelineTimestamp(tl, Math.max(0, Math.round(0.8*tl.w - size/2)));
      } else {
        window.addTimelineTimestamp(tl, Math.max(0, Math.round(0.2*tl.h - size/2)));
        window.addTimelineTimestamp(tl, Math.max(0, Math.round(0.5*tl.h - size/2)));
        window.addTimelineTimestamp(tl, Math.max(0, Math.round(0.8*tl.h - size/2)));
      }
      // apply initial shape
      applyMarkShapeToAll(tl);
    } catch(_){}
  
})();
state.timelines.push(tl);
  return tl;
};

function enableTimelineInteractions(tl){
  const el = tl.el;

  function selectSelf(e){
    if (!e.shiftKey && typeof window.clearSelection === 'function') clearSelection();
    (state.selection || (state.selection = new Set())).add(tl.id);
    el.classList.add('selected');
  }

  // drag move (ignore timestamp drags)
  el.addEventListener('mousedown', (e)=>{
    if (e.button!==0) return;
    if (e.target.classList.contains('tl-handle')) return;
    if (e.target.closest && e.target.closest('.tl-mark')) return;
    if (tl.locked) return;
    e.stopPropagation();
    selectSelf(e);
    const start = {x:e.clientX, y:e.clientY, x0:tl.x, y0:tl.y};
    function mm(ev){
      const dx = (ev.clientX - start.x)/(state.zoom||1);
      const dy = (ev.clientY - start.y)/(state.zoom||1);
      tl.x = start.x0 + dx; tl.y = start.y0 + dy;
      el.style.left = tl.x+'px'; el.style.top = tl.y+'px';
    }
    function up(){ window.removeEventListener('mousemove', mm, true); window.removeEventListener('mouseup', up, true); }
    window.addEventListener('mousemove', mm, true);
    window.addEventListener('mouseup', up, true);
  });

  // resize ends
  el.querySelectorAll('.tl-handle').forEach(h=>{
    h.addEventListener('mousedown', (e)=>{
      if (e.button!==0) return;
      if (tl.locked) return;
      e.stopPropagation();
      selectSelf(e);
      const start = {x:e.clientX, y:e.clientY, w:tl.w, h:tl.h, x0:tl.x, y0:tl.y};
      function mm(ev){
        const dx = (ev.clientX - start.x)/(state.zoom||1);
        const dy = (ev.clientY - start.y)/(state.zoom||1);
        if (tl.direction==='h'){
          if (h.classList.contains('left')){
            tl.x = start.x0 + dx; tl.w = Math.max(40, start.w - dx);
            el.style.left = tl.x+'px'; el.style.width = tl.w+'px';
          } else {
            tl.w = Math.max(40, start.w + dx);
            el.style.width = tl.w+'px';
          }
        } else {
          if (h.classList.contains('top')){
            tl.y = start.y0 + dy; tl.h = Math.max(40, start.h - dy);
            el.style.top = tl.y+'px'; el.style.height = tl.h+'px';
          } else {
            tl.h = Math.max(40, start.h + dy);
            el.style.height = tl.h+'px';
          }
        }
      }
      function up(){ window.removeEventListener('mousemove', mm, true); window.removeEventListener('mouseup', up, true); }
      window.addEventListener('mousemove', mm, true);
      window.addEventListener('mouseup', up, true);
    });
  });

  // timestamp drag (only the mark moves)
  el.addEventListener('mousedown', (e)=>{
    const mark = (e.target.closest && e.target.closest('.tl-mark')) || null;if(!mark) return;if (e.button!==0) return;e.stopPropagation();selectSelf(e);
    const start = {x:e.clientX, y:e.clientY, left:parseFloat(mark.style.left)||0, top:parseFloat(mark.style.top)||0};
    function mm(ev){
      const dx = (ev.clientX - start.x)/(state.zoom||1);
      const dy = (ev.clientY - start.y)/(state.zoom||1);
      if (tl.direction==='h'){
        let nx = start.left + dx;
      const mw = mark.offsetWidth || 24;
      nx = Math.max(0, Math.min(nx, tl.w - mw));
      mark.style.left = nx + 'px';
        mark.style.top  = (tl.h/2 - (mark.offsetHeight/2)) + 'px';
      } else {
        let ny = start.top + dy;
      const mh = mark.offsetHeight || 24;
      ny = Math.max(0, Math.min(ny, tl.h - mh));
      mark.style.top  = ny + 'px';
        mark.style.left = (tl.w/2 - (mark.offsetWidth/2)) + 'px';
      }
    
      // move linked group (if any) along the same axis
      try{
        const mobj = (tl.timestamps||[]).find(m => m && m.el === mark);
        if (mobj && mobj.linkedGroupId){
          const g = (typeof getGroupById==='function') ? getGroupById(mobj.linkedGroupId) : null;
          if (g){
            const size = mark.offsetWidth || 24;
            if (tl.direction==='h'){
              const lc = (parseFloat(mark.style.left)||0) + size/2;
              g.x = tl.x + lc - (g.w||g.el.offsetWidth||200)/2;
              if (g.el) g.el.style.left = g.x+'px';
            } else {
              const tc = (parseFloat(mark.style.top)||0) + size/2;
              g.y = tl.y + tc - (g.h||g.el.offsetHeight||100)/2;
              if (g.el) g.el.style.top = g.y+'px';
            }
          }
        }
      }catch(_){}
}
    function up(){ window.removeEventListener('mousemove', mm, true); window.removeEventListener('mouseup', up, true); }
    window.addEventListener('mousemove', mm, true);
    window.addEventListener('mouseup', up, true);
  });
// [removed] timestamp resize handle code disabled
// context menu
  el.addEventListener('contextmenu', (e)=>{
    // If right-click is on a timestamp, let the timestamp menu handle it
    const markEl = e.target.closest && e.target.closest('.tl-mark');
    if (markEl) return;
    e.preventDefault(); e.stopPropagation();
    window.openTimelineMenu(e.clientX, e.clientY, tl);
  });
}

window.addTimelineTimestamp = function(tl, posPx){
  const mark = document.createElement('div');
  mark.className = 'tl-mark';
  const size = (tl && typeof tl.markRadius==='number' ? Math.max(6, tl.markRadius)*2 : 24);
  mark.style.width = size+'px'; mark.style.height = size+'px';

  // Inherit timeline-level timestamp fill color
  try {
    if (tl && tl.markFill){ mark.style.background = tl.markFill; }
    else if (tl && tl.el && window.getComputedStyle){
      var __mf = getComputedStyle(tl.el).getPropertyValue('--tl-mark-fill');
      if (__mf && __mf.trim()) mark.style.background = __mf.trim();
    }
  } catch(_) {}
  if (tl.direction==='h'){
    mark.style.left = (typeof posPx==='number' ? posPx : (tl.w/2 - size/2)) + 'px';
    mark.style.top  = (tl.h/2 - size/2) + 'px';
  } else {
    mark.style.top  = (typeof posPx==='number' ? posPx : (tl.h/2 - size/2)) + 'px';
    mark.style.left = (tl.w/2 - size/2) + 'px';
  }const hit = document.createElement('div'); hit.className='hit'; mark.appendChild(hit);
  tl.el.appendChild(mark);
  // Right-click on mark to open its menu
  mark.addEventListener('contextmenu', (e)=>{ e.preventDefault(); e.stopPropagation(); window.openTimestampMenu(e.clientX, e.clientY, tl, mark); });
  
  // Also attach contextmenu to the enlarged hit area
  const hitEl = mark.querySelector && mark.querySelector('.hit');
  if (hitEl){
    hitEl.addEventListener('contextmenu', (e)=>{
      e.preventDefault(); e.stopPropagation();
      window.openTimestampMenu(e.clientX, e.clientY, tl, mark);
    });
  }
(tl.timestamps || (tl.timestamps=[])).push({ id: _nextId(), el:mark });
  return mark;
};

window.openTimelineMenu = function(x,y, tl){
  const menu = document.getElementById('timelineMenu');
  if(!menu || !tl) return;
  if (typeof closeMenus==='function') closeMenus();
  menu.style.left = (x + (window.scrollX||0))+'px';
  menu.style.top  = (y + (window.scrollY||0))+'px';
  menu.classList.add('open');
  menu.onmousedown = (e)=>e.stopPropagation();

  // Tabs
  const tabs = Array.from(menu.querySelectorAll('.tabs .tab'));
  const panels = Array.from(menu.querySelectorAll('.panel'));
  function activateTab(name){
    tabs.forEach(t=>t.classList.toggle('active', t.dataset.tab===name));
    panels.forEach(p=>{
      const on = (p.dataset.panel===name);
      p.classList.toggle('active', on);
      p.style.display = on ? 'flex' : 'none';
    });
  }
  tabs.forEach(t=>t.onclick = (ev)=>{ ev.preventDefault(); ev.stopPropagation(); activateTab(t.dataset.tab); });
  const ap = menu.querySelector('.panel.active'); if (ap) ap.style.display = 'flex';

  // Inputs
  const strokeInp = menu.querySelector('#tl-stroke-color');
  const widthInp  = menu.querySelector('#tl-stroke-width');
  const patternSel= menu.querySelector('#tl-stroke-pattern');
  const fillInp   = menu.querySelector('#tl-fill-color');
  const tsColorInp = menu.querySelector('#tl-mark-fill-color');
  const alphaInp = menu.querySelector('#tl-fill-alpha');
  const alphaLbl = menu.querySelector('#tl-fill-alpha-val');
  const shapeSel  = menu.querySelector('#tl-mark-shape');
  let   markRadInput = menu.querySelector('#tl-mark-radius');

  // helpers
  function parseRGB(str){
    const m = str && str.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!m) return null;
    return {r:parseInt(m[1],10), g:parseInt(m[2],10), b:parseInt(m[3],10)};
  }
  function toHex(r){ const s = r.toString(16); return s.length<2?('0'+s):s; }
  function toColorInput(v){
    const d = document.createElement('div'); d.style.color = v; document.body.appendChild(d);
    const rgb = getComputedStyle(d).color; document.body.removeChild(d);
    const c = parseRGB(rgb);
    return c ? ('#'+toHex(c.r)+toHex(c.g)+toHex(c.b)) : '#111111';
  }

  // preload
  try { if (tl.stroke) strokeInp.value = toColorInput(tl.stroke); } catch(_){}
  try { widthInp.value = (tl.strokeWidth || (tl.direction==='h'? tl.h : tl.w) || 6); } catch(_){}
  try { fillInp.value = toColorInput(tl.fill || '#ffffff'); } catch(_){}

  try {
    if (tsColorInp){
      var col = '#ffffff';
      try {
        if (tl.timestamps && tl.timestamps.length && tl.timestamps[0].el){
          col = getComputedStyle(tl.timestamps[0].el).backgroundColor;
        } else if (tl.el && tl.el.style && tl.el.style.getPropertyValue){
          var varCol = tl.el.style.getPropertyValue('--tl-mark-fill');
          if (varCol) col = varCol;
        }
      } catch(_){}
      tsColorInp.value = toColorInput(col);
    }
  } catch(_){}

  try{
    if (alphaInp){
      var alpha = 1;
      try{
        var base = tl.fill || (tl.line ? getComputedStyle(tl.line).backgroundColor : '');
        var m = /rgba?\(([^)]+)\)/i.exec(base);
        if (m){
          var parts = m[1].split(',').map(function(x){return x.trim();});
          if (parts.length >= 4) alpha = parseFloat(parts[3]);
        }
      }catch(_){}
      if (!isFinite(alpha) || alpha<0) alpha = 1;
      alphaInp.value = Math.round(alpha*100);
      if (alphaLbl) alphaLbl.textContent = alphaInp.value + '%';
    }
  }catch(_){}
try { patternSel.value = (tl.el && getComputedStyle(tl.el).borderStyle==='dashed') ? 'dashed' : 'solid'; } catch(_){}
  try { if (shapeSel) shapeSel.value = tl.markShape || 'circle'; } catch(_){}
  try {
    if (markRadInput){
      if (typeof tl.markRadius==='number') { markRadInput.value = Math.max(6, tl.markRadius); }
      else if (tl.timestamps && tl.timestamps.length) {
        const s = tl.timestamps[0].el.offsetWidth || 24;
        markRadInput.value = Math.max(6, Math.round(s/2));
      } else {
        markRadInput.value = 12;
      }
    }
  } catch(_){}

  // bindings
  if (strokeInp) strokeInp.oninput = (ev)=>{
    const c = ev.target.value;
    tl.stroke = c;
    tl.el.style.color = c;
    if (getComputedStyle(tl.el).borderWidth !== '0px' && tl.el.style.borderColor) {
      tl.el.style.borderColor = c;
    }
  };
  if (widthInp) widthInp.oninput = (ev)=>{
    const w = Math.max(1, parseInt(ev.target.value,10)||6);
    tl.strokeWidth = w;
    if (tl.direction==='h'){ tl.h = w; tl.el.style.height = w+'px'; }
    else { tl.w = w; tl.el.style.width = w+'px'; }
    // re-center marks to the axis after thickness change
    (tl.timestamps||[]).forEach(m=>{
      const el = m.el; if (!el) return;
      if (tl.direction==='h'){ el.style.top = (tl.h/2 - (el.offsetHeight||24)/2) + 'px'; }
      else { el.style.left = (tl.w/2 - (el.offsetWidth||24)/2) + 'px'; }
    });
  };
  if (patternSel) patternSel.onchange = (ev)=>{
    const v = ev.target.value;
    if (v==='dashed'){ tl.el.style.borderStyle='dashed'; tl.el.style.borderWidth='1px'; tl.el.style.borderColor = tl.stroke || '#111'; }
    else { tl.el.style.borderStyle='solid'; tl.el.style.borderWidth='0px'; }
  };
  if (fillInp) fillInp.oninput = (ev)=>{
    function hexToRgb(hex){
      var m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : null;
    }
    var rgb = hexToRgb(ev.target.value) || {r:17,g:17,b:17};
    var a = 1;
    try { a = alphaInp ? Math.max(0, Math.min(1, parseFloat(alphaInp.value)/100)) : 1; } catch(_){ a = 1; }
    tl.fill = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + a + ')';
    if (tl.line) tl.line.style.background = tl.fill;
  };
  if (alphaInp) alphaInp.oninput = (ev)=>{
    var val = Math.max(0, Math.min(100, parseInt(ev.target.value||'0',10)));
    ev.target.value = val;
    if (alphaLbl) alphaLbl.textContent = val + '%';
    function hexToRgb(hex){
      var m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)} : null;
    }
    var base = (fillInp && fillInp.value) ? fillInp.value : '#ffffff';
    var rgb = hexToRgb(base) || {r:255,g:255,b:255};
  if (tsColorInp) tsColorInp.oninput = (ev)=>{
    var c = ev.target.value || '#ffffff';
    tl.markFill = c;
    try { if (tl.el && tl.el.style && tl.el.style.setProperty) tl.el.style.setProperty('--tl-mark-fill', c); } catch(_){}
    try { (tl.timestamps||[]).forEach(function(m){ if (m && m.el) m.el.style.background = c; }); } catch(_){}
  };

    var a = val/100;
    tl.fill = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + a + ')';
    if (tl.line) tl.line.style.background = tl.fill;
  };
  if (shapeSel) shapeSel.onchange = (ev)=>{
    tl.markShape = ev.target.value || 'circle';
    if (typeof applyMarkShapeToAll === 'function') applyMarkShapeToAll(tl);
    // refresh centering/sizing for bar
    (tl.timestamps||[]).forEach(m=>{
      const el=m.el; if(!el) return;
      const r = (typeof tl.markRadius==='number'?tl.markRadius:12); const size = r*2; const thick=4;
      if (tl.markShape==='bar'){
        if (tl.direction==='h'){ el.style.width=thick+'px'; el.style.height=size+'px'; el.style.top=(tl.h/2 - size/2)+'px'; }
        else { el.style.width=size+'px'; el.style.height=thick+'px'; el.style.left=(tl.w/2 - size/2)+'px'; }
      } else {
        if (tl.direction==='h'){ el.style.top=(tl.h/2 - size/2)+'px'; }
        else { el.style.left=(tl.w/2 - size/2)+'px'; }
      }
    });
  };
  if (markRadInput) markRadInput.oninput = (ev)=>{
    let r = parseInt(ev.target.value,10);
    if (isNaN(r) || r<6) r = 6;
    tl.markRadius = r;
    const size = r*2;
    const isBar = (tl.markShape === 'bar');
    (tl.timestamps||[]).forEach(m=>{
      const el = m.el; if (!el) return;
      const keepLeft = parseFloat(el.style.left)||0;
      const keepTop  = parseFloat(el.style.top)||0;
      if (isBar){
        const thick = 4;
        if (tl.direction==='h'){ el.style.width = thick+'px'; el.style.height = size+'px'; el.style.top  = (tl.h/2 - size/2) + 'px'; el.style.left = keepLeft + 'px'; }
        else { el.style.width = size+'px'; el.style.height = thick+'px'; el.style.left = (tl.w/2 - size/2) + 'px'; el.style.top  = keepTop + 'px'; }
        el.style.background = 'currentColor'; el.style.border='0'; el.style.borderRadius='2px';
      } else {
        el.style.width = size+'px'; el.style.height = size+'px';
        if (tl.direction==='h'){ el.style.top  = (tl.h/2 - size/2) + 'px'; el.style.left = keepLeft + 'px'; }
        else { el.style.left = (tl.w/2 - size/2) + 'px'; el.style.top  = keepTop + 'px'; }
      }
    });
  };

    // Actions panel clicks
  menu.onclick = (e)=>{
    const act = e.target && e.target.dataset && e.target.dataset.action; if(!act) return;
    if (act==='add-timestamp'){ window.addTimelineTimestamp(tl); closeMenus && closeMenus(); return; }
    if (act==='duplicate'){ window.createTimeline({direction: tl.direction, at:{x:tl.x+24,y:tl.y+24}, length: (tl.direction==='h'? tl.w:tl.h), thickness: (tl.direction==='h'? tl.h: tl.w)}); closeMenus && closeMenus(); return; }
    if (act==='delete'){ try{ tl.el.remove(); }catch(_){ } state.timelines = (state.timelines||[]).filter(x=>x!==tl); if (state.selection) state.selection.delete(tl.id); closeMenus && closeMenus(); return; }
  };
};
</script>


<script>
window.openTimestampMenu = function(x,y, tl, markEl){
  try{ console.log('[TimestampMenu] open for', markEl && markEl.dataset ? markEl.dataset.id : markEl); }catch(_){ }
  const menu = document.getElementById('timestampMenu');
  if(!menu || !tl || !markEl) return;
  if (typeof closeMenus==='function') closeMenus();
  menu.style.left = (x + (window.scrollX||0))+'px';
  menu.style.top  = (y + (window.scrollY||0))+'px';
  menu.classList.add('open');
  menu.onmousedown = (e)=>e.stopPropagation();

  menu.onclick = (e)=>{
    const act = e.target && e.target.dataset && e.target.dataset.action;
    if (!act) return;

    if (act==='delete'){
      try{
        // Remove this timestamp element and its model entry
        if (Array.isArray(tl.timestamps)){
          const idx = tl.timestamps.findIndex(m => m && m.el === markEl);
          if (idx >= 0){
            try { if (tl.timestamps[idx].el && tl.timestamps[idx].el.remove) tl.timestamps[idx].el.remove(); } catch(_){}
            tl.timestamps.splice(idx, 1);
          } else {
            try { if (markEl && markEl.remove) markEl.remove(); } catch(_){}
          }
        } else {
          try { if (markEl && markEl.remove) markEl.remove(); } catch(_){}
        }
        // Clear selection if selected
        try{
          if (markEl && markEl.dataset && markEl.dataset.id && state.selection) state.selection.delete(markEl.dataset.id);
        }catch(_){}
      }catch(err){ console.error('[TimestampMenu] delete failed', err); }
      if (typeof closeMenus==='function') closeMenus();
      return;
    }

    if (act==='create-timezone'){
      const mobj = (tl.timestamps||[]).find(m => m && m.el === markEl);
      if (!mobj) { if (typeof closeMenus==='function') closeMenus(); return; }
      // place group near this timestamp
      const size = markEl.offsetWidth || 24;
      const left = parseFloat(markEl.style.left)||0;
      const top  = parseFloat(markEl.style.top)||0;
      let gx, gy;
      if (tl.direction==='h'){
        const markCenter = left + size/2;
        gx = tl.x + markCenter - 100;   // center group on mark
        gy = tl.y - 120;                 // above the line
      } else {
        const markCenter = top + size/2;
        gx = tl.x + tl.w + 80;           // to the right
        gy = tl.y + markCenter - 50;     // center vertically
      }
      let g = null;
      try{
        if (typeof createGroup === 'function'){
          g = createGroup({x: gx, y: gy});
          if (g && g.el){ g.el.style.width='200px'; g.el.style.height='100px'; }
        }
        if (g && g.id){ mobj.linkedGroupId = g.id; }
      }catch(err){ console.error('[TimestampMenu] create-timezone failed', err); }
      if (typeof closeMenus==='function') closeMenus();
      return;
    }
  };
};
</script>

<script>
(function(){
  function _num(v,d){ v=parseFloat(v); return isFinite(v)?v:(d||0); }
  function _collectTimelinesFallback(){
    var out=[], els=document.querySelectorAll('.timeline');
    els.forEach(function(el){
      try{
        var vertical=el.classList.contains('vertical');
        var line=el.querySelector('.timeline-line');
        var ls=line?getComputedStyle(line):null;
        var cs=getComputedStyle(el);
        var tl={
          id: el.dataset.id||null,
          x: _num(el.style.left), y:_num(el.style.top),
          w: _num(el.style.width), h:_num(el.style.height),
          direction: vertical?'v':'h',
          stroke: cs.color||'', strokeWidth: vertical?_num(cs.width):_num(cs.height),
          fill: ls?ls.backgroundColor:'', border: cs.borderColor||'',
          pattern: cs.borderStyle||'solid', markRadius:12, markShape:normalizeMarkShape('circle'),
          timestamps: []
        };
        el.querySelectorAll('.tl-mark').forEach(function(mark){
          tl.timestamps.push({
            x:_num(mark.style.left), y:_num(mark.style.top),
            size: mark.offsetWidth||24,
            linkedGroupId: (mark.dataset&&mark.dataset.linkedGroupId)||null
          });
        });
        out.push(tl);
      }catch(e){}
    });
    return out;
  }
  if (typeof window.exportBoardDataWithFiles==='function' && !window.__tlWrap2){
    window.__tlWrap2=true;
    var _orig=window.exportBoardDataWithFiles;
    window.exportBoardDataWithFiles=async function(){
      var data=await _orig.apply(this, arguments);
      try{
        var list=(window.state&&Array.isArray(state.timelines)&&state.timelines.length)?state.timelines:_collectTimelinesFallback();
        data.timelines=(list||[]).map(function(tl){
          var el=tl.el||document.querySelector('.timeline[data-id="'+(tl.id||'')+'"]');
          var cs=el?getComputedStyle(el):null;
          var line=el?el.querySelector('.timeline-line'):null;
          var ls=line?getComputedStyle(line):null;
          const firstTsEl = (tl && tl.timestamps && tl.timestamps[0] && tl.timestamps[0].el) ? tl.timestamps[0].el : null;
return {
            id: tl.id||(el&&el.dataset.id)||null,
            x: _num(tl.x!=null?tl.x:(el&&el.style.left)), y: _num(tl.y!=null?tl.y:(el&&el.style.top)),
            w: _num(tl.w!=null?tl.w:(el&&el.style.width)), h: _num(tl.h!=null?tl.h:(el&&el.style.height)),
            direction: tl.direction||(el&&el.classList.contains('vertical')?'v':'h'),
            stroke: tl.stroke||(cs?cs.color:''),
            strokeWidth: _num(tl.strokeWidth!=null?tl.strokeWidth:(cs?(tl.direction==='h'?cs.height:cs.width):0)),
            fill: tl.fill||(ls?ls.backgroundColor:''),
            border: tl.border||(cs?cs.borderColor:''),
            pattern: tl.pattern||(cs?cs.borderStyle:'solid'),
            markRadius: (typeof tl.markRadius==='number'?tl.markRadius:12),
            markShape: tl.markShape||'circle',
            timestamps: (tl.timestamps||[]).map(function(m){
              var mel=m.el||null;
              const firstTsEl = (tl && tl.timestamps && tl.timestamps[0] && tl.timestamps[0].el) ? tl.timestamps[0].el : null;
return {
                x:_num(m.x!=null?m.x:(mel&&mel.style.left)), y:_num(m.y!=null?m.y:(mel&&mel.style.top)),
                size:_num(m.size!=null?m.size:(mel&&mel.offsetWidth))||24,
                linkedGroupId: m.linkedGroupId||((mel&&mel.dataset)&&mel.dataset.linkedGroupId)||null
              };
            })
          };
        });
      }catch(e){}
      return data;
    };
  }
})();
</script>


<script>
(function(){
  if (!window.__patchedLoadBoardData_TL2 && typeof window.loadBoardData==='function'){
    window.__patchedLoadBoardData_TL2=true;
    var __orig=window.loadBoardData;
    window.loadBoardData=async function(boardData){
      var res=await __orig.call(this, boardData);
      try{
        requestAnimationFrame(function(){
          if (typeof finalizeTimelineRestore==='function') {
            try{ finalizeTimelineRestore(boardData); }catch(e){ console.warn('[TL finalize]', e); }
          }
        });
      }catch(e){}
      return res;
    };
  }
})();
</script>


<script>
(function(){
  function finalizeTimelineRestore(boardData){
    try{
      (state.groups||[]).forEach(function(g){ try{ if(g&&g.el&&g.id){ g.el.dataset.id = g.id; } }catch(_){}});
      function groupById(id){
        if (!id) return null;
        if (typeof getGroupById==='function') return getGroupById(id);
        var gs = state.groups||[]; for (var i=0;i<gs.length;i++){ if (gs[i] && gs[i].id===id) return gs[i]; }
        return null;
      }
      (state.timelines||[]).forEach(function(tl){
        if (!tl || !tl.timestamps) return;
        tl.timestamps.forEach(function(m){
          if (!m || !m.linkedGroupId) return;
          if (!groupById(m.linkedGroupId)){
            var mark = m.el;
            var gx = 0, gy = 0;
            try{
              var size = (mark && mark.offsetWidth)||24;
              if (tl.direction==='h'){
                gx = (tl.x||parseFloat(tl.el.style.left)||0) + (parseFloat(mark.style.left)||0) - 100;
                gy = (tl.y||parseFloat(tl.el.style.top)||0) - 120;
              } else {
                gx = (tl.x||parseFloat(tl.el.style.left)||0) + (tl.w||parseFloat(tl.el.style.width)||6) + 80;
                gy = (tl.y||parseFloat(tl.el.style.top)||0) + (parseFloat(mark.style.top)||0) - 50;
              }
            }catch(_){}
            var g = (typeof createGroup==='function') ? createGroup({x: gx, y: gy}) : null;
            if (g){
              try{ g.id = m.linkedGroupId; }catch(_){}
              try{ if (g.el) g.el.dataset.id = m.linkedGroupId; }catch(_){}
            }
          }
        });
      });
    }catch(e){ console.warn('[Timeline] finalize restore error:', e); }
  }
  window.finalizeTimelineRestore = finalizeTimelineRestore;
})();
</script>


<script>
// Ensure mark-shape changes propagate to all timestamps on a timeline
(function(){
  if (typeof window.applyMarkShapeToAll !== 'function'){
    window.applyMarkShapeToAll = function(tl){
        // Guard: only allow circle/square/bar; fallback to circle
        try {
          var _shape = (shape || tl.markShape || 'circle').toLowerCase();
          if (!/^(circle|square|bar)$/.test(_shape)) _shape = 'circle';
          shape = _shape;
        } catch(_) { shape = 'circle'; }
        
      if (!tl || !tl.timestamps) return;
      var shape = tl.markShape || 'circle';
      (tl.timestamps || []).forEach(function(m){
        var el = m && m.el;
        if (!el) return;
        // reset
        try{
          el.style.borderRadius = '';
          el.style.clipPath = '';
          el.style.transform = '';
          el.style.borderWidth = el.style.borderWidth || '2px';
        }catch(_){}
        // apply
        try{
          if (shape === 'circle'){
            el.style.borderRadius = '50%';
          } else if (shape === 'square'){
            el.style.borderRadius = '4px';
          } else if (shape === 'diamond'){
            el.style.borderRadius = '2px';
            el.style.transform = 'rotate(45deg)';
          } else if (shape === 'triangle'){
            // A simple upwards triangle; remove border to avoid odd corners
            el.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
            el.style.borderWidth = '0px';
          } else if (shape === 'bar'){
            el.style.borderRadius = '2px';
            // width/height recalc handled by the style panel's onchange code
          } else {
            // default fallback
            el.style.borderRadius = '50%';
          }
        }catch(_){}
      });
    };
  }
})();
</script>


    <script>
    // Paint all marks on this timeline with a given color (and remember it)
    window.applyTimelineMarkFill = function(tl, color){
      if (!tl) return;
      if (color) {
        try { tl.markFill = color; } catch(_){}
        try { if (tl.el && tl.el.style && tl.el.style.setProperty) tl.el.style.setProperty('--tl-mark-fill', color); } catch(_){}
      }
      var c = (tl && tl.markFill) || color || '#ffffff';
      try {
        (tl.timestamps||[]).forEach(function(m){ if (m && m.el) m.el.style.background = c; });
      } catch(_){}
    };
    </script>
    

    <script>
    function normalizeMarkShape(shape){
      shape = (shape || 'circle').toLowerCase();
      return (/^(circle|square|bar)$/.test(shape) ? shape : 'circle');
    }
    </script>
    

<!-- Copy/Paste + Selection Safety Net -->
<script>
(function(){
  function isEditableTarget(t){
    if(!t) return false;
    if (t.isContentEditable) return true;
    const tag = (t.tagName||'').toLowerCase();
    if (tag === 'input' || tag === 'textarea') return true;
    try { if (t.closest && t.closest('[contenteditable="true"]')) return true; } catch(_){}
    return false;
  }

  // Do NOT hijack native copy/paste/cut/select-all in editables
  window.addEventListener('keydown', function(e){
    const k = (e.key||'').toLowerCase();
    if ((e.ctrlKey || e.metaKey) && (k==='c' || k==='v' || k==='x' || k==='a')){
      if (isEditableTarget(e.target)) {
        // let the browser handle it
        return;
      }
      // If the app implements its own shortcuts elsewhere, don't block here.
      // Intentionally no preventDefault() so system clipboard keeps working.
    }
  }, true); // capture so we run before other handlers

  // Ensure selection gets re-enabled even if a mouseup was missed during drags
  (function installUserSelectReset(){
    function reset(){ try{ document.body.style.userSelect=''; }catch(_){} }
    window.addEventListener('blur', reset, true);
    document.addEventListener('mouseleave', reset, true);
    document.addEventListener('mouseup', reset, true);
    document.addEventListener('dragend', reset, true);
    document.addEventListener('pointerup', reset, true);
  })();

  // Guard: if any global handlers call preventDefault on copy/paste/cut in editables, neutralize by early return
  ['copy','paste','cut','keydown','keypress','keyup'].forEach(function(type){
    window.addEventListener(type, function(e){
      if (isEditableTarget(e.target)) {
        // Make sure events from editables are not treated as canvas shortcuts
        // (no-op — presence in capture phase helps avoid accidental global blocks).
      }
    }, true);
  });
})();
</script>

<!-- Canvas Copy/Paste (multi-select, paste at cursor) -->
<script>
  (function(){
    let lastMouseWorld = {x:0, y:0};
    const boardEl = document.getElementById('board') || document;
  
    function isEditable(el){
      if(!el) return false;
      if (el.isContentEditable) return true;
      const tag = (el.tagName||'').toLowerCase();
      return tag==='input' || tag==='textarea';
    }
  
    // FIX: numeric helper that doesn’t mis-treat 0 as falsy
    function numAny(v, fallback){
      const n = (typeof v === 'number') ? v : parseFloat(v);
      return Number.isFinite(n) ? n : (Number.isFinite(fallback) ? fallback : 0);
    }
  
    // Track cursor in world coords
    function screenToWorldLocal(sx, sy){
      try{ if (typeof screenToWorld === 'function') return screenToWorld(sx, sy); }catch(_){}
      const vp = document.getElementById('viewport') || document.body;
      const rect = vp.getBoundingClientRect();
      const zoom = (window.state && window.state.zoom) ? window.state.zoom : 1;
      const origin = (window.state && window.state.origin) ? window.state.origin : {x:0,y:0};
      return { x: (sx - rect.left - origin.x) / zoom, y: (sy - rect.top - origin.y) / zoom };
    }
  
    boardEl.addEventListener('mousemove', (e)=>{
      try{
        const pt = screenToWorldLocal(e.clientX, e.clientY);
        lastMouseWorld = pt;
        window.lastMouseWorld = pt;
      }catch(_){}
    }, true);
  
    function copySelectionToClipboard(){
      if (!window.state || !state.selection || !state.selection.size) return;
      window._internalClipboard = { ids: Array.from(state.selection), ts: Date.now() };
    }
  
    function pasteFromClipboardAt(point){
      const clip = window._internalClipboard;
      if (!clip || !Array.isArray(clip.ids) || !clip.ids.length) return;
  
      // 1) Compute selection top-left in WORLD space to align to cursor
      let minx = Infinity, miny = Infinity;
      clip.ids.forEach((sid)=>{
        const n  = (typeof getNodeById==='function')      ? getNodeById(sid)      : null;
        const g  = (typeof getGroupById==='function')     ? getGroupById(sid)     : null;
        const t  = (typeof getTextboxById==='function')   ? getTextboxById(sid)   : null;
        const ck = (window.checklistNodes || window.checklists || []).find(c => c && c.id === sid) || null;
        const tl = (typeof window.getTimelineById==='function') ? window.getTimelineById(sid) : null;
  
        let xx = null, yy = null;
        if (n && Number.isFinite(n.x) && Number.isFinite(n.y)) {
          xx = n.x; yy = n.y;
        } else if (g && Number.isFinite(g.x) && Number.isFinite(g.y)) {
          xx = g.x; yy = g.y;
        } else if (t && (t.element || Number.isFinite(t.x) || Number.isFinite(t.y))) {
          const tel = t.element || null;
          xx = numAny(tel && tel.style && tel.style.left, t && t.x);
          yy = numAny(tel && tel.style && tel.style.top,  t && t.y);
        } else if (ck) {
          const cel = ck.element || null;
          xx = numAny(cel && cel.style && cel.style.left, ck && ck.x);
          yy = numAny(cel && cel.style && cel.style.top,  ck && ck.y);
        } else if (tl && Number.isFinite(tl.x) && Number.isFinite(tl.y)) {
          xx = tl.x; yy = tl.y;
        }
  
        if (xx != null && yy != null) {
          if (xx < minx) minx = xx;
          if (yy < miny) miny = yy;
        }
      });
  
      const dx = isFinite(minx) ? (point.x - minx) : 24;
      const dy = isFinite(miny) ? (point.y - miny) : 24;
  
      const newIds = [];
  
      // 2) Duplicate each selected item
      clip.ids.forEach((sid)=>{
  
        // Node
        if (typeof getNodeById==='function'){
          const n = getNodeById(sid);
          if (n && typeof createNode==='function'){
            const at = {x: (n.x||0) + dx, y: (n.y||0) + dy};
            const sz = {w: n.w||0, h: n.h||0};
            const n2 = createNode(n.kind, n.assetUrl, sz, at, n.meta);
            if (n2 && n2.id) newIds.push(n2.id);
            return;
          }
        }
  
        // Group
        if (typeof getGroupById==='function'){
          const g = getGroupById(sid);
          if (g && typeof createGroup==='function'){
            const g2 = createGroup({x: (g.x||0) + dx, y: (g.y||0) + dy});
            if (g2){
              g2.w = g.w; g2.h = g.h; g2.color = g.color; g2.locked = !!g.locked;
              if (g2.el){
                g2.el.style.width  = (g2.w||0)+'px';
                g2.el.style.height = (g2.h||0)+'px';
                if (g2.color) g2.el.style.borderColor = g2.color;
              }
              if (g2.id) newIds.push(g2.id);
            }
            return;
          }
        }
  
        // Textbox
        if (typeof getTextboxById==='function' && typeof createFloatingTextbox==='function'){
          const tb = getTextboxById(sid);
          if (tb && tb.element){
            const tel = tb.element;
            const lx = numAny(tel.style && tel.style.left,  tb.x);
            const ly = numAny(tel.style && tel.style.top,   tb.y);
            const w  = numAny(tel.style && tel.style.width,  tb.w || tel.offsetWidth);
            const h  = numAny(tel.style && tel.style.height, tb.h || tel.offsetHeight);
            const html = tel.innerHTML;
  
            // createFloatingTextbox expects {x,y}
            const tb2 = createFloatingTextbox({x: lx + dx, y: ly + dy});
            if (tb2 && tb2.element){
              if (w) tb2.element.style.width  = w + 'px';
              if (h) tb2.element.style.height = h + 'px';
              try{
                const safe = (typeof sanitizeHtml==='function') ? sanitizeHtml(html) : html;
                tb2.element.innerHTML = safe || '';
                tb2.hasPlaceholder = false;
                tb2.isEditing = false;
              }catch(_){}
              if (tb2.id) newIds.push(tb2.id);
              else if (tb2.element && tb2.element.dataset && tb2.element.dataset.id) newIds.push(tb2.element.dataset.id);
            }
            return;
          }
        }
  
        // Checklist
        const ck = (window.checklistNodes || window.checklists || []).find(c => c && c.id === sid) || null;
        if (ck && typeof window.addChecklistNodeAt==='function'){
          try{
            const nodeEl = ck.element;
            const textEl = nodeEl ? (nodeEl.querySelector && nodeEl.querySelector('.checktext')) : null;
            const tx = numAny(nodeEl && nodeEl.style && nodeEl.style.left, ck.x);
            const ty = numAny(nodeEl && nodeEl.style && nodeEl.style.top,  ck.y);
            const w  = numAny(nodeEl && nodeEl.style && nodeEl.style.width,  ck.w || (nodeEl && nodeEl.offsetWidth));
            const h  = numAny(nodeEl && nodeEl.style && nodeEl.style.height, ck.h || (nodeEl && nodeEl.offsetHeight));
            const bg = (nodeEl && nodeEl.style && nodeEl.style.backgroundColor) || ck.bg || '';
            const border = (nodeEl && nodeEl.style && nodeEl.style.borderColor)  || ck.border || '';
            const color  = (nodeEl && nodeEl.style && nodeEl.style.color)        || ck.color || '';
            const fontSize = (textEl && textEl.style && textEl.style.fontSize) || ck.fontSize || '';
            const htmlTxt = textEl ? (typeof sanitizeHtml==='function' ? sanitizeHtml(textEl.innerHTML) : textEl.innerHTML)
                                   : (ck.html || ck.text || '');
            const textPlain = ck.text || (textEl ? textEl.textContent : '');
            const newEl = window.addChecklistNodeAt(tx + dx, ty + dy, textPlain, !!ck.checked, w, h, {bg, border, color, html: htmlTxt}, null, fontSize);
            if (newEl && newEl.dataset && newEl.dataset.id) newIds.push(newEl.dataset.id);
          }catch(_){}
          return;
        }
  
        // Timelines (optional; no-op if APIs missing)
        if (typeof window.getTimelineById==='function' && typeof window.addTimeline==='function'){
          try{
            const tl = window.getTimelineById(sid);
            if (tl){
              const at = {x:(tl.x||0)+dx, y:(tl.y||0)+dy};
              const t2 = window.addTimeline(at.x, at.y, tl.w||2, tl.h||300, tl.direction||'h', tl.stroke||'', tl.strokeWidth||1, tl.fill||'', tl.border||'', tl.pattern||'solid');
              if (t2 && tl.timestamps && Array.isArray(tl.timestamps)){
                tl.timestamps.forEach((m)=>{
                  const pos = (tl.direction==='h') ? (m.x||0) : (m.y||0);
                  const mark = window.addTimelineTimestamp(t2, pos);
                  if (mark && m.size){ mark.style.width = m.size+'px'; mark.style.height = m.size+'px'; }
                });
              }
              if (t2 && t2.id) newIds.push(t2.id);
            }
          }catch(_){}
          return;
        }
      });
  
      // 3) Select new items and refresh
      if (typeof clearSelection==='function'){ try{ clearSelection(); }catch(_){} }
      if (typeof selectId==='function'){ newIds.forEach(id => { try{ selectId(id); }catch(_){} }); }
      if (typeof applyTransform==='function'){ try{ applyTransform(); }catch(_){} }
    }
  
    window.addEventListener('keydown', (e)=>{
      // Don't intercept when typing in text fields or contenteditable
      if (isEditable(document.activeElement)) return;
      if ((e.ctrlKey||e.metaKey) && !e.shiftKey && e.key && e.key.toLowerCase()==='c'){
        e.preventDefault();
        copySelectionToClipboard();
      }
      if ((e.ctrlKey||e.metaKey) && !e.shiftKey && e.key && e.key.toLowerCase()==='v'){
        e.preventDefault();
        const pt = window.lastMouseWorld || lastMouseWorld || {x:0,y:0};
        pasteFromClipboardAt(pt);
      }
    }, true);
  })();  <!-- FIX: correctly close & invoke the IIFE -->
 </script>
  

<style id="resize-handle-style">
/* Generic resize handle */
.resize-handle {
  position: absolute;
  width: 12px;
  height: 12px;
  right: 2px;
  bottom: 2px;
  border: 1px solid rgba(0,0,0,.35);
  background: rgba(255,255,255,.85);
  border-radius: 3px;
  cursor: se-resize;
  box-shadow: 0 0 0 1px rgba(0,0,0,.05), 0 1px 2px rgba(0,0,0,.20);
  z-index: 3;
}
/* Make sure hosts are positioned to contain handle */
.checknode, .node.video, .node.youtube {
  position: absolute;
}
</style>

<script id="resize-handles-patch">
(function(){
  if (window.__resizeHandlesApplied) return;
  window.__resizeHandlesApplied = true;

  function num(v, fb){ var n = parseFloat(v); return isFinite(n) ? n : (isFinite(fb) ? fb : 0); }
  function getId(el){ return (el && el.dataset) ? el.dataset.id : null; }
  function stop(e){ e.stopPropagation(); if (e.cancelable) e.preventDefault(); }

  function ensureHandle(el, kind){
    if (!el || el.querySelector('.resize-handle')) return;
    var h = document.createElement('div');
    h.className = 'resize-handle';
    h.title = 'Drag to resize';
    el.appendChild(h);

    h.addEventListener('mousedown', function(e){
      stop(e);
      var startX = e.clientX, startY = e.clientY;
      var startW = el.offsetWidth, startH = el.offsetHeight;
      var id = getId(el);
      var keepAR = e.shiftKey;
      var ar = startW && startH ? (startW / startH) : 0;

      var prevSel = document.body.style.userSelect;
      document.body.style.userSelect = 'none';

      function mm(ev){
        var dx = ev.clientX - startX;
        var dy = ev.clientY - startY;
        var w = Math.max(60, startW + dx);
        var h = Math.max(40, startH + dy);
        if (keepAR && ar){
          if (Math.abs(dx) > Math.abs(dy)) h = Math.round(w / ar);
          else w = Math.round(h * ar);
        }
        el.style.width = w + 'px';
        el.style.height = h + 'px';

        // Update model
        try{
          if (kind === 'checklist'){
            var list = (window.checklistNodes || window.checklists || []);
            for (var i=0;i<list.length;i++){
              var ck = list[i];
              if (ck && String(ck.id) === String(id)){
                ck.w = w; ck.h = h;
                // optional aliases for export robustness
                ck.width = w; ck.height = h;
                break;
              }
            }
          } else if (kind === 'video' || kind === 'youtube'){
            if (typeof getNodeById === 'function'){
              var n = getNodeById(id);
              if (n){ n.w = w; n.h = h; }
            }
          }
        }catch(_){}
        try{ if (typeof applyTransform==='function') applyTransform(); }catch(_){}
      }

      function up(){
        window.removeEventListener('mousemove', mm, true);
        window.removeEventListener('mouseup', up, true);
        document.body.style.userSelect = prevSel;
        try{ if (typeof markDirty==='function') markDirty('resize'); }catch(_){}
      }

      window.addEventListener('mousemove', mm, true);
      window.addEventListener('mouseup', up, true);
    });
  }

  function scan(){
    // Checklists
    var cks = document.querySelectorAll('.checknode[data-id]');
    for (var i=0;i<cks.length;i++){ ensureHandle(cks[i], 'checklist'); }
    // Video nodes (and YouTube embeds if desired)
    var vids = document.querySelectorAll('.node.video[data-id], .node.youtube[data-id]');
    for (var j=0;j<vids.length;j++){ ensureHandle(vids[j], vids[j].classList.contains('youtube') ? 'youtube' : 'video'); }
  }

  // Initial scan
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', scan, { once: true });
  } else { scan(); }

  // Observe future additions
  var mo = new MutationObserver(function(muts){
    for (var m=0;m<muts.length;m++){
      var rec = muts[m];
      if (!rec.addedNodes) continue;
      for (var k=0;k<rec.addedNodes.length;k++){
        var nd = rec.addedNodes[k];
        if (!(nd instanceof HTMLElement)) continue;
        if (nd.matches && nd.matches('.checknode[data-id]')) ensureHandle(nd, 'checklist');
        if (nd.matches && (nd.matches('.node.video[data-id]') || nd.matches('.node.youtube[data-id]'))){
          ensureHandle(nd, nd.classList.contains('youtube') ? 'youtube' : 'video');
        }
        // Also check descendants
        var innerCks = nd.querySelectorAll ? nd.querySelectorAll('.checknode[data-id]') : [];
        for (var a=0;a<innerCks.length;a++){ ensureHandle(innerCks[a], 'checklist'); }
        var innerV = nd.querySelectorAll ? nd.querySelectorAll('.node.video[data-id], .node.youtube[data-id]') : [];
        for (var b=0;b<innerV.length;b++){ ensureHandle(innerV[b], innerV[b].classList.contains('youtube') ? 'youtube' : 'video'); }
      }
    }
  });
  mo.observe(document.body, { childList: true, subtree: true });
})();
</script>
</body></html>
